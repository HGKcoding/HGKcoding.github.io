<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hu Guokang&#39;s Blog</title>
  
  <subtitle>Stupid is as stupid does.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://huguokang.com/"/>
  <updated>2018-03-10T08:48:07.675Z</updated>
  <id>http://huguokang.com/</id>
  
  <author>
    <name>胡国康</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2018年3月9日面试总结</title>
    <link href="http://huguokang.com/2018/03/10/2018%E5%B9%B43%E6%9C%889%E6%97%A5%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <id>http://huguokang.com/2018/03/10/2018年3月9日面试总结/</id>
    <published>2018-03-09T16:00:00.000Z</published>
    <updated>2018-03-10T08:48:07.675Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>来到朋友在南京租的房子里住下后，我就开始着手找工作这一“伟大事业”了。原先是在<em>拉钩网</em>上投的简历，可是基本上是石沉大海。然后我就尝试着在<em>Boss直聘</em>上投，一开始因为李文星事件就对这个招聘网站没什么好感，但是为了能找到工作我就奋不顾身了。哈哈，其实没我说的这么夸张，李文星事件之后<em>Boss直聘</em>就开始重视对招聘公司信息的审核，所以现在比以前好多了，唯一要注意提防的就是那种通过0基础、高薪、各种补贴忽悠你进去的培训班。<br><a id="more"></a><br>3月8号那天我投了两家公司，其中一家公司的HR很快就联系我让我去面试了，我在网上各种搜索，再三确认这家公司不是培训机构后就欣然接受了面试邀请。</p><p>这家公司在雨花台区的南京软件谷创业城，而我在玄武区，距离比较远。3月9日我早早地起床，先是骑了15分钟摩拜单车，然后站了12站地铁，接着又是坐了9站公交。终于，我比面试时间提前了两个小时来到了那里。四周高楼林立，在电话询问了HR公司在几栋几层后，我就不慌不忙地上了楼。</p><p>这家公司是个才经历A轮融资的创业企业，办公室一百平方左右，员工也就十个吧。由于我只是个前端新手，还是转行的，所以我也不在乎这些。毕竟要先找份工作入行嘛！</p><p>HR小姐姐看见我站在门口便招呼我进来，先是让我打开电脑连上无线网，接着便拿出笔试题然我开始做，规定时间是两个小时。然后她就忙自己的事儿去了。</p><p>第一次笔试啊，也怨我实际项目经验比较少，而且过个年啥玩意儿都没看，实际写起来还是比较生疏的。管他呢，就当是在家练习了，于是我就硬着头皮上了！</p><p>第一题是个布局题，我还能应付应付，但是代码敲完发现还是和题目要求的布局有点区别，半天也没发现问题出现在哪。所以以后各种布局还是需要多练习一下，有些小细节你不去练一遍永远发现不了。</p><p>第二题我就彻底蒙圈了，主要是里面的一些技术我没去学，不知道从哪里下手。</p><p>时间到了，他们公司前端过来看我的情况，我就直接跟他说不会做，然后他问我为什么转行，为什么选择前端，总之是一些和技术无关的问题，我便一五一十地跟他说清楚。最后，他跟我讲了一些他对前端的看法，并委婉地说我技术不到家，我都是点头回应。</p><p>对于这次面试地的失败，不管怎么说，还是我自己技术不到家吧。对于基础的不重视，太着急和刻意地学习框架，结果两个都没学扎实。</p><p>以后地这些日子，我要对布局、CSS、原生JavaScript加大学习力度，多去做一些小的项目，不要总是想着用Vue去撸个APP，对于前端新手或者说初级前端，那些公司在乎的还是你的基础吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来到朋友在南京租的房子里住下后，我就开始着手找工作这一“伟大事业”了。原先是在&lt;em&gt;拉钩网&lt;/em&gt;上投的简历，可是基本上是石沉大海。然后我就尝试着在&lt;em&gt;Boss直聘&lt;/em&gt;上投，一开始因为李文星事件就对这个招聘网站没什么好感，但是为了能找到工作我就奋不顾身了。哈哈，其实没我说的这么夸张，李文星事件之后&lt;em&gt;Boss直聘&lt;/em&gt;就开始重视对招聘公司信息的审核，所以现在比以前好多了，唯一要注意提防的就是那种通过0基础、高薪、各种补贴忽悠你进去的培训班。&lt;br&gt;
    
    </summary>
    
      <category term="Interview" scheme="http://huguokang.com/categories/Interview/"/>
    
    
      <category term="面试" scheme="http://huguokang.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="随笔" scheme="http://huguokang.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>重温Git</title>
    <link href="http://huguokang.com/2017/12/26/%E9%87%8D%E6%B8%A9Git/"/>
    <id>http://huguokang.com/2017/12/26/重温Git/</id>
    <published>2017-12-26T07:22:09.000Z</published>
    <updated>2018-01-25T05:44:33.982Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="http://oy7msxtdy.bkt.clouddn.com/git.jpg" alt="git-logo"><br>之前只在廖雪峰的 Git 教程中简单地学习了一下，并没有在实际的项目中使用过，现阶段正在模仿 Vue 项目，就想着使用一下 Git，更加地模拟以后的工作环境。我是属于边学习<a href="https://git.oschina.net/progit" target="_blank" rel="external">Git中文官方教程</a>边动手使用它，这样更容易掌握这个工具。<br><a id="more"></a></p><h1 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h1><h2 id="初次运行-Git-前的配置"><a href="#初次运行-Git-前的配置" class="headerlink" title="初次运行 Git 前的配置"></a>初次运行 Git 前的配置</h2><h3 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h3><p>第一个要配置的就是个人用户名称和电子邮件地址。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> git config --global user.name "Jony J"</div><div class="line"><span class="meta">$</span> git config --global user.email jonyj@gmail.com</div></pre></td></tr></table></figure><p><code>--global</code> 选项表示以后你所有的项目都会默认使用这里配置的用户信息。如果要在某个特定的项目中使用其它名字或者电邮，只要去掉 <code>--global</code> 选项重新配置，新的设定保存在当前项目的 <code>.git/config</code> 文件里。</p><p>要检查已有的配置信息，可以使用 <code>git config --list</code> 命令。</p><h2 id="获取帮助"><a href="#获取帮助" class="headerlink" title="获取帮助"></a>获取帮助</h2><p>有三种方法向 Git 寻求帮助：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> git help &lt;verb&gt;</div><div class="line"><span class="meta">$</span> git &lt;verb&gt; --help</div><div class="line"><span class="meta">$</span> man git-&lt;verb&gt;</div></pre></td></tr></table></figure><h1 id="Git-基础"><a href="#Git-基础" class="headerlink" title="Git 基础"></a>Git 基础</h1><h2 id="取得项目的-Git-仓库"><a href="#取得项目的-Git-仓库" class="headerlink" title="取得项目的 Git 仓库"></a>取得项目的 Git 仓库</h2><p>有两种取得 Git 项目仓库的方法。</p><ol><li><p>第一种是在现存的目录下，通过导入所有文件来创建新的 Git 仓库，使用 <code>git init</code> 命令初始化，但是目前还没有跟踪管理项目中的任何一个文件。如果当前目录下有几个文件想要纳入版本控制，需要先用 <code>git add</code> 命令告诉 Git 开始对这些文件进行跟踪，然后提交：<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> git add *.c</div><div class="line"><span class="meta">$</span> git add README</div><div class="line"><span class="meta">$</span> git commit -m 'initial project version'</div></pre></td></tr></table></figure></li><li><p>第二种是从已有的 Git 仓库克隆出一个新的镜像仓库来，使用 <code>git clone [url]</code> 命令。</p></li></ol><h2 id="记录每次更新到仓库"><a href="#记录每次更新到仓库" class="headerlink" title="记录每次更新到仓库"></a>记录每次更新到仓库</h2><p>Git 管理项目时，文件流转的三个工作区域：Git 的工作目录，暂存区域，以及本地仓库。<br><br><img src="http://oy7msxtdy.bkt.clouddn.com/local-operation.png" alt="local-operations"></p><p>请记住，工作目录下面的所有文件都不外乎这两种状态：已跟踪或未跟踪。已跟踪的文件是指本来就被纳入版本控制管理的文件，在上次快照中有它们的记录，工作一段时间后，它们的状态可能是未更新，已修改或者已放入暂存区。而所有其他文件都属于未跟踪文件。它们既没有上次更新时的快照，也不在当前的暂存区域。初次克隆某个仓库时，工作目录中的所有文件都属于已跟踪文件，且状态为未修改。</p><p>在编辑过某些文件之后，Git 将这些文件标为已修改。我们逐步把这些修改过的文件放到暂存区域，直到最后一次性提交所有这些暂存起来的文件，如此重复。<br><img src="http://oy7msxtdy.bkt.clouddn.com/18333fig0201-tn.png" alt="file-status-lifecycle"></p><p>使用 <code>git status</code> 命令确定哪些文件当前处于什么状态。只要在“Untracked files”这行下面，就说明是未跟踪状态。使用 <code>git add</code> 命令跟踪新文件，在 <code>git add</code> 后面可以指明要跟踪的文件或目录路径。只要在 “Changes to be committed” 这行下面的，就说明是已暂存状态。在 “Changes not staged for commit” 这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。要暂存这次更新，需要运行 <code>git add</code> 命令（这是个多功能命令，根据目标文件的状态不同，此命令的效果也不同：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等）。</p><p>每次修改文件都需要使用 <code>git add</code> 命令将最新版本重新暂存起来。</p><p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。我们可以创建一个名为 <code>.gitignore</code> 的文件，列出要忽略的文件模式。如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> cat .gitignore</div><div class="line">     *.[oa]</div><div class="line">     *~</div></pre></td></tr></table></figure><p>第一行告诉 Git 忽略所有以 .o 或 .a 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的，我们用不着跟踪它们的版本。第二行告诉 Git 忽略所有以波浪符（~）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。</p><p>文件 <code>.gitignore</code> 有自己的格式规范，要养成好一开始就设置好该文件的习惯。</p><ol><li>所有空行或者以注释符号 ＃ 开头的行都会被 Git 忽略。<br></li><li>可以使用标准的 glob 模式（ shell 所使用的简化了的正则表达式）匹配。<br></li><li>匹配模式最后跟反斜杠（/）说明要忽略的是目录。<br></li><li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。<br></li></ol><p>实际上 <code>git status</code> 的显示比较简单，仅仅是列出了修改过的文件，如果要查看具体修改了什么地方，可以用 <code>git diff</code> 命令。此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容。</p><p>若要看已经暂存起来的文件和上次提交时的快照之间的差异，可以用 <code>git diff --cached</code> 或者 <code>git diff --staged</code> 命令（后者要在 v1.6.1 及更高版本才能使用）。</p><h3 id="提交文件"><a href="#提交文件" class="headerlink" title="提交文件"></a>提交文件</h3><p>使用 <code>git commit -m &quot;本次提交的说明&quot;</code> 命令提交。</p><p>尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。Git 提供了一个跳过使用暂存区域的方式，只要在提交的时候，给 <code>git commit</code> 加上 <code>-a</code> 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 <code>git add</code> 步骤。</p><h3 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h3><p>如果只是简单地从工作目录中<strong>手动</strong>删除，运行 <code>git status</code> 时就会在 “Changes not staged for commit” 部分看到，staged 无变化。</p><p>先手动删除 <code>rm something</code> ，然后运行 <code>git rm something</code> 记录此次移除文件的操作，最后提交的时候，该 “something” 文件就不再纳入版本管理了。</p><p>如果删除之前修改过但没有被 staged 的文件，则必须要用强制删除选项 <code>-f</code>（即 force 的首字母）。</p><p>如果仅从 staged 中删除，但仍然保留在工作区域，使用 <code>git rm --cached something</code> 命令。</p><p>使用 <code>git mv file_from file_to</code> 对文件进行改名。</p><h2 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h2><p><code>git log</code> 命令查看提交历史。可以看到每次更新都有一个 SHA-1 校验和、作者的名字和电子邮件地址、提交时间，最后缩进一个段落显示提交说明。</p><p><code>git log -p -2</code> 命令中 <code>-p</code> 选项表示展开每次提交的内容差异，<code>-2</code> 选项显示最近的两次提交。</p><p><code>--stat</code> 选项仅显示简要的增减行数统计。</p><p><code>--pretty</code> 选项可以指定完全不同于默认格式的方式展示提交历史，如：<code>git log --pretty=online</code> 将每个提交放在一行显示。这个选项还有其它值，如：<code>short</code> ，<code>full</code> 和 <code>fuller</code> 等。最牛逼的是 <code>format</code> ，甚至可以定制想要显示的记录格式，如：<code>git log --pretty=format:&quot;%h - %an, %ar : %s&quot;</code> 。</p><p>format的选项说明：<br><code>%H</code> 提交对象（commit）的完整哈希字串<br><code>%h</code> 提交对象的简短哈希字串<br><code>%T</code> 树对象（tree）的完整哈希字串<br><code>%t</code> 树对象的简短哈希字串<br><code>%P</code> 父对象（parent）的完整哈希字串<br><code>%p</code> 父对象的简短哈希字串<br><code>%an</code> 作者（author）的名字<br><code>%ae</code> 作者的电子邮件地址<br><code>%ad</code> 作者修订日期（可以用 -date= 选项定制格式）<br><code>%ar</code> 作者修订日期，按多久以前的方式显示<br><code>%cn</code> 提交者(committer)的名字<br><code>%ce</code> 提交者的电子邮件地址<br><code>%cd</code> 提交日期<br><code>%cr</code> 提交日期，按多久以前的方式显示<br><code>%s</code> 提交说明</p><p>选项说明：<br><code>-p</code> 按补丁格式显示每个更新之间的差异<br><code>--stat</code> 显示每次更新的文件修改统计信息<br><code>--shortstat</code> 只显示 –stat 中最后的行数修改添加移除统计<br><code>--name-only</code> 仅在提交信息后显示已修改的文件清单<br><code>--name-status</code> 显示新增、修改、删除的文件清单<br><code>--abbrev-commit</code> 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符<br><code>--relative-date</code> 使用较短的相对时间显示（比如，“2 weeks ago”）<br><code>--graph</code> 显示 ASCII 图形表示的分支合并历史。<br><code>--pretty</code> 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。</p><h3 id="限制输出长度"><a href="#限制输出长度" class="headerlink" title="限制输出长度"></a>限制输出长度</h3><p>选项说明：<br><code>-(n)</code> 仅显示最近的 n 条提交<br><code>--since</code>， <code>--after</code> 仅显示指定时间之后的提交<br><code>--until</code>， <code>--before</code> 仅显示指定时间之前的提交<br><code>--author</code> 仅显示指定作者相关的提交<br><code>--committer</code> 仅显示指定提交者相关的提交</p><p>举例，如果要查看 Git 仓库中，2008 年 10 月期间，gitster 提交的但未合并的测试脚本（位于项目的 t/ 目录下的文件），可以用下面的查询命令：</p><p><code>$ git log --pretty=&quot;%h - %s&quot; --author=gitster --since=&quot;2008-10-01&quot; --before=&quot;2008-11-01&quot; --no-merges -- t/</code></p><p>可以使用 gitk 这类图形化工具查阅提交历史。</p><p>想要退出 <code>git log</code> 命令只需要按 <code>q</code> 键 </p><h2 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h2><h3 id="修改最后一次操作"><a href="#修改最后一次操作" class="headerlink" title="修改最后一次操作"></a>修改最后一次操作</h3><p>有时候我们提交完了才发现漏掉了几个文件没有加，或者提交信息写错了。可以使用 <code>git commit --amend</code> 命令，此命令将使用当前的暂存区域快照提交。如果刚才提交完没有作任何改动，直接运行此命令的话，相当于有机会重新编辑提交说明。新的提交说明会覆盖刚才失误的提交。如果是忘记了暂存某些修改，可以在先补上暂存操作，再运行 <code>git commit --amend</code> 命令。</p><h3 id="取消已经暂存的文件"><a href="#取消已经暂存的文件" class="headerlink" title="取消已经暂存的文件"></a>取消已经暂存的文件</h3><p>假如失误用 <code>git add .</code> 命令将修改全加到暂存区域，可以通过 <code>git reset HEAD &lt;file&gt;...</code> 的方式取消暂存。</p><h3 id="取消对文件的修改"><a href="#取消对文件的修改" class="headerlink" title="取消对文件的修改"></a>取消对文件的修改</h3><p>使用 <code>git checkout --&lt;file&gt;...</code> 命令抛弃文件修改。这些命令 Git 会提示你。要慎重使用这条命令，它会取消所有对文件的修改，所以在用这条命令前，请务必确定真的不再需要保留刚才的修改。如果只是想回退版本，同时保留刚才的修改以便将来继续工作，可以用 stashing 和分支来处理，应该会更好些。</p><p>任何已经提交到 Git 的都可以被恢复。所以，你可能失去的数据，仅限于没有提交过的，对 Git 来说它们就像从未存在过一样。</p><h2 id="远程仓库的使用"><a href="#远程仓库的使用" class="headerlink" title="远程仓库的使用"></a>远程仓库的使用</h2><h3 id="查看当前的远程仓库"><a href="#查看当前的远程仓库" class="headerlink" title="查看当前的远程仓库"></a>查看当前的远程仓库</h3><p>可以使用 <code>git remove</code> 命令来查看当前配置有哪些远程仓库。它会列出每个远程库的简短名字，在克隆完某个项目后，至少可以看到一个名为 origin 的远程库，Git 默认使用这个名字来标识你所克隆的原始仓库。加个 <code>-v</code> 选项可以显示对应的克隆地址。</p><h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><p>要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用，运行 <code>git remote add [shortname] [url]</code>。</p><h3 id="修改远程仓库"><a href="#修改远程仓库" class="headerlink" title="修改远程仓库"></a>修改远程仓库</h3><p>有三种方式：</p><ol><li>修改命令： <code>git remote origin set-url &lt;URL&gt;</code></li><li>先删后加： 先<code>git remote rm origin</code>，再<code>git remote add origin git@github.com:&lt;Username&gt;/&lt;Repository&gt;.git</code></li><li>直接修改 config 文件</li></ol><h3 id="从远程仓库抓取数据"><a href="#从远程仓库抓取数据" class="headerlink" title="从远程仓库抓取数据"></a>从远程仓库抓取数据</h3><p>使用 <code>git fetch [remote-name]</code> ，这条命令只会抓取所有你本地仓库中还没有的数据。如果是克隆的一个仓库，使用 <code>git fetch origin</code> 来获取更新。</p><p>如果设置了某个分支用于跟踪某个远端仓库的分支，可以使用 <code>git pull</code> 命令自动抓取数据下来，然后将远端分支自动合并到本地仓库中当前分支。实际上，默认情况下 <code>git clone</code> 命令本质上就是自动创建了本地的 master 分支用于跟踪远程仓库中的 master 分支（假设远程仓库确实有 master 分支）。所以一般我们运行 <code>git pull</code>，目的都是要从原始克隆的远端仓库中抓取数据后，合并到工作目录中的当前分支。</p><h3 id="推送数据到远程仓库"><a href="#推送数据到远程仓库" class="headerlink" title="推送数据到远程仓库"></a>推送数据到远程仓库</h3><p>项目进行到一个阶段，要同别人分享目前的成果，可以将本地仓库中的数据推送到远程仓库。实现这个任务的命令很简单： <code>git push [remote-name] [branch-name]</code>。</p><p>如果你 github 仓库是新建的空的仓库，第一次 push 需要加上 <code>-u</code> 选项.</p><p>只有在所克隆的服务器上有写权限，或者同一时刻没有其他人在推数据，这条命令才会如期完成任务。如果在你推数据前，已经有其他人推送了若干更新，那你的推送操作就会被驳回。你必须先把他们的更新抓取到本地，合并到自己的项目中，然后才可以再次推送。</p><h3 id="查看远程仓库信息"><a href="#查看远程仓库信息" class="headerlink" title="查看远程仓库信息"></a>查看远程仓库信息</h3><p>我们可以通过命令 <code>git remote show [remote-name]</code> 查看某个远程仓库的详细信息。</p><h3 id="远程仓库的删除和重命名"><a href="#远程仓库的删除和重命名" class="headerlink" title="远程仓库的删除和重命名"></a>远程仓库的删除和重命名</h3><p>使用 <code>git remote rename pb paul</code> 命令可以将 pb 重命名为 paul。</p><p>使用 <code>git remote rm paul</code> 命令可以删除 paul。</p><h2 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h2><p><code>git tag</code> 命令显示所有标签，<code>git tag -l &#39;v1.4.2.*&#39;</code>命令显示1.4.2系列的版本标签。</p><p><code>git tag -a v1.4 -m &#39;my version 1.4&#39;</code> 命名创建一个含附注类型的标签。<code>-a</code> 选项是 annotated（带注释的） 的首字母。</p><p><code>git tag -a v1.2 校验和或它的前几位字符</code> 命令可用于后期补加标签。</p><p><code>git push origin [tagname]</code> 命令用来将标签传送到远端服务器。可使用 <code>git push origin --tags</code> 一次性推送所有标签。</p><h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><p><img src="http://oy7msxtdy.bkt.clouddn.com/18333fig0313-tn.png" alt="fast-forward"><br>由于当前 master 分支所在的提交对象是要并入的 hotfix 分支的直接上游，Git 只需把 master 分支指针直接右移。换句话说，如果顺着一个分支走下去可以到达另一个分支的话，那么 Git 在合并两者时，只会简单地把指针右移，因为这种单线的历史分支不存在任何需要解决的分歧，所以这种合并过程可以称为快进（Fast forward）。<br><img src="http://oy7msxtdy.bkt.clouddn.com/18333fig0314-tn.png" alt="fast-forward"></p><p><img src="http://oy7msxtdy.bkt.clouddn.com/18333fig0315-tn.png" alt="issue53-1"><br>iss53分支不受影响继续推进<br><br><img src="http://oy7msxtdy.bkt.clouddn.com/18333fig0316-tn.png" alt="issue53-2"><br><br>Git 会用两个分支的末端（C4 和 C5）以及它们的共同祖先（C2）进行一次简单的三方合并计算。<br><img src="http://oy7msxtdy.bkt.clouddn.com/18333fig0317-tn.png" alt="issue53-3"><br><br>并对三方合并后的结果重新做一个新的快照，并自动创建一个指向它的提交对象（C6）。</p><h2 id="关于分支的命令"><a href="#关于分支的命令" class="headerlink" title="关于分支的命令"></a>关于分支的命令</h2><p><code>git branch 分支名</code> ：创建一个新分支。</p><p><code>git checkout 分支名</code> ：切换到另一个分支。</p><p><code>git checkout -b 分支名</code> ：创建一个新分支并切换过去。</p><p><code>git branch -d 分支名</code> ：删除一个分支。由于 Git 中的分支实际上仅是一个包含所指对象校验和（40 个字符长度 SHA-1 字串）的文件，所以创建和销毁一个分支就变得非常廉价。</p><p>先 <code>git checkout master</code> 到默认分支，然后再 <code>git merge 分支名</code> 合并分支，最后删除已经用的分支。</p><p>如何在不同分支修改了同一文件的同一处，将导致 <code>unmerged</code> 问题，Git 会定位到出新问题的文件，并要求你手动解决分歧。可以运行 <code>git mergetool</code> 命令来调用可视化合并工具辅助你解决冲突。</p><p><code>git branch</code> 可以列出所有分支的清单，带有 <code>*</code> 号的是当前分支。</p><p><code>git branch -v</code> 可以查看每个分支最后一个提交的信息。</p><p><code>git branch --merged</code> 查看哪些分支已经并入当前分支。<code>git branch --no-merged</code> 反之。</p><p>对于没有合并过来的分支，由于包含着尚未合并的工作成果，简单地使用 <code>git branch -d 文件名</code> 删除是会提示错误，如果确实要删除，可以使用 <code>git branch -D 文件名</code> 强制删除。</p><h2 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h2><p>推送本地分支 <code>serverfix</code>：<code>git push origin serverfix</code> ，它是 <code>git push origin serverfix:serverfix</code> 的简写。若想把远程分支叫为 <code>awesomebranch</code> ，可以用 <code>git push origin serverfix:awesomebranch</code> 。</p><p>把远程分支合并到当前分支：<code>git merge origin/serverfix</code> ，如果想要自己的一份远程分支，可以在远程分支上分化出一个新的分支：<code>git checkout -b serverfix origin/serverfix</code> 。本地的这个分支不一定叫 <code>serverfix</code> ，可以换成别的。</p><p>从远程分支 <code>checkout</code> 出来的本地分支被称为跟踪分支。在跟踪分支里输入 <code>git push</code>，Git 会自行推断应该向哪个服务器的哪个分支推送数据。同样，在这些分支里运行 <code>git pull</code> 会获取所有远程索引，并把它们的数据都合并到本地分支中来。</p><p><code>v1.6.2</code> 以上的可以使用 <code>--track</code> 选项简化，如：<code>git checkout --track origin/serverfix</code></p><p>可以使用 <code>git push [远程名] :[分支名]</code> 来删除你不再需要的远程分支。如：<code>git push origin :serverfix</code> 。联想到本地分支的推送，这等于推送了空白分支。</p><h2 id="rebase-衍合"><a href="#rebase-衍合" class="headerlink" title="rebase(衍合)"></a>rebase(衍合)</h2><p>先 <code>git checkout 特性分支名</code> ，再 <code>git rebase master</code> 衍合，相当于给 master 分支打一个补丁，然后切换回去合并，即 master 快进。</p><p>也可以直接 <code>git rebase master 特性分支名</code> ，省去切换到分支再衍合的麻烦。然后 <code>git checkout master</code> <code>git merge 特性分支名</code> 。</p><p><img src="http://oy7msxtdy.bkt.clouddn.com/18333fig0331-tn.png" alt="rebase-1"><br><img src="http://oy7msxtdy.bkt.clouddn.com/18333fig0332-tn.png" alt="rebase-2"></p><p>对于这个例子，我们决定先把客户端的修改并到主线，而暂缓并入服务器的修改。使用 <code>git rebase --onto master server client</code> 命令。</p><p>这就是取出 <code>client</code> 分支，找出 <code>client</code> 分支和 <code>server</code> 分支的共同祖先之后的变化，然后把它们在 <code>master</code> 上重演一遍。</p><p><strong>一旦分支中的提交对象发布到公共仓库，就千万不要对该分支进行衍合操作。</strong></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>看了官方文档前三章之后，再次熟悉了一遍基本的 Git 命令，本来似懂非懂的原理也有了更清楚的认识。然而Git 远远不止这些知识，更多细节还是要去文档的后几章上发掘。我这里先告一段落了，因为这不是首要任务，什么 sass 我还没看呢！Vue 的全家桶也是一知半解，罪过，罪过。。。<br><img src="http://oy7msxtdy.bkt.clouddn.com/102-161101164039.jpg" alt="tuifei"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://oy7msxtdy.bkt.clouddn.com/git.jpg&quot; alt=&quot;git-logo&quot;&gt;&lt;br&gt;之前只在廖雪峰的 Git 教程中简单地学习了一下，并没有在实际的项目中使用过，现阶段正在模仿 Vue 项目，就想着使用一下 Git，更加地模拟以后的工作环境。我是属于边学习&lt;a href=&quot;https://git.oschina.net/progit&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Git中文官方教程&lt;/a&gt;边动手使用它，这样更容易掌握这个工具。&lt;br&gt;
    
    </summary>
    
      <category term="Learning" scheme="http://huguokang.com/categories/Learning/"/>
    
    
      <category term="Git" scheme="http://huguokang.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Webpack学习笔记</title>
    <link href="http://huguokang.com/2017/12/09/Webpack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://huguokang.com/2017/12/09/Webpack学习笔记/</id>
    <published>2017-12-09T00:57:58.000Z</published>
    <updated>2017-12-13T08:04:56.421Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>随着 Vue.js 的学习，webpack 已然是必须要掌握的工具。目前，webpack 版本更新到 <code>v3.10.0</code> 了，相比以前应该是优化并成熟了很多。<a href="https://doc.webpack-china.org" target="_blank" rel="external">webpack中文官网</a>上有详细的文档，这篇文章作为我的学习笔记，就大概地记录下重要的知识点。<br><a href="https://doc.webpack-china.org/configuration" target="_blank" rel="external">详细配置</a></p><a id="more"></a><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p><strong>官方文档的描述：</strong>本质上，webpack 是一个现代 JavaScript 应用程序的模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。</p><p>webpack 有四个核心概念：<br></p><ul><li>入口(entry)<br></li><li>输出(output)<br></li><li>loader<br></li><li>插件(plugins)</li></ul><p>看上去还是比较简单的，下面一一描述。</p><h2 id="入口起点-Entry-Point"><a href="#入口起点-Entry-Point" class="headerlink" title="入口起点(Entry Point)"></a>入口起点(Entry Point)</h2><p>首先 webpack 会从 webpack.config.js 这个文件中读取相关的配置信息，这也是我们配置各个属性的地方。</p><p>配置 <code>entry</code> 属性有两种语法，单个入口（简写）语法和对象语法。</p><p>单个入口（简写）语法：<code>entry: string|Array&lt;string&gt;</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// entry 属性的单个入口语法</span></div><div class="line"><span class="keyword">const</span> config = &#123;</div><div class="line">  entry: <span class="string">'./path/to/my/entry/file.js'</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">// 上面是下面的简写</span></div><div class="line"><span class="keyword">const</span> config = &#123;</div><div class="line">  entry: &#123;</div><div class="line">    main: <span class="string">'./path/to/my/entry/file.js'</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看到这种语法还可以传入数组，传入文件路径数组将创建“多个主入口”。文档说：在你想要多个依赖文件一起注入，并将它们的依赖导向(graph)到一个”chunk”时很有用。</p><p>对象语法：<code>entry: {[entryChunkName: string]: string|Array&lt;string&gt;}</code></p><p>这种语法比较繁琐但是最可扩展。<br><br>“可扩展的 webpack 配置”是指，可重用并且可以和其它配置组合使用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 分离 应用程序 和 第三方库 入口</span></div><div class="line"><span class="comment">// 这种方式常见于，只有一个入口起点（不包括 vendor）的单页应用程序中</span></div><div class="line"><span class="comment">// 此设置允许你使用 CommonsChunkPlugin 从「应用程序 bundle」中提取 vendor 引用(vendor reference) 到 vendor bundle，并把引用 vendor 的部分替换为 __webpack_require__() 调用。如果应用程序 bundle 中没有 vendor 代码，那么你可以在 webpack 中实现被称为长效缓存的通用模式。</span></div><div class="line"><span class="keyword">const</span> config = &#123;</div><div class="line">  entry: &#123;</div><div class="line">    app: <span class="string">'./src/app.js'</span>,</div><div class="line">    vendors: <span class="string">'./src/vendors.js'</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 多页面应用程序，页面跳转便获取新的 HTML 文档</span></div><div class="line"><span class="comment">// 每个 HTML 文档只使用一个入口起点。</span></div><div class="line"><span class="comment">// 使用 CommonsChunkPlugin 为每个页面间的应用程序共享代码创建 bundle</span></div><div class="line"><span class="keyword">const</span> config = &#123;</div><div class="line">  entry: &#123;</div><div class="line">    pageOne: <span class="string">'./src/pageOne/index.js'</span>,</div><div class="line">    pageTwo: <span class="string">'./src/pageTwo/index.js'</span>,</div><div class="line">    pageThree: <span class="string">'./src/pageThree/index.js'</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="输出-output"><a href="#输出-output" class="headerlink" title="输出(output)"></a>输出(output)</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// filename 用于输出文件的文件名</span></div><div class="line"><span class="comment">// path 目标输出目录的绝对路径</span></div><div class="line"><span class="keyword">const</span> config = &#123;</div><div class="line">  output: &#123;</div><div class="line">    filename: <span class="string">'bundle.js'</span>,</div><div class="line">    path: <span class="string">'/home/proj/public/assets'</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 多个入口起点或者使用了像 CommonsChunkPlugin 这样的插件</span></div><div class="line">&#123;</div><div class="line">  entry: &#123;</div><div class="line">    app: <span class="string">'./src/app.js'</span>,</div><div class="line">    search: <span class="string">'./src/search.js'</span></div><div class="line">  &#125;,</div><div class="line">  output: &#123;</div><div class="line">    filename: <span class="string">'[name].js'</span>,</div><div class="line">    path: __dirname + <span class="string">'/dist'</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 写入到硬盘： ./dist/app.js, ./dist/search.js</span></div></pre></td></tr></table></figure><h2 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h2><p>loader 用于对模块的源代码进行转换。</p><p>首先要先安装对应的 loader ，比如安装 css-loader ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev css-loader</div></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 提示 webpack 对每个 .css 使用 css-loader</span></div><div class="line"><span class="keyword">const</span> config = &#123;</div><div class="line">  <span class="built_in">module</span>: &#123;</div><div class="line">    rules: [</div><div class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">use</span>: <span class="string">'css-loader'</span> &#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// module.rules 允许在 webpack 配置中指定多个 loader</span></div><div class="line"><span class="built_in">module</span>: &#123;</div><div class="line">  rlues: [</div><div class="line">    &#123;</div><div class="line">      test: <span class="regexp">/\.css$/</span>,</div><div class="line">      use: [</div><div class="line">        &#123; <span class="attr">loader</span>: <span class="string">'style-loader'</span>&#125;,</div><div class="line">        &#123; </div><div class="line">          loader: <span class="string">'css-loader'</span>,</div><div class="line">          options: &#123;</div><div class="line">            modules: <span class="literal">true</span></div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      ]</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="插件-Plugins"><a href="#插件-Plugins" class="headerlink" title="插件(Plugins)"></a>插件(Plugins)</h2><p>插件用于解决 loader 无法实现的事。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 由于插件可以携带参数/选项，你必须在 webpack 配置中，向 plugins 属性传入 new 实例。</span></div><div class="line"><span class="comment">// webpack 配置是标准的 Node.js CommonJS 模块，通过 require(...)导入其它文件或使用 npm 的工具函数</span></div><div class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>); <span class="comment">// 通过 npm 安装</span></div><div class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>); <span class="comment">// 访问内置插件</span></div><div class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> config = &#123;</div><div class="line">  entry: <span class="string">'./path/to/my/entry/file.js'</span>,</div><div class="line">  output: &#123;</div><div class="line">    filename: <span class="string">'my-first-webpack.bundle.js'</span>,</div><div class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>)</div><div class="line">  &#125;,</div><div class="line">  <span class="built_in">module</span>: &#123;</div><div class="line">    loaders: [               <span class="comment">// 为什么不是 rules ?</span></div><div class="line">      &#123;</div><div class="line">        test: <span class="regexp">/\.(js|jsx)$/</span>,</div><div class="line">        use: <span class="string">'babel-loader'</span></div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  plugins: [</div><div class="line">    <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(),</div><div class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;<span class="attr">template</span>: <span class="string">'./src/index.html'</span>&#125;)</div><div class="line">  ]</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = config;</div></pre></td></tr></table></figure><p>到这里，四个核心概念都大概了解了，下面再学习其它方面。</p><h2 id="模块-Modules"><a href="#模块-Modules" class="headerlink" title="模块(Modules)"></a>模块(Modules)</h2><p>在模块化编程中，开发者将程序分解成离散功能块(discrete chunks of functionality)，并称之为模块。</p><p>webpack 模块的几个例子：<br></p><ul><li>ES2015 <code>import</code> 语句<br></li><li>CommonJS <code>require()</code> 语句<br></li><li>css/sass/less 文件中的 <code>@import</code> 语句<br></li><li>样式(url(…))或 HTML 文件(<code>&lt;img src=...&gt;</code>)中的图片链接(image url)</li></ul><p>webpack 通过 loader 可以支持各种语言和预处理器编写模块。loader 描述了 webpack 如何处理 非 JavaScript(non-JavaScript) 模块，并且在bundle中引入这些依赖。</p><h2 id="模块解析-Module-Resolution"><a href="#模块解析-Module-Resolution" class="headerlink" title="模块解析(Module Resolution)"></a>模块解析(Module Resolution)</h2><p>resolver 是一个用于帮助找到模块的绝对路径的第三方库(library)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 一个模块可以作为另一个模块的依赖模块被引用</span></div><div class="line"><span class="comment">// 所依赖的模块可以是来自应用程序代码或第三方的库</span></div><div class="line"><span class="keyword">import</span> foo <span class="keyword">from</span> <span class="string">'path/to/module'</span></div><div class="line"><span class="comment">// 或者</span></div><div class="line"><span class="built_in">require</span>(<span class="string">'path/to/module'</span>)</div></pre></td></tr></table></figure><p>resolver 帮助 webpack 找到 bundle 中需要引入的模块代码。当打包模块时，webpack 使用 enhanced-resolve 来解析文件路径。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 绝对路径</span></div><div class="line"><span class="keyword">import</span> <span class="string">"/home/me/file"</span>;</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"C:\\Users\\me\\file"</span>;</div><div class="line"></div><div class="line"><span class="comment">// 相对路径</span></div><div class="line"><span class="comment">// 这种情况下，使用 import 或 require 的资源文件(resource file)所在的目录被认为是上下文目录。</span></div><div class="line"><span class="keyword">import</span> <span class="string">"../src/file1"</span>;</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"./file2"</span>;</div><div class="line"></div><div class="line"><span class="comment">// 模块路径</span></div><div class="line"><span class="keyword">import</span> <span class="string">"module"</span>;</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"module/lib/file"</span>;</div></pre></td></tr></table></figure><h2 id="依赖图-Dependency-Graph"><a href="#依赖图-Dependency-Graph" class="headerlink" title="依赖图(Dependency Graph)"></a>依赖图(Dependency Graph)</h2><p>任何时候，一个文件依赖于另一个文件，webpack 就把此视为文件之间有依赖关系。webpack 从命令行或配置文件中定义的一个模块列表开始，处理你的应用程序。 从这些入口起点开始，webpack 递归地构建一个依赖图，这个依赖图包含着应用程序所需的每个模块.</p><h2 id="构建目标-Targets"><a href="#构建目标-Targets" class="headerlink" title="构建目标(Targets)"></a>构建目标(Targets)</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在 webpack 配置中设置 target 的值</span></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  target: <span class="string">'node'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 多个 Target</span></div><div class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"><span class="keyword">var</span> serverConfig = &#123;</div><div class="line">  target: <span class="string">'node'</span>,</div><div class="line">  output: &#123;</div><div class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</div><div class="line">    filename: <span class="string">'lib.node.js'</span></div><div class="line">  &#125;</div><div class="line">  <span class="comment">//…</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> clientConfig = &#123;</div><div class="line">  target: <span class="string">'web'</span>, <span class="comment">// &lt;=== 默认是 'web'，可省略</span></div><div class="line">  output: &#123;</div><div class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</div><div class="line">    filename: <span class="string">'lib.js'</span></div><div class="line">  &#125;</div><div class="line">  <span class="comment">//…</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = [ serverConfig, clientConfig ];</div></pre></td></tr></table></figure><h2 id="Manifest"><a href="#Manifest" class="headerlink" title="Manifest"></a>Manifest</h2><h2 id="模块热替换-Hot-Module-Replacement"><a href="#模块热替换-Hot-Module-Replacement" class="headerlink" title="模块热替换(Hot Module Replacement)"></a>模块热替换(Hot Module Replacement)</h2><p>上面介绍了很多概念，下面的指南介绍项目中如何使用 webpack</p><h1 id="指南"><a href="#指南" class="headerlink" title="指南"></a>指南</h1><h2 id="本地安装"><a href="#本地安装" class="headerlink" title="本地安装"></a>本地安装</h2><p>对于大多数项目，建议本地安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev webpack</div><div class="line">npm install --save-dev webpack@&lt;version&gt;</div></pre></td></tr></table></figure><p>通常，webpack 通过运行一个或多个 npm scripts，会在本地 <code>node_modules</code> 目录中查找安装的 webpack：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">"scripts": &#123;</div><div class="line">  "start": "webpack --config webpack.config.js"</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在 package.json 添加一个 npm script 来代替 CLI 这种方式来运行本地的 webpack。</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  ...</div><div class="line">  "scripts": &#123;</div><div class="line">    "bulid": "webpack"</div><div class="line">  &#125;,</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>现在可以使用 <code>npm run build</code> 命令代替 较长的 CLI 命令(<code>./node_modules/.bin/webpack</code>) </p><p>使用 npm 的 scripts，我们可以通过模块名来引用本地安装的 npm 包，而不是写出完整路径。</p><h2 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h2><p>没什么东西，跟着创建了一个小项目，结构如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">webpack-demo</div><div class="line">|- package.json</div><div class="line">|- webpack.config.js</div><div class="line">|- /dist</div><div class="line">  |- bundle.js</div><div class="line">  |- index.html</div><div class="line">|- /src</div><div class="line">  |- index.js</div><div class="line">|- /node_modules</div></pre></td></tr></table></figure><h2 id="管理资源"><a href="#管理资源" class="headerlink" title="管理资源"></a>管理资源</h2><p>在 src 目录下加入资源，webpack.config.js 中配置相应的 loader，在 index.js 中 先 import 再将资源引入到 index.html 中。</p><h2 id="管理输出"><a href="#管理输出" class="headerlink" title="管理输出"></a>管理输出</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);<span class="comment">// 当修改 entry 时，不需要修改 index.html，这个插件会生成一个新的覆盖它</span></div><div class="line"><span class="keyword">const</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);<span class="comment">// 清理 /dist 文件夹</span></div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  entry: &#123;</div><div class="line">    app: <span class="string">'./src/index.js'</span>,</div><div class="line">    print: <span class="string">'./src/print.js'</span></div><div class="line">  &#125;,</div><div class="line">  plugins: [</div><div class="line">    <span class="keyword">new</span> CleanWebpackPlugin([<span class="string">'dist'</span>]),</div><div class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</div><div class="line">      title: <span class="string">'Output Management'</span></div><div class="line">    &#125;)</div><div class="line">  ],</div><div class="line">  output: &#123;</div><div class="line">    filename: <span class="string">'[name].bundle.js'</span>,</div><div class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>)</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>通过 manifest，webpack 能够对「你的模块映射到输出 bundle 的过程」保持追踪。</p><h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><p>以下工具仅用于开发环境</p><h3 id="使用-source-map"><a href="#使用-source-map" class="headerlink" title="使用 source map"></a>使用 source map</h3><p>该功能将编译后的代码映射回原始源代码，当多个源文件打包到一个 bundle 中，出错时，可以准确知道错误来自哪个源文件。</p><p>source map 有很多<a href="https://doc.webpack-china.org/configuration/devtool" target="_blank" rel="external">不同的选项</a>，可以根据需要进行配置。</p><p>假如我们使用 <code>inline-source-map</code> 选项，那么可以在 webpack.config.js 中配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ...</span></div><div class="line">devtool: <span class="string">'inline-source-map'</span>,</div><div class="line"><span class="comment">// ...</span></div></pre></td></tr></table></figure><p>webpack 中有三个不同的选项，可以帮助我们在代码发生变化后自动编译代码：</p><ol><li><p>webpack’s Watch Mode</p></li><li><p>webpack-dev-server</p></li><li><p>webpack-dev-middleware</p></li></ol><p>多数场景中，我们可以需要使用 <code>webpack-dev-server</code>，所以我只记录下这个选项。</p><p><code>webpack-dev-server</code> 提供了一个简单的 web 服务器，能实时重新加载(live reloading)。</p><p>首先，安装它：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev webpack-dev-server</div></pre></td></tr></table></figure><p>然后还是在之前的配置文件中加入以下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ...</span></div><div class="line">devServer: &#123;</div><div class="line">  contentBase: <span class="string">'./dist'</span></div><div class="line">&#125;,</div><div class="line"><span class="comment">// ...</span></div></pre></td></tr></table></figure><p>这会告知 <code>webpack-dev-server</code>，在 <code>localhost:8080</code> 下建立服务，将 <code>dist</code> 目录下的文件，作为可访问文件。</p><p>然后添加一个 npm script ，通过 npm start 可以直接运行开发服务器(dev server):</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">"scripts": &#123;</div><div class="line">  // ...</div><div class="line">  "start": "webpack-dev-server --open"</div><div class="line">  // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>webpack-dev-server</code> 带有许多可配置的选项。<a href="https://doc.webpack-china.org/configuration/dev-server" target="_blank" rel="external">相关文档</a></p><h2 id="模块热替换"><a href="#模块热替换" class="headerlink" title="模块热替换"></a>模块热替换</h2><h3 id="启用-HMR"><a href="#启用-HMR" class="headerlink" title="启用 HMR"></a>启用 HMR</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 更新 webpack-dev-server 的配置，并使用 webpack 内置的 HMR 插件。我们还要删除掉 print.js 的入口起点，因为它现在正被 index.js 模式使用。</span></div><div class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line">  <span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</div><div class="line">  <span class="keyword">const</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</div><div class="line">+ <span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</div><div class="line"></div><div class="line">  <span class="built_in">module</span>.exports = &#123;</div><div class="line">    entry: &#123;</div><div class="line">-      app: <span class="string">'./src/index.js'</span>,</div><div class="line">-      print: <span class="string">'./src/print.js'</span></div><div class="line">+      app: <span class="string">'./src/index.js'</span></div><div class="line">    &#125;,</div><div class="line">    devtool: <span class="string">'inline-source-map'</span>,</div><div class="line">    devServer: &#123;</div><div class="line">      contentBase: <span class="string">'./dist'</span>,</div><div class="line">+     hot: <span class="literal">true</span></div><div class="line">    &#125;,</div><div class="line">    plugins: [</div><div class="line">      <span class="keyword">new</span> CleanWebpackPlugin([<span class="string">'dist'</span>]),</div><div class="line">      <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</div><div class="line">        title: <span class="string">'Hot Module Replacement'</span></div><div class="line">      &#125;),</div><div class="line">+     <span class="keyword">new</span> webpack.NamedModulesPlugin(), <span class="comment">// 便于查看要修补(patch)的依赖</span></div><div class="line">+     <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</div><div class="line">    ],</div><div class="line">    output: &#123;</div><div class="line">      filename: <span class="string">'[name].bundle.js'</span>,</div><div class="line">      path: path.resolve(__dirname, <span class="string">'dist'</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;;</div></pre></td></tr></table></figure><p>修改 <code>index.js</code> 文件，以便当 <code>print.js</code> 内部发生变更时可以告诉 webpack 接受更新的模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">  <span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">'lodash'</span>;</div><div class="line">  <span class="keyword">import</span> printMe <span class="keyword">from</span> <span class="string">'./print.js'</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">component</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</div><div class="line">    <span class="keyword">var</span> btn = <span class="built_in">document</span>.createElement(<span class="string">'button'</span>);</div><div class="line"></div><div class="line">    element.innerHTML = _.join([<span class="string">'Hello'</span>, <span class="string">'webpack'</span>], <span class="string">' '</span>);</div><div class="line"></div><div class="line">    btn.innerHTML = <span class="string">'Click me and check the console!'</span>;</div><div class="line">    btn.onclick = printMe;</div><div class="line"></div><div class="line">    element.appendChild(btn);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> element;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="built_in">document</span>.body.appendChild(component());</div><div class="line">+</div><div class="line">+ <span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</div><div class="line">+   <span class="built_in">module</span>.hot.accept(<span class="string">'./print.js'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">+     <span class="built_in">console</span>.log(<span class="string">'Accepting the updated printMe module!'</span>);</div><div class="line">+     printMe();</div><div class="line">+   &#125;)</div><div class="line">+ &#125;</div></pre></td></tr></table></figure><p>更改 <code>print.js</code> 中 <code>consloe.log</code> 的输出内容，浏览器中看到相应的输出。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">  <span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">printMe</span>(<span class="params"></span>) </span>&#123;</div><div class="line">-   <span class="built_in">console</span>.log(<span class="string">'I get called from print.js!'</span>);</div><div class="line">+   <span class="built_in">console</span>.log(<span class="string">'Updating print.js...'</span>)</div><div class="line">  &#125;</div></pre></td></tr></table></figure><h3 id="通过-Node-js-API"><a href="#通过-Node-js-API" class="headerlink" title="通过 Node.js API"></a>通过 Node.js API</h3><p><strong>dev-server.js</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> webpackDevServer = <span class="built_in">require</span>(<span class="string">'webpack-dev-server'</span>);</div><div class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'./webpack.config.js'</span>);</div><div class="line"><span class="keyword">const</span> options = &#123;</div><div class="line">  contentBase: <span class="string">'./dist'</span>,</div><div class="line">  hot: <span class="literal">true</span>,</div><div class="line">  host: <span class="string">'localhost'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 想要启用 HMR，还需要修改 webpack 配置对象，使其包含 HMR 入口起点。</span></div><div class="line"><span class="comment">// webpack-dev-server package 中具有一个叫做 addDevServerEntrypoints 的方法实现了这个目标</span></div><div class="line">webpackDevServer.addDevServerEntrypoints(config, options);</div><div class="line"><span class="keyword">const</span> compiler = webpack(config);</div><div class="line"><span class="comment">// 不要将 dev server 选项放在 webpack 配置对象(webpack config object)中。而是，在创建选项时，将其作为第二个参数传递。</span></div><div class="line"><span class="keyword">const</span> server = <span class="keyword">new</span> webpackDevServer(compiler, options);</div><div class="line"></div><div class="line">server.listen(<span class="number">5000</span>, <span class="string">'localhost'</span>, () =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'dev server listening on port 5000'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>可是，控制台仍然打印旧的 <code>printMe</code> 功能，这是因为 <code>onclick</code> 事件仍然绑定旧的 <code>printMe</code> 函数。下面作出修改：</p><p><strong>index.js</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">  <span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">'lodash'</span>;</div><div class="line">  <span class="keyword">import</span> printMe <span class="keyword">from</span> <span class="string">'./print.js'</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">component</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</div><div class="line">    <span class="keyword">var</span> btn = <span class="built_in">document</span>.createElement(<span class="string">'button'</span>);</div><div class="line"></div><div class="line">    element.innerHTML = _.join([<span class="string">'Hello'</span>, <span class="string">'webpack'</span>], <span class="string">' '</span>);</div><div class="line"></div><div class="line">    btn.innerHTML = <span class="string">'Click me and check the console!'</span>;</div><div class="line">    btn.onclick = printMe;  <span class="comment">// onclick 事件绑定原始的 printMe 函数上</span></div><div class="line"></div><div class="line">    element.appendChild(btn);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> element;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">- <span class="built_in">document</span>.body.appendChild(component());</div><div class="line">+ <span class="keyword">let</span> element = component(); <span class="comment">// 当 print.js 改变导致页面重新渲染时，重新获取渲染的元素</span></div><div class="line">+ <span class="built_in">document</span>.body.appendChild(element);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</div><div class="line">    <span class="built_in">module</span>.hot.accept(<span class="string">'./print.js'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'Accepting the updated printMe module!'</span>);</div><div class="line">-     printMe();</div><div class="line">+     <span class="built_in">document</span>.body.removeChild(element); <span class="comment">// 删除原来的</span></div><div class="line">+     element = component(); <span class="comment">// 重新渲染页面后，component 更新 click 事件处理</span></div><div class="line">+     <span class="built_in">document</span>.body.appendChild(element);</div><div class="line">    &#125;)</div><div class="line">  &#125;</div></pre></td></tr></table></figure><h3 id="HMR-修改样式表"><a href="#HMR-修改样式表" class="headerlink" title="HMR 修改样式表"></a>HMR 修改样式表</h3><p>借助于 <code>style-loader</code> 的帮助，CSS 的模块热替换实际上是相当简单的。当更新 CSS 依赖模块时，此 loader 在后台使用 <code>module.hot.accept</code> 来修补(patch) <code>&lt;style&gt;</code> 标签。</p><h3 id="其它代码和框架"><a href="#其它代码和框架" class="headerlink" title="其它代码和框架"></a>其它代码和框架</h3><p>既然我在学习 Vue.js，自然少不了 Vue Loader 的学习。</p><p>Vue Loader：此 loader 支持用于 vue 组件的 HMR，提供开箱即用体验。</p><h2 id="Tree-Shaking"><a href="#Tree-Shaking" class="headerlink" title="Tree Shaking"></a>Tree Shaking</h2><p>tree shaking 是一个术语，通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code)。它依赖于 ES2015 模块系统中的静态结构特性，例如 <code>import</code> 和 <code>export</code>。</p><p>我们通过 <code>import</code> 和 <code>export</code> 语法标识出了未引用代码，为了从 bundle 中删除它们，可以使用压缩工具(minifier) <code>UglifyJSPlugin</code> 。</p><p>先安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i --save-dev uglifyjs-webpack-plugin</div></pre></td></tr></table></figure><p>然后将其添加到我们的配置中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line">+ <span class="keyword">const</span> UglifyJSPlugin = <span class="built_in">require</span>(<span class="string">'uglifyjs-webpack-plugin'</span>);</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  entry: <span class="string">'./src/index.js'</span>,</div><div class="line">  output: &#123;</div><div class="line">    filename: <span class="string">'bundle.js'</span>,</div><div class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>)</div><div class="line">- &#125;</div><div class="line">+ &#125;,</div><div class="line">+ plugins: [</div><div class="line">+   <span class="keyword">new</span> UglifyJSPlugin()</div><div class="line">+ ]</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="生产环境构建"><a href="#生产环境构建" class="headerlink" title="生产环境构建"></a>生产环境构建</h2><p>开发环境(development)和生产环境(production)的构建目标差异很大。在开发环境中，我们需要具有强大的、具有实时重新加载(live reloading)或热模块替换(hot module replacement)能力的 source map 和 localhost server。而在生产环境中，我们的目标则转向于关注更小的 bundle，更轻量的 source map，以及更优化的资源，以改善加载时间。由于要遵循逻辑分离，我们通常建议为每个环境编写彼此独立的 webpack 配置。</p><p>两者做了略微区分，但是我们还保留了一个通用配置。使用 <code>webpack-merge</code> 工具将这些配置合并在一起。通过“通用”配置，我们不必在环境特定(environment-specific)的配置中重复代码。</p><p>先安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev webpack-merge</div></pre></td></tr></table></figure><p>代码分离：</p><p><strong>project</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">  webpack-demo</div><div class="line">  |- package.json</div><div class="line">- |- webpack.config.js</div><div class="line">+ |- webpack.common.js</div><div class="line">+ |- webpack.dev.js</div><div class="line">+ |- webpack.prod.js</div><div class="line">  |- /dist</div><div class="line">  |- /src</div><div class="line">    |- index.js</div><div class="line">    |- math.js</div><div class="line">  |- /node_modules</div></pre></td></tr></table></figure><p><strong>webpack.common.js</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">+ <span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line">+ <span class="keyword">const</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</div><div class="line">+ <span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</div><div class="line">+</div><div class="line">+ <span class="built_in">module</span>.exports = &#123;</div><div class="line">+   entry: &#123;</div><div class="line">+     app: <span class="string">'./src/index.js'</span></div><div class="line">+   &#125;,</div><div class="line">+   plugins: [</div><div class="line">+     <span class="keyword">new</span> CleanWebpackPlugin([<span class="string">'dist'</span>]),</div><div class="line">+     <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</div><div class="line">+       title: <span class="string">'Production'</span></div><div class="line">+     &#125;)</div><div class="line">+   ],</div><div class="line">+   output: &#123;</div><div class="line">+     filename: <span class="string">'[name].bundle.js'</span>,</div><div class="line">+     path: path.resolve(__dirname, <span class="string">'dist'</span>)</div><div class="line">+   &#125;</div><div class="line">+ &#125;;</div></pre></td></tr></table></figure><p><strong>webpack.dev.js</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">+ <span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</div><div class="line">+ <span class="keyword">const</span> common = <span class="built_in">require</span>(<span class="string">'./webpack.common.js'</span>);</div><div class="line">+</div><div class="line">+ <span class="built_in">module</span>.exports = merge(common, &#123;</div><div class="line">+   devtool: <span class="string">'inline-source-map'</span>,</div><div class="line">+   devServer: &#123;</div><div class="line">+     contentBase: <span class="string">'./dist'</span></div><div class="line">+   &#125;</div><div class="line">+ &#125;);</div></pre></td></tr></table></figure><p><strong>webpack.prod.js</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">+ <span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</div><div class="line">+ <span class="keyword">const</span> UglifyJSPlugin = <span class="built_in">require</span>(<span class="string">'uglifyjs-webpack-plugin'</span>);</div><div class="line">+ <span class="keyword">const</span> common = <span class="built_in">require</span>(<span class="string">'./webpack.common.js'</span>);</div><div class="line">+</div><div class="line">+ <span class="built_in">module</span>.exports = merge(common, &#123;</div><div class="line">+   plugins: [</div><div class="line">+     <span class="keyword">new</span> UglifyJSPlugin()</div><div class="line">+   ]</div><div class="line">+ &#125;);</div></pre></td></tr></table></figure><p>修改 npm scripts：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">    "scripts": &#123;</div><div class="line">-     "start": "webpack-dev-server --open",</div><div class="line">+     "start": "webpack-dev-server --open --config webpack.dev.js",</div><div class="line">-     "build": "webpack"</div><div class="line">+     "build": "webpack --config webpack.prod.js"</div><div class="line">    &#125;,</div></pre></td></tr></table></figure><p>除了 <code>UglifyJSPlugin</code> ，类似的比较受欢迎的还有 <code>BabelMinifyWebpackPlugin</code> 和 <code>ClosureCompilerPlugin</code></p><p>鼓励在生产环境中 <code>source-map</code> 选项：</p><p><strong>webpack.prod.js</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">  <span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</div><div class="line">  <span class="keyword">const</span> UglifyJSPlugin = <span class="built_in">require</span>(<span class="string">'uglifyjs-webpack-plugin'</span>);</div><div class="line">  <span class="keyword">const</span> common = <span class="built_in">require</span>(<span class="string">'./webpack.common.js'</span>);</div><div class="line"></div><div class="line">  <span class="built_in">module</span>.exports = merge(common, &#123;</div><div class="line">+   devtool: <span class="string">'source-map'</span>, <span class="comment">//避免在生产中使用 inline-*** 和 eval-***，因为它们增加 bundle 大小。</span></div><div class="line">    plugins: [</div><div class="line">-     <span class="keyword">new</span> UglifyJSPlugin()</div><div class="line">+     <span class="keyword">new</span> UglifyJSPlugin(&#123;</div><div class="line">+       sourceMap: <span class="literal">true</span></div><div class="line">+     &#125;)</div><div class="line">    ]</div><div class="line">  &#125;)</div></pre></td></tr></table></figure><h3 id="指定环境"><a href="#指定环境" class="headerlink" title="指定环境"></a>指定环境</h3><p>webpack.prod.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">+ <span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</div><div class="line">  <span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</div><div class="line">  <span class="keyword">const</span> UglifyJSPlugin = <span class="built_in">require</span>(<span class="string">'uglifyjs-webpack-plugin'</span>);</div><div class="line">  <span class="keyword">const</span> common = <span class="built_in">require</span>(<span class="string">'./webpack.common.js'</span>);</div><div class="line"></div><div class="line">  <span class="built_in">module</span>.exports = merge(common, &#123;</div><div class="line">    devtool: <span class="string">'cheap-module-source-map'</span>,</div><div class="line">    plugins: [</div><div class="line">      <span class="keyword">new</span> UglifyJSPlugin(&#123;</div><div class="line">        sourceMap: <span class="literal">true</span></div><div class="line">      &#125;),</div><div class="line">+     <span class="keyword">new</span> webpack.DefinePlugin(&#123; <span class="comment">// 用 webpack 内置的 DefinePlugin 为所有的依赖定义这个变量</span></div><div class="line">+       <span class="string">'process.env'</span>: &#123; <span class="comment">// 许多 library 将通过与 process.env.NODE_ENV 环境变量关联，以决定 library 中应该引用哪些内容</span></div><div class="line">+         <span class="string">'NODE_ENV'</span>: <span class="built_in">JSON</span>.stringify(<span class="string">'production'</span>)</div><div class="line">+       &#125;</div><div class="line">+     &#125;)</div><div class="line">    ]</div><div class="line">  &#125;)</div></pre></td></tr></table></figure><h2 id="代码分离"><a href="#代码分离" class="headerlink" title="代码分离"></a>代码分离</h2><p>此特性能够把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件。代码分离可以用于获取更小的 bundle，以及控制资源加载优先级，如果使用合理，会极大影响加载时间。</p><ul><li><p>入口起点：使用 entry 配置手动地分离代码</p></li><li><p>防止重复：使用 <code>CommonsChunkPlugin</code> 去重和分离代码。</p></li><li><p>动态导入：通过模块的内联函数调用来分离代码。(<code>import</code> 和 <code>async</code>)</p></li></ul><h3 id="bundle-分析"><a href="#bundle-分析" class="headerlink" title="bundle 分析"></a>bundle 分析</h3><p>官方分析工具和社区支持的可选工具</p><h2 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h2><p><a href="https://alexjoverm.github.io/2017/07/16/Lazy-load-in-Vue-using-Webpack-s-code-splitting/" target="_blank" rel="external">Vue的懒加载</a></p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>由于缓存的技术，需要修改文件名，浏览器才能知道更新。</p><p>使用 <code>[chunkhash]</code> 替换，将 <code>output</code> 中修改为 <code>filename: &#39;[name].[chunkname].js&#39;</code></p><h3 id="提取模板-Extracting-Boilerplate"><a href="#提取模板-Extracting-Boilerplate" class="headerlink" title="提取模板(Extracting Boilerplate)"></a>提取模板(Extracting Boilerplate)</h3><p>还是webpack 的内置插件 <code>CommonChunkPlugin</code>，可以将 wepack 的样板和 manifest 提取出来。通过指定 entry 配置中未用到的名称，此插件会自动将我们需要的内容提取到单独的包中。</p><p>在 <code>plugins</code> 中加入实例 <code>new webpack.optimize.CommonsChunkPlugin({ name: &#39;runtime&#39; })</code></p><p>推荐将第三方库提取到单独的 <code>vendor</code> chunk 文件中，因为它们很少像本地源码那样频繁修改。<br>这可以通过使用新的 entry(入口) 起点，以及再额外配置一个 CommonsChunkPlugin 实例的组合方式来实现。</p><h3 id="模块标识符-Module-Identifiers"><a href="#模块标识符-Module-Identifiers" class="headerlink" title="模块标识符(Module Identifiers)"></a>模块标识符(Module Identifiers)</h3><p>由于模块标识符会基于默认的解析顺序进行增量，导致在修改本地依赖时，vendor 的 hash 发生变化，可以使用两个插件解决这个问题。<code>NamedModulesplugin</code> 和 <code>HashedModuleIdsPlugin</code>，前者使用模块的路径代替数字标识符，可读性高但执行时间长适合开发过程中使用，后者更适合生产环境。</p><h2 id="创建-Library"><a href="#创建-Library" class="headerlink" title="创建 Library"></a>创建 Library</h2><p>除了打包应用程序代码，webpack 还可以用于打包 JavaScript library。（暂时不需要了解）</p><h2 id="Shimming"><a href="#Shimming" class="headerlink" title="Shimming"></a>Shimming</h2><h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><h2 id="使用环境变量"><a href="#使用环境变量" class="headerlink" title="使用环境变量"></a>使用环境变量</h2><p>需要环境变量来消除开发和生产构建之间 <code>webpack.config.js</code> 的差异。</p><p>webpack 命令行环境配置中，通过设置 <code>--env</code> 可以使你根据需要，传入尽可能多的环境变量。在 <code>webpack.config.js</code> 文件中可以访问到这些环境变量。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack --env.NODE_ENV=local --env.production --progress</div></pre></td></tr></table></figure><p>如果设置 <code>env</code> 变量，却没有赋值，<code>--env.production</code> 默认将 <code>--env.production</code> 设置为 <code>true</code>。</p><p>通常，在 webpack config 中，<code>module.exports</code> 指向配置对象。要使用 <code>env</code> 变量，你必须将 <code>module.exports</code> 转换成一个函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">env</span> =&gt;</span> &#123;</div><div class="line">  <span class="comment">// Use env.&lt;YOUR VARIABLE&gt; here:</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'NODE_ENV: '</span>, env.NODE_ENV) <span class="comment">// 'local'</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Production: '</span>, env.production) <span class="comment">// true</span></div><div class="line"></div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    entry: <span class="string">'./src/index.js'</span>,</div><div class="line">    output: &#123;</div><div class="line">      filename: <span class="string">'bundle.js'</span>,</div><div class="line">      path: path.resolve(__dirname, <span class="string">'dist'</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="构建性能"><a href="#构建性能" class="headerlink" title="构建性能"></a>构建性能</h2><p>提到一些优化性能的方法</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;随着 Vue.js 的学习，webpack 已然是必须要掌握的工具。目前，webpack 版本更新到 &lt;code&gt;v3.10.0&lt;/code&gt; 了，相比以前应该是优化并成熟了很多。&lt;a href=&quot;https://doc.webpack-china.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;webpack中文官网&lt;/a&gt;上有详细的文档，这篇文章作为我的学习笔记，就大概地记录下重要的知识点。&lt;br&gt;&lt;a href=&quot;https://doc.webpack-china.org/configuration&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;详细配置&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Learning" scheme="http://huguokang.com/categories/Learning/"/>
    
    
      <category term="Webpack3.0" scheme="http://huguokang.com/tags/Webpack3-0/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js学习笔记11</title>
    <link href="http://huguokang.com/2017/11/27/Vue.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B011/"/>
    <id>http://huguokang.com/2017/11/27/Vue.js学习笔记11/</id>
    <published>2017-11-27T08:45:18.000Z</published>
    <updated>2017-11-30T14:13:46.715Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h1><p>Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。它采用集中式存储管理应用的所以组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p><p><img src="http://oy7msxtdy.bkt.clouddn.com/vuex.png" alt="vuex"></p><a id="more"></a><h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><h3 id="单一状态树"><a href="#单一状态树" class="headerlink" title="单一状态树"></a>单一状态树</h3><p>意味着每一个应用只包含一个 store 实例。</p><h3 id="在-Vue-组件中获得-Vuex-状态"><a href="#在-Vue-组件中获得-Vuex-状态" class="headerlink" title="在 Vue 组件中获得 Vuex 状态"></a>在 Vue 组件中获得 Vuex 状态</h3><p>由于 Vuex 的状态存储是响应式的，可以在计算属性中返回某个从 store 实例中读取的状态：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一个 Counter 组件</span></div><div class="line"><span class="keyword">const</span> Counter = &#123;</div><div class="line">  template: <span class="string">'&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;'</span>,</div><div class="line">  computed: &#123;</div><div class="line">    count () &#123;</div><div class="line">      <span class="keyword">return</span> store.state.count</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这种模式导致组件依赖全局状态单例。在模块化的构建系统中，在每个需要使用 state 的组件中需要频繁地导入，并且在测试组件时需要模拟状态（没看懂）。</p><p>Vuex 通过 store 选项，提供了一种机制将状态从根组件“注入”到每一个子组件中（需要调用 <code>Vue.use(Vuex)</code> ）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</div><div class="line">  el: <span class="string">'#app'</span>,</div><div class="line">  <span class="comment">// 把 store 对象提供给 "store" 选项，这可以把 store 的实例注入所有子组件</span></div><div class="line">  store,</div><div class="line">  components: &#123; Counter &#125;,</div><div class="line">  template: <span class="string">'</span></div><div class="line"><span class="string">    &lt;div class="app"&gt;\</span></div><div class="line"><span class="string">      &lt;counter&gt;&lt;/counter&gt;\</span></div><div class="line"><span class="string">    &lt;/div&gt;\</span></div><div class="line"><span class="string">  '</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure><p><strong>通过在根实例中注册 <code>store</code> 选项，该 <code>store</code> 实例会注入到根组件下的所有子组件中，且子组件能通过 <code>this.$store</code> 访问到</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> Counter = &#123;</div><div class="line">  template: <span class="string">'&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;'</span>,</div><div class="line">  computed: &#123;</div><div class="line">    count () &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.count</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="mapState-辅助函数"><a href="#mapState-辅助函数" class="headerlink" title="mapState 辅助函数"></a><code>mapState</code> 辅助函数</h3><p>它可以帮助我们生成计算属性，当一个组件需要获取多个状态时。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在单独构建的版本中辅助函数为 Vuex.mapState</span></div><div class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  computed: mapState(&#123;</div><div class="line">    count: <span class="function"><span class="params">state</span> =&gt;</span> state.count,</div><div class="line">    <span class="comment">// 传字符串参数 'count' 等同于 'state.count'</span></div><div class="line">    countAlias: <span class="string">'count'</span>,</div><div class="line"></div><div class="line">    <span class="comment">// 为了能够使用 'this' 获取局部状态，必须使用常规函数</span></div><div class="line">    countPlusLoaclState (state) &#123;</div><div class="line">      <span class="keyword">return</span> state.count + <span class="keyword">this</span>.loaclCount</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 <code>mapState</code> 传入一个字符串数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">computed: mapState([</div><div class="line">  <span class="comment">// 映射 this.count 为 store.state.count </span></div><div class="line">  <span class="string">'count'</span></div><div class="line">])</div></pre></td></tr></table></figure><h3 id="对象展开运算符"><a href="#对象展开运算符" class="headerlink" title="对象展开运算符"></a>对象展开运算符</h3><p>我们可以用它将 <code>mapState</code> 函数返回的对象和局部计算属性合并为一个，最终传递给 <code>computed</code> 属性。</p><h3 id="组件仍然保有局部状态"><a href="#组件仍然保有局部状态" class="headerlink" title="组件仍然保有局部状态"></a>组件仍然保有局部状态</h3><h2 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h2><p>Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p><p>Getter 接受 state 作为其第一个参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.store(&#123;</div><div class="line">  state: &#123;</div><div class="line">    todos: [</div><div class="line">      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">'...'</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;,</div><div class="line">      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">'...'</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;,</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  getters: &#123;</div><div class="line">    doneTodos: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</div><div class="line">      <span class="keyword">return</span> state.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.done)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>Getter 会暴露为 <code>store.getters</code> 对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">store.getters.doneTodos <span class="comment">// -&gt; [&#123; id: 1, text: '...', done: true &#125;]</span></div></pre></td></tr></table></figure><p>Getter 也可以接收其它 getter 作为第二个参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">getters: &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  doneTodosCount: <span class="function">(<span class="params">state, getters</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> getters.doneTodos.length</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">store.getters.doneTodosCount  <span class="comment">// -&gt; 1</span></div></pre></td></tr></table></figure><p>在组件中使用它：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">computed: &#123;</div><div class="line">  doneTodosCount () &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.doneTodoCount</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以通过让 getter 返回一个函数，来实现给 getter 传参。这样查询 store 里的数组就很方便。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">getters: &#123;</div><div class="line">  <span class="comment">// ... </span></div><div class="line">  getTodoById: <span class="function">(<span class="params">state, getters</span>) =&gt;</span> (id) =&gt; &#123;</div><div class="line">    <span class="keyword">return</span> state.todos.find(todo.id === id) <span class="comment">// id =&gt; id === todo.id (find方法接收回调函数用于找到第一个符合条件的数组成员)</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">store.getters.getTodoById(<span class="number">2</span>) <span class="comment">// -&gt; &#123; id : 2, text: '...', done: false&#125;</span></div></pre></td></tr></table></figure><h3 id="mapGetter-辅助函数"><a href="#mapGetter-辅助函数" class="headerlink" title="mapGetter 辅助函数"></a><code>mapGetter</code> 辅助函数</h3><p>将 store 中的 getter 映射到局部计算属性：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">'Vuex'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  computed: &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    computed: &#123;</div><div class="line">      <span class="comment">// 使用对象展开运算符将 getter 混入 computed 对象中</span></div><div class="line">      ...mapGetters([</div><div class="line">        <span class="string">'doneTodosCount'</span>, <span class="comment">// this.doneTodosCount = store.getters.doneTodosCount</span></div><div class="line">        <span class="string">'anotherGetter'</span>,</div><div class="line">        <span class="comment">// ...</span></div><div class="line">      ])</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>可以使用对象形式给一个 getter 属性另取一个名字：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mapGetters(&#123;</div><div class="line">  <span class="comment">// 映射 'this.doneCount' 为 'store.getters.doneTodosCount'</span></div><div class="line">  doneCount: <span class="string">'doneTodosCount'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure><h2 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h2><p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation（变化）。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的<strong>事件类型</strong> (type) 和 一个<strong>回调函数</strong> (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">  state: &#123;</div><div class="line">    count: <span class="number">1</span></div><div class="line">  &#125;,</div><div class="line">  mutation: &#123;</div><div class="line">    increment (state) &#123;</div><div class="line">      <span class="comment">// 变更状态</span></div><div class="line">      state.count++</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>你不能直接调用一个 mutation handler。这个选项更像是事件注册：“当触发一个类型为 <code>increment</code> 的 mutation 时，调用此函数。”要唤醒一个 mutation handler，你需要以相应的 type 调用 <code>store.commit</code> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">store.commit(<span class="string">'increment'</span>)</div></pre></td></tr></table></figure><h3 id="提交载荷（Payload）"><a href="#提交载荷（Payload）" class="headerlink" title="提交载荷（Payload）"></a>提交载荷（Payload）</h3><p>你可以向 <code>store.commit</code> 传入额外的参数，即载荷</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ...</span></div><div class="line">mutations: &#123;</div><div class="line">  increment (state, n) &#123;</div><div class="line">    state.count += n</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">store.commit(<span class="string">'increment'</span>, <span class="number">10</span>)</div></pre></td></tr></table></figure><p>在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ...</span></div><div class="line">mutations: &#123;</div><div class="line">  increment (state, payload) &#123;</div><div class="line">    state.count += payload.amount</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">store.commit(<span class="string">'increment'</span>, &#123;</div><div class="line">  amount: <span class="number">10</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure><h3 id="对象风格的提交方式"><a href="#对象风格的提交方式" class="headerlink" title="对象风格的提交方式"></a>对象风格的提交方式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">store.commit(&#123;</div><div class="line">  type: <span class="string">'increment'</span>,</div><div class="line">  amount: <span class="number">10</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure><h3 id="Mutation-需遵守-Vue-的响应规则"><a href="#Mutation-需遵守-Vue-的响应规则" class="headerlink" title="Mutation 需遵守 Vue 的响应规则"></a>Mutation 需遵守 Vue 的响应规则</h3><ol><li><p>最好提前在你的 store 中初始化好所有所需属性。</p></li><li><p>当需要在对象上添加新属性时，你应该</p><ul><li><p>使用 <code>Vue.set(obj, &#39;newProp&#39;, 123)</code>，</p></li><li><p>或者以新对象替换老对象，利用对象展开运算符：</p><p><code>state.obj = { ...state.obj, newProp: 123 }</code></p></li></ul></li></ol><h3 id="使用常量替代-Mutation-事件类型"><a href="#使用常量替代-Mutation-事件类型" class="headerlink" title="使用常量替代 Mutation 事件类型"></a>使用常量替代 Mutation 事件类型</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// mutation-types.js</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> SOME_MUTATION = <span class="string">'SOME_MUTATION'</span></div><div class="line"></div><div class="line"><span class="comment">// store.js</span></div><div class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></div><div class="line"><span class="keyword">import</span> &#123; SOME_MUTATION &#125; <span class="keyword">from</span> <span class="string">'./mutation-types'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">  state: &#123; ... &#125;,</div><div class="line">  mutations: &#123;</div><div class="line">    <span class="comment">// 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名 （属性名表达式）</span></div><div class="line">    [SOME_MUTATION] (state) &#123;</div><div class="line">      <span class="comment">// mutate state</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><h3 id="Mutation-必须是同步函数"><a href="#Mutation-必须是同步函数" class="headerlink" title="Mutation 必须是同步函数"></a>Mutation 必须是同步函数</h3><p>因为任何在回调函数中进行的状态的改变都是不可追踪的。</p><h3 id="在组件中提交-Mutation"><a href="#在组件中提交-Mutation" class="headerlink" title="在组件中提交 Mutation"></a>在组件中提交 Mutation</h3><p>你可以在组件中使用 <code>this.$store.commit(&#39;xxx&#39;)</code> 提交 mutation，或者使用 <code>mapMutations</code> 辅助函数将组件中的 <code>methods</code> 映射为 <code>store.commit</code> 调用（需要在根节点注入 <code>store</code>）。  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; mapMutations &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  methods: &#123;</div><div class="line">    ...mapMutations([</div><div class="line">      <span class="string">'increment'</span>, <span class="comment">// 将 `this.increment()` 映射为 `this.$store.commit('increment')`</span></div><div class="line"></div><div class="line">      <span class="comment">// 'mapMutations' 也支持载荷</span></div><div class="line">      <span class="string">'incrementBy'</span> <span class="comment">// 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)`</span></div><div class="line">    ]),</div><div class="line">    ...mapMutation(&#123;</div><div class="line">      add: <span class="string">'increment'</span> <span class="comment">// 将 `this.add()` 映射为 `this.$store.commit('increment')`</span></div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h2><p>Action 类似于 mutation，不同在于：</p><ul><li>Action 提交的是 mutation，而不是直接变更状态。<br></li><li>Action 可以包含任意异步操作。</li></ul><p>注册一个简单的 action ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vue.Store(&#123;</div><div class="line">  state: &#123;</div><div class="line">    count: <span class="number">0</span></div><div class="line">  &#125;,</div><div class="line">  mutation: &#123;</div><div class="line">    increment (state) &#123;</div><div class="line">      state.count++</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  actions: &#123;</div><div class="line">    increment (context) &#123;</div><div class="line">      context.commit(<span class="string">'increment'</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 <code>context.commit</code> 提交一个 mutation，或者通过 <code>context.state</code> 和 <code>context.getters</code>  来获取 state 和 getters。</p><p>当需要调用 <code>commit</code> 很多次的时候，可以用 ES2015 的参数结构来简化代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">action: &#123;</div><div class="line">  increment (&#123; commit &#125;) &#123; <span class="comment">// 是这个 &#123; context.commit: context.commit &#125; 的解构吗？</span></div><div class="line">    commit(<span class="string">'increment'</span>)  <span class="comment">// </span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="分发-Action"><a href="#分发-Action" class="headerlink" title="分发 Action"></a>分发 Action</h3><p>Action 通过 <code>store.dispatch</code> 方法触发：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">store.dispach(<span class="string">'increment'</span>)</div></pre></td></tr></table></figure><p>我们可以在 action 内部执行异步操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">action: &#123;</div><div class="line">  incrementAsync (&#123; commit &#125;) &#123;</div><div class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      commit(<span class="string">'increment'</span>)</div><div class="line">    &#125;, <span class="number">1000</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Actions 支持同样的载荷方式和对象方式进行分发：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 以载荷形式分发</span></div><div class="line">store.dispatch(<span class="string">'incrementAsync'</span>, &#123;</div><div class="line">  amount: <span class="number">10</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 以对象形式分发</span></div><div class="line">store.dispatch(&#123;</div><div class="line">  type: <span class="string">'incrementAsync'</span>,</div><div class="line">  amount: <span class="number">10</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>购物车示例，涉及到调用异步 API 和分发多重 mutation ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">actions: &#123;</div><div class="line">  checkout (&#123; commit, state &#125;, product) &#123;</div><div class="line">    <span class="comment">// 把当前购物车的物品备份起来</span></div><div class="line">    <span class="keyword">const</span> savedCartItems = [...state.cart.added]</div><div class="line">    <span class="comment">// 发出结账请求，然后清空购物车</span></div><div class="line">    commit(type.CHECKOUT_REQUEST)</div><div class="line">    <span class="comment">// 购物 API 接受一个成功回调和一个失败回调</span></div><div class="line">    shop.buyProducts(</div><div class="line">      products,</div><div class="line">      <span class="comment">// 成功操作</span></div><div class="line">      () =&gt; commit(type.CHECKOUT_SUCCESS),</div><div class="line">      <span class="comment">// 失败操作</span></div><div class="line">      () =&gt; commit(type.CHECKOUT_FAILURE, savedCartItems)</div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="在组件中分发-Action"><a href="#在组件中分发-Action" class="headerlink" title="在组件中分发 Action"></a>在组件中分发 Action</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; mapActions &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  methods: &#123;</div><div class="line">    ...mapActions([</div><div class="line">      <span class="string">'increment'</span>, <span class="comment">// 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`</span></div><div class="line"></div><div class="line">      <span class="comment">// `mapActions` 也支持载荷：</span></div><div class="line">      <span class="string">'incrementBy'</span> <span class="comment">// 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)`</span></div><div class="line">    ]),</div><div class="line">    ...mapActions(&#123;</div><div class="line">      add: <span class="string">'increment'</span> <span class="comment">// 将 `this.add()` 映射为 `this.$store.dispatch('increment')`</span></div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="组合-Action"><a href="#组合-Action" class="headerlink" title="组合 Action"></a>组合 Action</h3><p><code>store.dispatch</code> 可以处理被触发的 action 的处理函数返回的 Promise，并且 <code>store.dispatch</code> 仍旧返回 Promise：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">action: &#123;</div><div class="line">  actionA (&#123; commit &#125;) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        commit(<span class="string">'someMutation'</span>),</div><div class="line">        resolve()</div><div class="line">      &#125;, <span class="number">1000</span>)</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>现在可以：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">store.dispatch(<span class="string">'actionA'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>在另一个 action 中也可以：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">actions: &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  actionB (&#123; dispatch, commit&#125;) &#123;</div><div class="line">    <span class="keyword">return</span> dispatch(<span class="string">'actionA'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      commit(<span class="string">'someOtherMutation'</span>)</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h2><p>Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> moduleA = &#123;</div><div class="line">  state: &#123; ... &#125;,</div><div class="line">  mutations: &#123; ... &#125;,</div><div class="line">  actions: &#123; ... &#125;,</div><div class="line">  getters: &#123; ... &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> moduleB = &#123;</div><div class="line">  state: &#123; ... &#125;,</div><div class="line">  mutations: &#123; ... &#125;,</div><div class="line">  actions: &#123; ... &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">  modules: &#123;</div><div class="line">    a: moduleA,</div><div class="line">    b: moduleB</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">store.state.a <span class="comment">// -&gt; moduleA 的状态</span></div><div class="line">store.state.b <span class="comment">// -&gt; moduleB 的状态</span></div></pre></td></tr></table></figure><h3 id="模块的局部状态"><a href="#模块的局部状态" class="headerlink" title="模块的局部状态"></a>模块的局部状态</h3><p>对于模块内部的 mutation 和 getter，接收的第一个参数是模块的局部状态对象。</p><p>同样，对于模块内部的 action，局部状态通过 context.state 暴露出来，根节点状态则为 context.rootState：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> moduleA = &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  actions: &#123;</div><div class="line">    incrementIfOddOnRootSum (&#123; state, commit, rootState &#125;) &#123;</div><div class="line">      <span class="keyword">if</span> ((state.count + rootState.count) % <span class="number">2</span> === <span class="number">1</span>) &#123;</div><div class="line">        commit(<span class="string">'increment'</span>)</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间的——这样使得多个模块能够对同一 mutation 或 action 作出响应。</p><p>如果希望你的模块具有更高的封装度和复用性，你可以通过添加 namespaced: true 的方式使其成为命名空间模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">  modules: &#123;</div><div class="line">    account: &#123;</div><div class="line">      namespaced: <span class="literal">true</span>,</div><div class="line"></div><div class="line">      <span class="comment">// 模块内容（module assets）</span></div><div class="line">      state: &#123; ... &#125;, <span class="comment">// 模块内的状态已经是嵌套的，使用 "namespaced" 属性不会对其产生影响</span></div><div class="line">      getters: &#123;</div><div class="line">        isAdmin () &#123; ... &#125; <span class="comment">// -&gt; getters['account/isAdmin']</span></div><div class="line">      &#125;,</div><div class="line">      actions: &#123;</div><div class="line">        login () &#123; ... &#125; <span class="comment">// -&gt; dispatch('account/login')</span></div><div class="line">      &#125;,</div><div class="line">      mutations: &#123;</div><div class="line">        login () &#123; ... &#125; <span class="comment">// -&gt; commit('account/login')</span></div><div class="line">      &#125;,</div><div class="line"></div><div class="line">      <span class="comment">// 嵌套模块</span></div><div class="line">      modules: &#123;</div><div class="line">        <span class="comment">// 继承父模块的命名空间</span></div><div class="line">        myPage: &#123;</div><div class="line">          state: &#123; ... &#125;,</div><div class="line">          getters: &#123;</div><div class="line">            profile () &#123; ... &#125; <span class="comment">// -&gt; getters['account/profile']</span></div><div class="line">          &#125;</div><div class="line">        &#125;,</div><div class="line"></div><div class="line">        <span class="comment">// 进一步嵌套命名空间</span></div><div class="line">        posts: &#123;</div><div class="line">          namespaced: <span class="literal">true</span>,</div><div class="line"></div><div class="line">          state: &#123; ... &#125;,</div><div class="line">          getters: &#123;</div><div class="line">            popular () &#123; ... &#125; <span class="comment">// -&gt; getters['account/posts/popular']</span></div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>启用了命名空间的 getter 和 action 会收到局部化的 getter，dispatch 和 commit。换言之，你在使用模块内容（module assets）时不需要在同一模块内额外添加空间名前缀。更改 namespaced 属性后不需要修改模块内的代码。</p><h3 id="在命名空间模块内访问全局内容（Global-Assets）"><a href="#在命名空间模块内访问全局内容（Global-Assets）" class="headerlink" title="在命名空间模块内访问全局内容（Global Assets）"></a>在命名空间模块内访问全局内容（Global Assets）</h3><p>如果你希望使用全局 state 和 getter，rootState 和 rootGetter 会作为第三和第四参数传入 getter，也会通过 context 对象的属性传入 action。</p><p>若需要在全局命名空间内分发 action 或提交 mutation，将 { root: true } 作为第三参数传给 dispatch 或 commit 即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">modules: &#123;</div><div class="line">  foo: &#123;</div><div class="line">    namespaced: <span class="literal">true</span>,</div><div class="line"></div><div class="line">    getters: &#123;</div><div class="line">      <span class="comment">// 在这个模块的 getter 中，`getters` 被局部化了</span></div><div class="line">      <span class="comment">// 你可以使用 getter 的第四个参数来调用 `rootGetters`</span></div><div class="line">      someGetter (state, getters, rootState, rootGetters) &#123;</div><div class="line">        getters.someOtherGetter <span class="comment">// -&gt; 'foo/someOtherGetter'</span></div><div class="line">        rootGetters.someOtherGetter <span class="comment">// -&gt; 'someOtherGetter'</span></div><div class="line">      &#125;,</div><div class="line">      someOtherGetter: <span class="function"><span class="params">state</span> =&gt;</span> &#123; ... &#125;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    actions: &#123;</div><div class="line">      <span class="comment">// 在这个模块中， dispatch 和 commit 也被局部化了</span></div><div class="line">      <span class="comment">// 他们可以接受 `root` 属性以访问根 dispatch 或 commit</span></div><div class="line">      someAction (&#123; dispatch, commit, getters, rootGetters &#125;) &#123;</div><div class="line">        getters.someGetter <span class="comment">// -&gt; 'foo/someGetter'</span></div><div class="line">        rootGetters.someGetter <span class="comment">// -&gt; 'someGetter'</span></div><div class="line"></div><div class="line">        dispatch(<span class="string">'someOtherAction'</span>) <span class="comment">// -&gt; 'foo/someOtherAction'</span></div><div class="line">        dispatch(<span class="string">'someOtherAction'</span>, <span class="literal">null</span>, &#123; <span class="attr">root</span>: <span class="literal">true</span> &#125;) <span class="comment">// -&gt; 'someOtherAction'</span></div><div class="line"></div><div class="line">        commit(<span class="string">'someMutation'</span>) <span class="comment">// -&gt; 'foo/someMutation'</span></div><div class="line">        commit(<span class="string">'someMutation'</span>, <span class="literal">null</span>, &#123; <span class="attr">root</span>: <span class="literal">true</span> &#125;) <span class="comment">// -&gt; 'someMutation'</span></div><div class="line">      &#125;,</div><div class="line">      someOtherAction (ctx, payload) &#123; ... &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="带命名空间的绑定函数"><a href="#带命名空间的绑定函数" class="headerlink" title="带命名空间的绑定函数"></a>带命名空间的绑定函数</h3><p>当使用 mapState, mapGetters, mapActions 和 mapMutations 这些函数来绑定命名空间模块时，你可以将模块的空间名称字符串作为第一个参数传递给上述函数，这样所有绑定都会自动将该模块作为上下文。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">computed: &#123;</div><div class="line">  ...mapState(<span class="string">'some/nested/module'</span>, &#123;</div><div class="line">    a: <span class="function"><span class="params">state</span> =&gt;</span> state.a.</div><div class="line">    b: <span class="function"><span class="params">state</span> =&gt;</span> state.b</div><div class="line">  &#125;)</div><div class="line">&#125;,</div><div class="line">methods: &#123;</div><div class="line">  ...mapActions(<span class="string">'some/nested/module'</span>, [</div><div class="line">    <span class="string">'foo'</span>,</div><div class="line">    <span class="string">'bar'</span></div><div class="line">  ])</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>而且，你可以通过使用 createNamespacedHelpers 创建基于某个命名空间辅助函数。它返回一个对象，对象里有新的绑定在给定命名空间值上的组件绑定辅助函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; createNamespacedHelpers &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> &#123; mapState, mapActions &#125; = createNamespacedHelpers(<span class="string">'some/nested/module'</span>)</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  computed: &#123;</div><div class="line">    <span class="comment">// 在 'some/nested/module' 中查找</span></div><div class="line">    ...mapState(&#123;</div><div class="line">      a: <span class="function"><span class="params">state</span> =&gt;</span> state.a,</div><div class="line">      b: <span class="function"><span class="params">state</span> =&gt;</span> state.b</div><div class="line">    &#125;)</div><div class="line">  &#125;,</div><div class="line">  methods: &#123;</div><div class="line">    <span class="comment">// 在 `some/nested/module` 中查找</span></div><div class="line">    ...mapActions([</div><div class="line">      <span class="string">'foo'</span>,</div><div class="line">      <span class="string">'bar'</span></div><div class="line">    ])</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="给插件开发者的注意事项"><a href="#给插件开发者的注意事项" class="headerlink" title="给插件开发者的注意事项"></a>给插件开发者的注意事项</h3><p>呵呵，我啥时候能开发插件再来看吧。。。</p><h3 id="模块动态注册"><a href="#模块动态注册" class="headerlink" title="模块动态注册"></a>模块动态注册</h3><p>在 store 创建之后，你可以使用 <code>store.registerModule</code> 方法注册模块：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 注册模块 `myModule`</span></div><div class="line">store.registerModule(<span class="string">'myModule'</span>, &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;)</div><div class="line"><span class="comment">// 注册嵌套模块  `nested/myModule`</span></div><div class="line">store.registerModule([<span class="string">'nested'</span>, <span class="string">'myModule'</span>], &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>之后就可以通过 store.state.myModule 和 store.state.nested.myModule 访问模块的状态。</p><p>模块动态注册功能使得其他 Vue 插件可以通过在 store 中附加新模块的方式来使用 Vuex 管理状态。例如，vuex-router-sync 插件就是通过动态注册模块将 vue-router 和 vuex 结合在一起，实现应用的路由状态管理。</p><p>你也可以使用 store.unregisterModule(moduleName) 来动态卸载模块。注意，你不能使用此方法卸载静态模块（即创建 store 时声明的模块）。</p><p>在注册一个新 module 时，你很有可能想保留过去的 state，例如从一个服务端渲染的应用保留 state。你可以通过 preserveState 选项将其归档：store.registerModule(‘a’, module, { preserveState: true })。（等我遇到再说，现在还不懂服务端渲染）</p><h3 id="模块重用"><a href="#模块重用" class="headerlink" title="模块重用"></a>模块重用</h3><p>有时我们可能需要创建一个模块的多个实例，例如：</p><ul><li><p>创建多个 store，它们公用一个模块</p></li><li><p>在一个 store 中多次注册一个模块</p></li></ul><p>如果我们使用一个纯对象来声明模块的状态，那么这个状态对象会通过引用被共享，导致状态对象被修改时 store 或模块间数据互相污染的问题。</p><p>实际上这和 Vue 组件内的 data 是同样的问题。因此解决办法也是相同的——使用一个函数来声明模块状态（仅 2.3.0+ 支持）：</p><p>```js<br>const MyReusableModule = {<br>  state () {<br>    return {<br>      foo: ‘bar’<br>    }<br>  },<br>  // mutation, action 和 getter 等等…<br>}</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Vuex&quot;&gt;&lt;a href=&quot;#Vuex&quot; class=&quot;headerlink&quot; title=&quot;Vuex&quot;&gt;&lt;/a&gt;Vuex&lt;/h1&gt;&lt;p&gt;Vuex 是一个专为 Vue.js 应用程序开发的&lt;strong&gt;状态管理模式&lt;/strong&gt;。它采用集中式存储管理应用的所以组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oy7msxtdy.bkt.clouddn.com/vuex.png&quot; alt=&quot;vuex&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Learning" scheme="http://huguokang.com/categories/Learning/"/>
    
    
      <category term="Vue.js" scheme="http://huguokang.com/tags/Vue-js/"/>
    
      <category term="vuex" scheme="http://huguokang.com/tags/vuex/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js学习笔记10</title>
    <link href="http://huguokang.com/2017/11/26/Vue.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B010/"/>
    <id>http://huguokang.com/2017/11/26/Vue.js学习笔记10/</id>
    <published>2017-11-26T00:48:51.000Z</published>
    <updated>2017-11-27T07:37:20.737Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><strong>概述</strong></p><p>vue-router 是 Vue.js 官方的路由插件，它和 Vue.js 是深度集成的，适合用于构建单页面应用。Vue 的单页面应用是基于路由和组件的，路由用于设定访问路径，并将路径和组件映射起来。传统的页面应用，是用一些超链接来实现页面切换和跳转的。在 vue-router 单页面应用中，则是路径之间的切换，也就是组件的切换。</p><a id="more"></a><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><strong>NPM</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install vue-router</div></pre></td></tr></table></figure><p>如果在一个模块化工程中使用它，必须要通过 Vue.use() 明确地安装路由功能：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ipmort Vue <span class="keyword">from</span> <span class="string">'vue'</span></div><div class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span></div><div class="line"></div><div class="line">Vue.use(VueRouter)</div></pre></td></tr></table></figure><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>使用 Vue.js ，我们已经可以通过组合组件来组成应用程序，当你要把 vue-router 添加进来，我们需要做的是，将组件（components）映射到路由（routes），然后告诉 vue-router 在哪里渲染它们。</p><p><strong>HTML</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/vue/dist/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/vue-router/dist/vue-router.js"</span>&gt;</span><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span></div><div class="line"><span class="javascript">  &lt;h1&gt;Hello App!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span></div><div class="line"><span class="xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span></div><div class="line"><span class="xml">    <span class="comment">&lt;!-- 使用 router-link 组件来导航 --&gt;</span></span></div><div class="line"><span class="xml">    <span class="comment">&lt;!-- 通过传入 `to` 属性指定链接 --&gt;</span></span></div><div class="line"><span class="xml">    <span class="comment">&lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt;</span></span></div><div class="line"><span class="xml">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/foo"</span>&gt;</span>Go to Foo<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></div><div class="line"><span class="xml">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/bar"</span>&gt;</span>Go to Bar<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></div><div class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></div><div class="line"><span class="xml">  <span class="comment">&lt;!-- 路由出口 --&gt;</span></span></div><div class="line"><span class="xml">  <span class="comment">&lt;!-- 路由匹配到的组件将渲染在这里 --&gt;</span></span></div><div class="line"><span class="xml">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div></pre></td></tr></table></figure><p><strong>JavaScript</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 0. 如果使用模块化机制编程，导入 Vue 和 VueRouter ，要调用 Vue.use(VueRouter)</span></div><div class="line"></div><div class="line"><span class="comment">// 1. 定义（路由）组件</span></div><div class="line"><span class="comment">// 可以从其他文件 import 进来</span></div><div class="line"><span class="keyword">const</span> Foo = &#123; <span class="attr">template</span>: <span class="string">'&lt;div&gt;foo&lt;/div&gt;'</span> &#125;</div><div class="line"><span class="keyword">const</span> Bar = &#123; <span class="attr">template</span>: <span class="string">'&lt;div&gt;bar&lt;/div&gt;'</span> &#125;</div><div class="line"></div><div class="line"><span class="comment">// 2. 定义路由</span></div><div class="line"><span class="comment">// 每个路由应该映射一个组件。其中 "component" 可以是</span></div><div class="line"><span class="comment">// 通过 Vue.extend() 创建的组件构造器，</span></div><div class="line"><span class="comment">// 或者，只是一个组件配置对象。</span></div><div class="line"><span class="comment">// 我们晚点在讨论嵌套路由。</span></div><div class="line"><span class="keyword">const</span> routes = [</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'/foo'</span>, <span class="attr">component</span>: Foo &#125;</div><div class="line">  &#123; <span class="attr">path</span>: <span class="string">'/bar'</span>, <span class="attr">component</span>: Bar &#125;</div><div class="line">]</div><div class="line"></div><div class="line"><span class="comment">// 3. 创建 router 实例，然后传 `routes` 配置</span></div><div class="line"><span class="comment">// 你还可以传别的配置参数，不过先这么简单着</span></div><div class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</div><div class="line">  routes <span class="comment">// （ES6缩写）相当于 routes: routes </span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 4. 创建和挂载根实例。</span></div><div class="line"><span class="comment">// 记得要通过 router 配置参数注入路由，</span></div><div class="line"><span class="comment">// 从而让整个应用都带有路由功能</span></div><div class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</div><div class="line">  router</div><div class="line">&#125;).$mount(<span class="string">'#app'</span>)</div></pre></td></tr></table></figure><h2 id="动态路由匹配"><a href="#动态路由匹配" class="headerlink" title="动态路由匹配"></a>动态路由匹配</h2><p>我们经常需要把某种模式匹配到的所有路由全都映射到同个组件。例如，我们有一个 <code>User</code> 组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染。那么，我们可以在 <code>vue-router</code> 的路由路径中使用动态路径参数（dynamic segment）来达到这个效果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> User = &#123;</div><div class="line">  template: <span class="string">'&lt;div&gt;User&lt;/div&gt;'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</div><div class="line">  routes: [</div><div class="line">    <span class="comment">// 动态路径参数 以冒号开头</span></div><div class="line">    &#123; <span class="attr">path</span>: <span class="string">'/user/:id'</span>, <span class="attr">component</span>: User &#125;</div><div class="line">  ]</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>像 <code>/user/foo</code> 和 <code>/user/bar</code> 都将映射到相同的路由。</p><p>一个路径参数使用冒号 <code>:</code> 标记。当匹配到一个路由时，参数值会被设置到 <code>this.$route.params</code> ，可以在每个组件内使用。于是我们可以更新 <code>User</code>  的模板，输入当前用户的 ID：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> User = &#123;</div><div class="line">  template: <span class="string">'&lt;idv&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>你可以在一个路由中设置多段路径参数，对应的值都会设置到 <code>$route.params</code> 中。例如：</p><table><thead><tr><th>模式</th><th>匹配路径</th><th>$route.params</th></tr></thead><tbody><tr><td>/user/:username</td><td>/user/evan</td><td>{ <code>username: &#39;evan&#39;</code> }</td></tr><tr><td>/user/:username/post/:post_id</td><td>user/evan/post/123</td><td>{ <code>username: &#39;eavn&#39;, post_id: 123</code>}</td></tr></tbody></table><p>除了 <code>$route.params</code> 外，<code>$route</code> 对象还提供了其它有用的信息。可以查看<a href="https://router.vuejs.org/zh-cn/api/route-object.html" target="_blank" rel="external">API文档</a>的详细说明。</p><h3 id="响应路由参数的变化"><a href="#响应路由参数的变化" class="headerlink" title="响应路由参数的变化"></a>响应路由参数的变化</h3><p>提醒一下，当使用路由参数时，例如从 <code>/user/foo</code> 导航到 <code>user/bar</code> ，原来的组件实例会被复用。因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。不过，这也意味着组件的生命周期钩子不会再被调用。</p><p>复用组件时，想对路由参数的变化作出响应的话，你可以简单地 watch <code>$route</code> 对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> User = &#123;</div><div class="line">  template: <span class="string">'...'</span>,</div><div class="line">  watch: &#123;</div><div class="line">    <span class="string">'$route'</span> (to, <span class="keyword">from</span>) &#123;</div><div class="line">      <span class="comment">// 对路由变化作出响应...</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>或者使用2.2中引入的 <code>beforeRouteUpdate</code>守卫：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> User = &#123;</div><div class="line">  template: <span class="string">'...'</span>,</div><div class="line">  beforeRouteUpdate (to, <span class="keyword">from</span>, next) &#123;</div><div class="line">    <span class="comment">// react to route changes...</span></div><div class="line">    <span class="comment">// don't forget to call next()</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="高级匹配模式"><a href="#高级匹配模式" class="headerlink" title="高级匹配模式"></a>高级匹配模式</h3><p><code>vue-router</code> 使用 path-to-regexp 作为路径匹配引擎，所有支持高级的匹配模式。查看它的<a href="https://github.com/pillarjs/path-to-regexp#parameters" target="_blank" rel="external">文档</a>可以学习高阶的路径匹配。</p><h3 id="匹配优先级"><a href="#匹配优先级" class="headerlink" title="匹配优先级"></a>匹配优先级</h3><p>有时候，同一个路径可以匹配多个路由，此时，匹配的优先级就按照路由的定义顺序：谁先定义的，谁的优先级就最高。</p><h2 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h2><p>实际生活中的应用界面，通常由多层嵌套的组件组合而成的。借助 <code>vue-router</code> ，使用嵌套路由配置，就可以简单地表达这种关系。</p><p>借助上节创建地 app：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> User = &#123;</div><div class="line">  template: <span class="string">'&lt;div&gt;User &#123;&#123; $route.param.id &#125;&#125;&lt;/div&gt;'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</div><div class="line">  routes: [</div><div class="line">    &#123; <span class="attr">path</span>: <span class="string">'/user/:id'</span>, <span class="attr">component</span>: User &#125;</div><div class="line">  ]</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>这里的 <code>&lt;router-view&gt;</code> 是最顶层的出口，渲染最高级路由匹配到的组件。同样地，一个被渲染组件同样可以包含自己的嵌套 <code>&lt;router-view&gt;</code> 。例如在 <code>User</code> 组件的模板添加一个 <code>&lt;router-view&gt;</code> ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> User = &#123;</div><div class="line">  template: <span class="string">'\</span></div><div class="line"><span class="string">    &lt;div class="user"&gt;\</span></div><div class="line"><span class="string">      &lt;h2&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/h2&gt;\</span></div><div class="line"><span class="string">      &lt;router-view&gt;&lt;/router-view&gt;\</span></div><div class="line"><span class="string">    &lt;/div&gt;\</span></div><div class="line"><span class="string">  '</span>\</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>要在嵌套的出口中渲染组件，需要在 <code>VueRouter</code> 的参数中使用 <code>children</code> 配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</div><div class="line">  routes: [</div><div class="line">    &#123; <span class="attr">path</span>: <span class="string">'/user/:id'</span>, <span class="attr">component</span>: User,</div><div class="line">      children: [</div><div class="line">        &#123;</div><div class="line">          <span class="comment">// 当 /user/:id/profile 匹配成功，</span></div><div class="line">          <span class="comment">// UserProfile 会被渲染在 User 的 &lt;router-view&gt; 中</span></div><div class="line">          path: <span class="string">'profile'</span>,</div><div class="line">          component: UserProfile</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">          <span class="comment">// 当 /user/:id/posts 匹配成功</span></div><div class="line">          <span class="comment">// UserPosts 会被渲染在 User 的 &lt;router-view&gt; 中</span></div><div class="line">          path: <span class="string">'posts'</span>,</div><div class="line">          component: UserPosts </div><div class="line">        &#125;</div><div class="line">      ]</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>要注意，以 <code>/</code> 开头的嵌套路径会被当作根路径。这让你充分的使用嵌套组件而无须设置嵌套的路径。</p><p>你会发现，<code>children</code> 配置就是像 <code>routes</code> 配置一样的路由配置数组，所以呢，你可以嵌套多层路由。</p><p>此时，基于上面的配置，当你访问 <code>/user/foo</code> 时，<code>User</code> 的出口是不会渲染任何东西，这是因为没有匹配到合适的子路由。如果你想要渲染点什么，可以提供一个空的子路由：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</div><div class="line">  routes: [</div><div class="line">    &#123;</div><div class="line">      path: <span class="string">'/user/:id'</span>, <span class="attr">component</span>: User,</div><div class="line">      children: [</div><div class="line">        <span class="comment">// 当 /user/:id 匹配成功，</span></div><div class="line">        <span class="comment">// UserHome 会被渲染在 User 的 &lt;router-view&gt; 中</span></div><div class="line">        &#123; <span class="attr">path</span>: <span class="string">''</span>, <span class="attr">component</span>: UserHome &#125;,</div><div class="line"></div><div class="line">        <span class="comment">// ...其它子路由</span></div><div class="line">      ]</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;)</div></pre></td></tr></table></figure><h3 id="编程式的导航"><a href="#编程式的导航" class="headerlink" title="编程式的导航"></a>编程式的导航</h3><p>除了使用 <code>&lt;router-link&gt;</code> 创建 a 标签来定义导航链接，我们还可以借助 router 的实例方法，通过编写代码来实现。</p><p><code>router.push(location, onComplete?, onAbort?)</code></p><p>在 2.2.0+，可选的在 <code>router.push</code> 或 <code>router.replace</code> 中提供 <code>onComplete</code> 和 <code>onAbort</code> 回调作为第二个和第三个参数。这些回调将会在导航成功完成 (在所有的异步钩子被解析之后) 或终止 (导航到相同的路由、或在当前导航完成之前导航到另一个不同的路由) 的时候进行相应的调用。</p><p><strong>注意：在 Vue 实例内部，你可以通过 <code>$router</code> 访问路由实例。因此可以调用 <code>this.$router.push</code>。</strong></p><p>想要导航到不同的 URL，则使用 <code>router.push</code> 方法。这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL。</p><p>当你点击 <code>&lt;router-link&gt;</code> 时，这个方法会在内部调用，所以说，点击 <code>&lt;router-link :to=&quot;...&quot;&gt;</code> 等同于调用 <code>router.push(...)</code>。</p><table><thead><tr><th>声明式</th><th>编程式</th></tr></thead><tbody><tr><td><code>&lt;router-link :to=&quot;...&quot;</code></td><td><code>router.push(...)</code></td></tr></tbody></table><p>该方法的参数可以是一个字符串路径，或者一个地址的对象。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 字符串</span></div><div class="line">router.push(<span class="string">'home'</span>)</div><div class="line"></div><div class="line"><span class="comment">// 对象</span></div><div class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">'home'</span> &#125;)</div><div class="line"></div><div class="line"><span class="comment">// 命名的路由</span></div><div class="line">router.push(&#123; <span class="attr">name</span>: <span class="string">'user'</span>, <span class="attr">params</span>: &#123; <span class="attr">userId</span>: <span class="number">123</span> &#125;&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 带查询参数，变成 /register?plan=private</span></div><div class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">'register'</span>, <span class="attr">query</span>: &#123; <span class="attr">plan</span>: <span class="string">'private'</span> &#125;&#125;)</div></pre></td></tr></table></figure><p>注意：如果提供了 <code>path</code> ，<code>params</code> 会被忽略，上述例子中的 <code>query</code> 并不属于这种情况。你需要像下面一样提供路由的 <code>name</code> 或手写完整的带有参数的 <code>path</code> ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> userId = <span class="number">123</span></div><div class="line">router.push(&#123; <span class="attr">name</span>: <span class="string">'user'</span>, <span class="attr">params</span>: &#123; userId &#125;&#125;) <span class="comment">// -&gt; /user/123</span></div><div class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">'/user/$&#123;userId&#125;'</span> &#125;) <span class="comment">// -&gt; /user/123</span></div><div class="line"><span class="comment">// 这里的 params 不生效</span></div><div class="line">router。push(&#123; <span class="attr">path</span>: <span class="string">'/user'</span>, <span class="attr">params</span>: &#123; userId &#125;&#125;) <span class="comment">// -&gt; /user</span></div></pre></td></tr></table></figure><p><strong>同样的规则也适用于 <code>router-link</code> 组件的 <code>to</code> 属性</strong></p><p><code>router.replace(location, onComplete?, onAbort?)</code></p><p>跟 <code>router.push</code> 很像，唯一的不同就是，它不会向 history 添加新记录，而是替换掉当前的 history 记录。</p><table><thead><tr><th>声明式</th><th>编程式</th></tr></thead><tbody><tr><td><code>&lt;router-link :to=&quot;...&quot; replace</code></td><td><code>router.replace(...)</code></td></tr></tbody></table><p><code>router.go(n)</code></p><p>接收一个整数为参数，意思是在 history 记录中向前或者退后多少步，类似 <code>window.history.go(n)</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 等同于 history.forward()</span></div><div class="line">router.go(<span class="number">1</span>)</div><div class="line"></div><div class="line"><span class="comment">// 等同于 history.back()</span></div><div class="line">router.go(<span class="number">-1</span>)</div><div class="line"></div><div class="line"><span class="comment">// 如果 history 记录不够用，那就失败</span></div><div class="line">router.go(<span class="number">-100</span>)</div></pre></td></tr></table></figure><h2 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h2><p>可以在创建 Router 实例的时候，在 <code>routes</code> 配置中给某个路由设置名称。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</div><div class="line">  routes: [</div><div class="line">    &#123;</div><div class="line">      path: <span class="string">'/user/:userId'</span>,</div><div class="line">      name: <span class="string">'user'</span></div><div class="line">      component: User</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>要链接到一个命名路由，可以给 <code>router-link</code> 的 <code>to</code> 属性传一个对象：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;"</span>&gt;</span>User<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></div></pre></td></tr></table></figure><h2 id="命名视图"><a href="#命名视图" class="headerlink" title="命名视图"></a>命名视图</h2><p>有时候想同时（同级）展示多个视图，而不是嵌套展示，例如创建一个布局，有 <code>sidebar</code>（侧导航） 和 <code>main</code>（主内容） 两个视图，这个时候命名视图就派上用场了。你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 <code>router-view</code> 没有设置名字，那么默认为 <code>default</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">class</span>=<span class="string">"view one"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">class</span>=<span class="string">"view two"</span> <span class="attr">name</span>=<span class="string">"a"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">class</span>=<span class="string">"view three"</span> <span class="attr">name</span>=<span class="string">"b"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></div></pre></td></tr></table></figure><p>一个视图使用一个组件渲染，因此对于同个路由，多个视图就需要多个组件。确保正确使用 <code>components</code> 配置（带上 <code>s</code>）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</div><div class="line">  routes: [</div><div class="line">    &#123;</div><div class="line">      path: <span class="string">'/'</span></div><div class="line">      components: &#123;</div><div class="line">        <span class="keyword">default</span>: Foo,</div><div class="line">        a: Bar,</div><div class="line">        b: Baz</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;)</div></pre></td></tr></table></figure><h2 id="重定向和别名"><a href="#重定向和别名" class="headerlink" title="重定向和别名"></a>重定向和别名</h2><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>重定向也是通过 <code>routes</code> 配置来完成，下面例子是从 <code>/a</code> 重定向到 <code>/b</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</div><div class="line">  routes: [</div><div class="line">    &#123; <span class="attr">path</span>: <span class="string">'/a'</span>, <span class="attr">redirect</span>: <span class="string">'/b'</span> &#125;</div><div class="line">  ]</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>重定向的目标也可以是一个命名的路由：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</div><div class="line">  routes: [</div><div class="line">    &#123; <span class="attr">path</span>: <span class="string">'/a'</span>, <span class="attr">redirect</span>: &#123; <span class="attr">name</span>: <span class="string">'foo'</span> &#125;&#125;</div><div class="line">  ]</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>甚至是一个方法，动态返回重定向目标：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</div><div class="line">  routes: [</div><div class="line">    &#123; <span class="attr">path</span>: <span class="string">'/a'</span>, <span class="attr">redirect</span>: <span class="function"><span class="params">to</span> =&gt;</span> &#123;</div><div class="line">      <span class="comment">// 方法接收 目标路由 作为参数</span></div><div class="line">      <span class="comment">// return 重定向的 字符串路径/路径对象</span></div><div class="line">    &#125;&#125;</div><div class="line">  ]</div><div class="line">&#125;)</div></pre></td></tr></table></figure><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p><code>/a</code> 的别名是 <code>/b</code>，意味着，当用户访问 <code>/b</code> 时，<code>URL</code> 会保持为 <code>/b</code>，但是路由匹配为 <code>/a</code>，就像用户访问 <code>/a</code> 一样。</p><p>上面对应的路由配置为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</div><div class="line">  routes: [</div><div class="line">    &#123; <span class="attr">path</span>: <span class="string">'/a'</span>, <span class="attr">component</span>: A, <span class="attr">alias</span>: <span class="string">'/b'</span> &#125;</div><div class="line">  ]</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>别名的功能然你可以自由地将 UI 结构映射到任意的 URL，而不是受限于配置的嵌套路由结构。</p><h2 id="向路由组件传递-props"><a href="#向路由组件传递-props" class="headerlink" title="向路由组件传递 props"></a>向路由组件传递 props</h2><p>在组件中使用 <code>$route</code> 会使之与其对应路由形成高度耦合，从而使组件只能在某些特定的 url 上使用，限制了其灵活性。</p><p>使用 props 将组件和路由解耦：</p><p><strong>与$route耦合</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> User = &#123;</div><div class="line">  template: <span class="string">'&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;'</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</div><div class="line">  routes: [</div><div class="line">    &#123; <span class="attr">path</span>: <span class="string">'/user/:id'</span>, <span class="attr">component</span>: User &#125;</div><div class="line">  ]</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p><strong>使用props解耦</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> User = &#123;</div><div class="line">  props: [<span class="string">'id'</span>],</div><div class="line">  template: <span class="string">'&lt;div&gt;User &#123;&#123; id &#125;&#125;&lt;/div&gt;'</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</div><div class="line">  routes: [</div><div class="line">    &#123; <span class="attr">path</span>: <span class="string">'/user/:id'</span>, <span class="attr">component</span>: User, <span class="attr">props</span>: <span class="literal">true</span>&#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// 对于包含命名视图的路由，你必须分别为每个命名视图添加 props 选项：</span></div><div class="line">    &#123;</div><div class="line">      path: <span class="string">'/user/:id'</span>,</div><div class="line">      components: &#123; <span class="attr">default</span>: User, <span class="attr">sidebar</span>: Sidebar &#125;,</div><div class="line">      props: &#123; <span class="attr">default</span>: <span class="literal">true</span>, <span class="attr">sidebar</span>: <span class="literal">false</span> &#125;</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>这样你就可以在任何地方使用该组件，使得该组件更易于重用和测试。</p><h3 id="布尔模式"><a href="#布尔模式" class="headerlink" title="布尔模式"></a>布尔模式</h3><p>如果 props 被设置为 true，<code>route.params</code> 将会被设置为组件属性。</p><h3 id="对象模式"><a href="#对象模式" class="headerlink" title="对象模式"></a>对象模式</h3><p>如果props是一个对象，它会被按原样设置为组件属性。当props是静态的时候有用。</p><h3 id="函数模式"><a href="#函数模式" class="headerlink" title="函数模式"></a>函数模式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</div><div class="line">  routes: [</div><div class="line">    &#123; <span class="attr">path</span>: <span class="string">'/search'</span>, <span class="attr">component</span>: SearchUser, <span class="attr">props</span>: <span class="function">(<span class="params">route</span>) =&gt;</span> (&#123; <span class="attr">query</span>: route.query.q &#125;) &#125;</div><div class="line">  ]</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>Url: <code>/search?q=vue</code> 会将 <code>{ query: &quot;vue&quot; }</code> 作为属性传递给 SearchUser 组件。</p><p>请尽可能保持props函数为无状态的，因为它只会在路由发生变化时起作用。如果你需要状态来定义props，请使用包装组件，这样vue才可以对状态变化做出反应。</p><h2 id="HTML5-History-模式"><a href="#HTML5-History-模式" class="headerlink" title="HTML5 History 模式"></a>HTML5 History 模式</h2><p><code>vue-router</code> 默认 hash 模式–使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载</p><p>如果不想要很丑的 hash，我们可以用路由的 history 模式，这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</div><div class="line">  mode: <span class="string">'history'</span>,</div><div class="line">  routes: [...]</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>不过这种模式要玩好，还需要后台配置支持。因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问时就会返回 404。</p><p>所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。</p><h3 id="后端配置例子"><a href="#后端配置例子" class="headerlink" title="后端配置例子"></a>后端配置例子</h3><p>搁置</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;vue-router 是 Vue.js 官方的路由插件，它和 Vue.js 是深度集成的，适合用于构建单页面应用。Vue 的单页面应用是基于路由和组件的，路由用于设定访问路径，并将路径和组件映射起来。传统的页面应用，是用一些超链接来实现页面切换和跳转的。在 vue-router 单页面应用中，则是路径之间的切换，也就是组件的切换。&lt;/p&gt;
    
    </summary>
    
      <category term="Learning" scheme="http://huguokang.com/categories/Learning/"/>
    
    
      <category term="Vue.js" scheme="http://huguokang.com/tags/Vue-js/"/>
    
      <category term="vue-router" scheme="http://huguokang.com/tags/vue-router/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js学习笔记9</title>
    <link href="http://huguokang.com/2017/11/22/Vue.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B09/"/>
    <id>http://huguokang.com/2017/11/22/Vue.js学习笔记9/</id>
    <published>2017-11-22T04:54:28.000Z</published>
    <updated>2017-11-26T01:22:07.821Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="状态过渡"><a href="#状态过渡" class="headerlink" title="状态过渡"></a>状态过渡</h1><p>Vue 的过渡系统提供了非常多简单的方法设置进入、离开和列表的动效。那么对于数据元素本身的动效，比如：</p><ul><li>数字和运算</li><li>颜色的显示</li><li>SVG 节点的位置</li><li>元素的大小和其他的属性</li></ul><p>所有的原始数字都被事先存储起来，可以直接转换到数字。做到这一步，我们就可以结合 Vue 的响应式和组件系统，使用第三方库来实现切换元素的过渡状态。</p><a id="more"></a><h2 id="状态动画与观察者"><a href="#状态动画与观察者" class="headerlink" title="状态动画与观察者"></a>状态动画与观察者</h2><p>通过观察者我们能监听到任何数值属性的数值更新。先看一个使用 Tweenjs 的例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/tween.js@16.3.4"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"animated-number-demo"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.number</span>=<span class="string">"number"</span> <span class="attr">type</span>=<span class="string">"number"</span> <span class="attr">step</span>=<span class="string">"20"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; animatedNumber &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  el: <span class="string">'#animated-number-demo'</span>,</div><div class="line">  data: &#123;</div><div class="line">    number: <span class="number">0</span>,</div><div class="line">    animatedNumber: <span class="number">0</span></div><div class="line">  &#125;,</div><div class="line">  watch: &#123;</div><div class="line">    number: <span class="function"><span class="keyword">function</span>(<span class="params">newValue, oldValue</span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> vm = <span class="keyword">this</span></div><div class="line">      <span class="function"><span class="keyword">function</span> <span class="title">animate</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (TWEEN.update()) &#123;</div><div class="line">          requestAnimationFrame(animate)</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">new</span> TWEEN.Tween(&#123; <span class="attr">tweeningNumber</span>: oldValue &#125;)</div><div class="line">        .easing(TWEEN.Easing.Quadratic.Out)</div><div class="line">        .to(&#123; <span class="attr">tweeningNumber</span>: newValue &#125;, <span class="number">500</span>)</div><div class="line">        .onUpdate(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">          vm.animatedNumber = <span class="keyword">this</span>.tweeningNumber.toFixed(<span class="number">0</span>)</div><div class="line">        &#125;)</div><div class="line">        .start()</div><div class="line"></div><div class="line">      animate()  </div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><h2 id="动态状态过渡"><a href="#动态状态过渡" class="headerlink" title="动态状态过渡"></a>动态状态过渡</h2><p>搁置中…</p><h2 id="把过渡放到组件里"><a href="#把过渡放到组件里" class="headerlink" title="把过渡放到组件里"></a>把过渡放到组件里</h2><p>管理太多的状态过渡会很快的增加 Vue 实例或者组件的复杂性，幸好很多的动画可以提取到专用的子组件。</p><p>我们将之前的示例改写一下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/tween.js@16.3.4"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-8"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.number</span>=<span class="string">"firstNumber"</span> <span class="attr">type</span>=<span class="string">"number"</span> <span class="attr">step</span>=<span class="string">"20"</span>&gt;</span> +</div><div class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.number</span>=<span class="string">"secondNumber"</span> <span class="attr">type</span>=<span class="string">"number"</span> <span class="attr">step</span>=<span class="string">"20"</span>&gt;</span> =</div><div class="line">  &#123;&#123; result &#125;&#125;</div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">animated-integer</span> <span class="attr">v-bind:value</span>=<span class="string">"firstNumber"</span>&gt;</span><span class="tag">&lt;/<span class="name">animated-integer</span>&gt;</span> +</div><div class="line">  <span class="tag">&lt;<span class="name">animated-integer</span> <span class="attr">v-bind:value</span>=<span class="string">"secondNumber"</span>&gt;</span><span class="tag">&lt;/<span class="name">animated-integer</span>&gt;</span> =</div><div class="line">  <span class="tag">&lt;<span class="name">animated-integer</span> <span class="attr">v-bind:value</span>=<span class="string">"result"</span>&gt;</span><span class="tag">&lt;/<span class="name">animated-integer</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这种复杂的补间动画逻辑可以被复用</span></div><div class="line"><span class="comment">// 任何整数都可以执行动画</span></div><div class="line"><span class="comment">// 组件化使我们的界面十分清晰</span></div><div class="line"><span class="comment">// 可以支持更多更复杂的动态过渡策略</span></div><div class="line">Vue.component(<span class="string">'animated-integer'</span>, &#123;</div><div class="line">  template: <span class="string">'&lt;span&gt;&#123;&#123; tweeningValue &#125;&#125;&lt;/span&gt;'</span>,</div><div class="line">  props: &#123;</div><div class="line">    value: &#123;</div><div class="line">      type: <span class="built_in">Number</span>,</div><div class="line">      required: <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      tweeningValue: <span class="number">0</span></div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  watch: &#123;</div><div class="line">    value: <span class="function"><span class="keyword">function</span> (<span class="params">newValue, oldValue</span>) </span>&#123;</div><div class="line">      <span class="keyword">this</span>.tween(oldValue, newValue)</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  mounted: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.tween(<span class="number">0</span>, <span class="keyword">this</span>.value)</div><div class="line">  &#125;,</div><div class="line">  methods: &#123;</div><div class="line">    tween: <span class="function"><span class="keyword">function</span> (<span class="params">startValue, endValue</span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> vm = <span class="keyword">this</span></div><div class="line">      <span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (TWEEN.update()) &#123;</div><div class="line">          requestAnimationFrame(animate)</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">new</span> TWEEN.Tween(&#123; <span class="attr">tweeningValue</span>: startValue &#125;)</div><div class="line">        .to(&#123; <span class="attr">tweeningValue</span>: endValue &#125;, <span class="number">500</span>)</div><div class="line">        .onUpdate(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">          vm.tweeningValue = <span class="keyword">this</span>.tweeningValue.toFixed(<span class="number">0</span>)</div><div class="line">        &#125;)</div><div class="line">        .start()</div><div class="line"></div><div class="line">      animate()</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 所有的复杂度都已经从 Vue 的主实例中移除！</span></div><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  el: <span class="string">'#example-8'</span>,</div><div class="line">  data: &#123;</div><div class="line">    firstNumber: <span class="number">20</span>,</div><div class="line">    secondNumber: <span class="number">40</span></div><div class="line">  &#125;,</div><div class="line">  computed: &#123;</div><div class="line">    result: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.firstNumber + <span class="keyword">this</span>.secondNumber</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><h1 id="混合"><a href="#混合" class="headerlink" title="混合"></a>混合</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>混合（mixins）是一种分发 Vue 组件中可复用功能的非常灵活的方式。混合对象可以包含任意组件选项。以组件使用混合对象时，所有混合对象的选项将被混入该组件本身的选项。</p><p>例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义一个混合对象</span></div><div class="line"><span class="keyword">var</span> myMixin = &#123;</div><div class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.hello()</div><div class="line">  &#125;,</div><div class="line">  methods: &#123;</div><div class="line">    hello: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'hello from mixin!'</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 定义一个使用混合对象的组件</span></div><div class="line"><span class="keyword">var</span> Component = Vue.extend(&#123;</div><div class="line">  mixins: [myMixin]</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="keyword">var</span> component = <span class="keyword">new</span> Component() <span class="comment">// =&gt; "hello from mixin!"</span></div></pre></td></tr></table></figure><h2 id="选项合并"><a href="#选项合并" class="headerlink" title="选项合并"></a>选项合并</h2><p>当组件和混合对象含有同名选项时，这些选项将以恰当的方式混合。比如，同名钩子函数将混合为一个数组，因此都将被调用。另外，混合对象的钩子将在组件自身钩子之前调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mixin = &#123;</div><div class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'混合对象的钩子被调用'</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  mixins: [mixin],</div><div class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'组件钩子被调用'</span>)</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// =&gt; "混合对象的钩子被调用"</span></div><div class="line"><span class="comment">// =&gt; "组件钩子被调用"</span></div></pre></td></tr></table></figure><p>值为对象的选项，例如 <code>methods</code> ，<code>componenets</code> 和 <code>directives</code> ，将被混合为同一个对象。两个对象键名冲突时，取组件对象的键值对。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mixin = &#123;</div><div class="line">  methods: &#123;</div><div class="line">    foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'foo'</span>)</div><div class="line">    &#125;,</div><div class="line">    conflicting: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'from mixin'</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</div><div class="line">  mixins: [mixin],</div><div class="line">  methods: &#123;</div><div class="line">    bar: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'bar'</span>)</div><div class="line">    &#125;,</div><div class="line">    conflicting: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'from self'</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">vm.foo() <span class="comment">// =&gt; "foo"</span></div><div class="line">vm.bar() <span class="comment">// =&gt; "bar"</span></div><div class="line">vm.conflicting() <span class="comment">// =&gt; "from self"</span></div></pre></td></tr></table></figure><p><strong>NOTE:</strong> <code>Vue.extend()</code> 也使用同样的策略进行合并。</p><h2 id="全局混合"><a href="#全局混合" class="headerlink" title="全局混合"></a>全局混合</h2><p>也可以全局注册混合对象。注意使用！一旦使用全局混合对象，将会影响到所有之后创建的 Vue 实例。使用恰当时，可以为自定义对象注入处理逻辑。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 为自定义的选项 'myOption' 注入一个处理器。</span></div><div class="line">Vue.mixin(&#123;</div><div class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> myOption = <span class="keyword">this</span>.$options.myOption</div><div class="line">    <span class="keyword">if</span> (myOption) &#123;</div><div class="line">      <span class="built_in">console</span>.log(myOption)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  myOption: <span class="string">'hello'</span></div><div class="line">&#125;)</div><div class="line"><span class="comment">// =&gt; "hello"</span></div></pre></td></tr></table></figure><p><strong>NOTE:</strong>谨慎使用全局混合对象，因为会影响到每个单独创建的 Vue 实例 (包括第三方模板)。大多数情况下，只应当应用于自定义选项，就像上面示例一样。也可以将其用作 Plugins 以避免产生重复应用</p><h2 id="自定义选项合并策略"><a href="#自定义选项合并策略" class="headerlink" title="自定义选项合并策略"></a>自定义选项合并策略</h2><p>自定义选项将使用默认策略，即简单地覆盖已有值。如果想让自定义选项以自定义逻辑合并，可以向 <code>Vue.config.optionMergeStrategies</code> 添加一个函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Vue.config.optionMergeStrategies.myOption = <span class="function"><span class="keyword">function</span> (<span class="params">toVal, fromVal</span>) </span>&#123;</div><div class="line">  <span class="comment">// return mergedVal</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>对于大多数对象选项，也可以使用 <code>methods</code> 地合并策略：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> strategies = Vue.config.optionMergeStragies</div><div class="line">strategies.myOption = strategies.methods</div></pre></td></tr></table></figure><h1 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>除了核心功能默认内置的指令，Vue也允许注册自定义指令。</p><p>举个聚焦输入框的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 注册一个全局自定义指令 `v-focus`</span></div><div class="line">Vue.directive(<span class="string">'focus'</span>, &#123;</div><div class="line">  <span class="comment">// 当被绑定的元素插入到 DOM 中时</span></div><div class="line">  inserted: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</div><div class="line">    el.focus()</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>如果想注册局部指令，组件中也接受一个 <code>directives</code> 的选项：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">directives: &#123;</div><div class="line">  focus: &#123;</div><div class="line">    <span class="comment">// 指令的定义</span></div><div class="line">    inserted: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</div><div class="line">      el.focus()</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>然后你可以在模板中任何元素上使用新的 <code>v-focus</code> 属性，如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-focus</span>&gt;</span></div></pre></td></tr></table></figure><h2 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h2><p>一个指令定义对象可以提供如下几个钩子函数（均为可选）：</p><ul><li><p><code>bind</code> ：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</p></li><li><p><code>inserted</code> ：被绑定元素插入父节点时调用（仅保证父节点存在，但不一定已被插入文档中）。</p></li><li><p><code>update</code> ：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新。</p></li><li><p><code>componentUpdated</code> ：指令所在组件的 VNode 及其子 VNode 全部更新后调用。</p></li><li><p><code>unbind</code> ：只调用一次，指令与元素解绑时调用。</p></li></ul><h2 id="钩子函数参数"><a href="#钩子函数参数" class="headerlink" title="钩子函数参数"></a>钩子函数参数</h2><p>指令钩子函数会被传入一下参数：</p><ul><li><code>el</code> ：指令所绑定的元素，可以用来直接操作 DOM 。</li><li><code>binding</code> ：一个对象，包括一下属性：<ul><li><code>name</code> ：指令名，不包括 <code>v-</code> 前缀。</li><li><code>value</code> ：指令的绑定值，例如：<code>v-my-directive=&quot;1 + 1&quot;</code> 中，绑定值为 <code>2</code> 。</li><li><code>oldValue</code> ：指令绑定的前一个值，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。无论值是否改变都可用。</li><li><code>expression</code> ：字符串形式的指令表达式。例如 <code>v-my-directive=&quot;1 + 1&quot;</code> 中，表达式为 <code>&quot;1 + 1&quot;</code> 。</li><li><code>arg</code> ：传给指令的参数，可选。例如 <code>v-my-directive:foo</code> 中，参数为 <code>&quot;foo&quot;</code> 。</li><li><code>modifers</code> ：一个白还修饰符的对象。例如 <code>v-my-directive.foo.bar</code> 中，修饰符对象为 <code>{ foo: true, bar: true }</code> 。</li></ul></li><li><code>vnode</code> ：Vue 编译生成的虚拟节点。</li><li><code>oldVnode</code> ：上一个虚拟节点，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。</li></ul><p><strong>NOTE:</strong>除了 <code>el</code> 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 <code>dataset</code> 来进行。</p><h2 id="函数简写"><a href="#函数简写" class="headerlink" title="函数简写"></a>函数简写</h2><p>在很多时候，你可能想在 <code>bind</code> 和 <code>update</code> 时触发相行为，而不关心其它的钩子。比如这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Vue.directive(<span class="string">'color-swatch'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">el, binding</span>) </span>&#123;</div><div class="line">  el.style.backgroundColor = binding.value</div><div class="line">&#125;)</div></pre></td></tr></table></figure><h2 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a>对象字面量</h2><p>如果指令需要多个值，可以传入 JavaScript 对象字面量。记住，指令函数能够接受所有合法的 JavaScript 表达式。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-demo</span>=<span class="string">"&#123; color: 'white', text: 'hello!' &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Vue.directive(<span class="string">'demo'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">el, binding</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(binding.value.color) <span class="comment">// =&gt; "white"</span></div><div class="line">  <span class="built_in">console</span>.log(binding.value.text) <span class="comment">// =&gt; "hello!"</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><h2 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h2><p>通过全局方法 Vue.use() 使用插件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Vue.use(MyPlugin)</div></pre></td></tr></table></figure><p>也可以传入一个选项对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Vue.use(MyPlugin, &#123; <span class="attr">someOption</span>: <span class="literal">true</span> &#125;)</div></pre></td></tr></table></figure><p><code>Vue.use</code>会自动阻止多次注册相同插件，届时只会注册一次该插件。</p><p>Vue.js 官方提供的一些插件（例如 <code>vue-router</code> ）在检测到 <code>Vue</code> 是可访问的全局变量时会自动调用 <code>Vue.use()</code> 。然而在例如 CommonJS 的模块环境中，你应该始终显式地调用 <code>Vue.use()</code> ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 用 Browserify 或 webpack 提供的  CommonJS 模块环境时</span></div><div class="line"><span class="keyword">var</span> Vue = <span class="built_in">require</span>(<span class="string">'vue'</span>)</div><div class="line"><span class="keyword">var</span> VueRouter = <span class="built_in">require</span>(<span class="string">'vue-router'</span>)</div><div class="line"></div><div class="line"><span class="comment">// 不要忘了调用此方法</span></div><div class="line">Vue.use(VueRouter)</div></pre></td></tr></table></figure><h1 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h1><p>Vue.js 允许你自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：<strong>双花括号插值和<code>v-bind</code>表达式</strong>。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符号指示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 在双括号中 --&gt;</span></div><div class="line">&#123;&#123; message | capitalize &#125;&#125;</div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 在 `v-bind` 中 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">"rawId | formatId"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p>你可以在一个组件的选项中定义本地的过滤器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">filters: &#123;</div><div class="line">  capitalize: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!value) <span class="keyword">return</span></div><div class="line">    value = value.toString()</div><div class="line">    <span class="keyword">return</span> value.charAt(<span class="number">0</span>).toUpperCase() + value.slice(<span class="number">1</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>或者全局定义过滤器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Vue.filter(<span class="string">'capitalize'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!value) <span class="keyword">return</span> <span class="string">''</span></div><div class="line">  value = value.toString()</div><div class="line">  <span class="keyword">return</span> value.charAt(<span class="number">0</span>).toUpperCase() + value.slice(<span class="number">1</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>过滤器函数总接受表达式的值（之前的操作链的结果）作为第一个参数。在上述例子中，<code>capitalize</code> 过滤器函数将会收到 <code>message</code> 的值作为第一个参数。</p><p>过滤器可以串联：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;&#123; message | filterA | filterB &#125;&#125;</div></pre></td></tr></table></figure><p>过滤器是 JavaScript 函数，因此可以接收参数：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;&#123; message | filterA('arg1', arg2) &#125;&#125;</div></pre></td></tr></table></figure><p>这里，<code>filterA</code> 被定义为接收三个参数的过滤器函数。其中 <code>message</code> 的值作为第一个参数，普通字符串 <code>arg1</code> 作为第二个参数，表达式 <code>arg2</code> 的值作为第三个参数。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;状态过渡&quot;&gt;&lt;a href=&quot;#状态过渡&quot; class=&quot;headerlink&quot; title=&quot;状态过渡&quot;&gt;&lt;/a&gt;状态过渡&lt;/h1&gt;&lt;p&gt;Vue 的过渡系统提供了非常多简单的方法设置进入、离开和列表的动效。那么对于数据元素本身的动效，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数字和运算&lt;/li&gt;
&lt;li&gt;颜色的显示&lt;/li&gt;
&lt;li&gt;SVG 节点的位置&lt;/li&gt;
&lt;li&gt;元素的大小和其他的属性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有的原始数字都被事先存储起来，可以直接转换到数字。做到这一步，我们就可以结合 Vue 的响应式和组件系统，使用第三方库来实现切换元素的过渡状态。&lt;/p&gt;
    
    </summary>
    
      <category term="Learning" scheme="http://huguokang.com/categories/Learning/"/>
    
    
      <category term="Vue.js" scheme="http://huguokang.com/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js学习笔记8</title>
    <link href="http://huguokang.com/2017/11/17/Vue.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B08/"/>
    <id>http://huguokang.com/2017/11/17/Vue.js学习笔记8/</id>
    <published>2017-11-17T01:24:19.000Z</published>
    <updated>2017-11-21T12:03:23.366Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="进入-离开-amp-列表过渡"><a href="#进入-离开-amp-列表过渡" class="headerlink" title="进入/离开 &amp; 列表过渡"></a>进入/离开 &amp; 列表过渡</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。包括以下工具：</p><ul><li>在 CSS 过渡和动画中自动应用 class</li><li>可以配合使用第三方 CSS 动画库，如 Animate.css</li><li>在过渡钩子函数中使用 JavaScript 直接操作 DOM</li><li>可以配合使用第三方 JavaScript 动画库，如 Velocity.js</li></ul><a id="more"></a><h2 id="单元素-组件的过渡"><a href="#单元素-组件的过渡" class="headerlink" title="单元素/组件的过渡"></a>单元素/组件的过渡</h2><p>Vue 提供了 <code>transition</code> 的封装组件，在下列情形中，可以给任何元素和组件添加 entering/leaving 过渡</p><ul><li>条件渲染（使用 <code>v-if</code> ）</li><li>条件展示（使用 <code>v-show</code> ）</li><li>动态组件</li><li>组件根节点</li></ul><p>例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"show = !show"</span>&gt;</span></div><div class="line">    Toggle</div><div class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">"fade"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">"show"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  el: <span class="string">'#demo'</span>,</div><div class="line">  data: &#123;</div><div class="line">    show: <span class="literal">true</span></div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.fade-enter-active</span>, <span class="selector-class">.fade-leave-active</span> &#123;</div><div class="line">  <span class="attribute">transition</span>: opacity .<span class="number">5s</span></div><div class="line">&#125;</div><div class="line"><span class="selector-class">.fade-enter</span>, <span class="selector-class">.fade-leave-to</span> <span class="comment">/* .fade-leave-active in below version 2.1.8 */</span> &#123;</div><div class="line">  <span class="attribute">opacity</span>: <span class="number">0</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当插入或删除包含在 <code>transition</code> 组件中的元素时，Vue 将会做以下处理：</p><ol><li><p>自动嗅探目标元素是否应用了 CSS 过渡或动画，如果是，在恰当的时机添加/删除 CSS 类名。</p></li><li><p>如果过渡组件提供了 JavaScript 钩子函数，这些钩子函数将在恰当的时机被调用。</p></li><li><p>如果没有找到 JavaScript 钩子并且也没有检测到 CSS 过渡/动画，DOM 操作（插入/删除）在下一帧中立即执行。（注意：此指浏览器逐帧动画机制，和 Vue 的 <code>nextTick</code> 概念不一样）</p></li></ol><h3 id="过渡的类名"><a href="#过渡的类名" class="headerlink" title="过渡的类名"></a>过渡的类名</h3><p>在进入/离开的过渡中，会有6个class切换。</p><ol><li><p><code>v-enter</code> ：定义进入过渡的开始状态。在元素被插入时生效，在下一个帧移除。</p></li><li><p><code>v-enter-active</code> : 定义过渡的状态。在元素整个过渡过程中作用，在元素被插入时生效，在 <code>transition/animation</code> 完成后移除。这个类可以被用来定义过渡的过程时间，延迟和曲线函数。</p></li><li><p><code>v-enter-to</code> ：2.1.8版以上定义进入过渡的结束状态。在元素被插入一帧后生效（于此同时 <code>v-enter</code> 被删除），在 <code>transition/animation</code> 完成之后移除。</p></li><li><p><code>v-leave</code> : 定义离开过渡的开始状态。在离开过渡被触发时生效，在下一个帧移除。</p></li><li><p><code>v-leave-active</code> ：定义过渡的状态。在元素整个过程中作用，在离开过渡被触发后立即生效，在 <code>transition/animation</code> 完成之后移除。这个类可以被用来定义过渡的过程时间，延迟和曲线函数。</p></li><li><p><code>v-leave-to</code> ：2.1.8版及以上定义离开过渡的结束状态。在离开过渡被触发一帧后生效（于此同时 <code>v-leave</code> 被删除），在 <code>transition/animation</code> 完成之后移除。</p></li></ol><p>对于这些在 <code>enter/leave</code> 过渡中切换的类名，<code>v-</code> 是这些类名的前缀。使用 <code>&lt;transition name=&quot;my-transition&quot;&gt;</code> 可以重置前缀，比如 <code>v-enter</code> 替换为 <code>my-transition-enter</code>。</p><h3 id="CSS-过渡"><a href="#CSS-过渡" class="headerlink" title="CSS 过渡"></a>CSS 过渡</h3><p>常用的过渡都是使用 CSS 过渡。</p><p>下面是一个例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-1"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"show = !show"</span>&gt;</span></div><div class="line">    Toggle render</div><div class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">"slide-fade"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">"show"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  el: <span class="string">'#example-1'</span></div><div class="line">  data: &#123;</div><div class="line">    show: <span class="literal">true</span></div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 可以设置不同的进入和离开动画 */</span></div><div class="line"><span class="comment">/* 设置持续时间和动画函数 */</span></div><div class="line"><span class="selector-class">.slide-fade-enter-active</span> &#123;</div><div class="line">  <span class="attribute">transition</span>: all .<span class="number">3s</span> ease;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.slide-fade-leave-active</span> &#123;</div><div class="line">  <span class="attribute">transition</span>: all .<span class="number">8s</span> <span class="built_in">cubic-bezier</span>(1.0, 0.5, 0.8, 1.0);</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.slide-fade-enter</span>, <span class="selector-class">.slide-fade-leave-to</span></div><div class="line"><span class="comment">/* .slide-fade-leave-active for below version 2.1.8 */</span> &#123;</div><div class="line">  <span class="attribute">transform</span>: <span class="built_in">translateX</span>(10px);</div><div class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="CSS-动画"><a href="#CSS-动画" class="headerlink" title="CSS 动画"></a>CSS 动画</h3><p>CSS 动画用法同 CSS 过渡区别是在动画中 <code>v-enter</code> 类名在节点插入 DOM 后不会立即删除，而是在 <code>animationend</code> 事件触发时删除。</p><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-2"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"show = !show"</span>&gt;</span>Toggle show<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">"bounce"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">"show"</span>&gt;</span>Look at me!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  el: <span class="string">'#example-2'</span>,</div><div class="line">  data: &#123;</div><div class="line">    show: <span class="literal">true</span></div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.bounce-enter-active</span> &#123;</div><div class="line">  <span class="attribute">animation</span>: bounce-in .<span class="number">5s</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.bounce-leave-active</span> &#123;</div><div class="line">  <span class="attribute">animation</span>: bounce-in .<span class="number">5s</span> reverse;</div><div class="line">&#125;</div><div class="line">@<span class="keyword">keyframes</span> bounce-in &#123;</div><div class="line">  0% &#123;</div><div class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(0);</div><div class="line">  &#125;</div><div class="line">  50% &#123;</div><div class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(1.5);</div><div class="line">  &#125;</div><div class="line">  100% &#123;</div><div class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(1);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="自定义过渡的类名"><a href="#自定义过渡的类名" class="headerlink" title="自定义过渡的类名"></a>自定义过渡的类名</h3><p>我们可以通过以下特性来自定义过渡类名：</p><ul><li><code>enter-class</code></li><li><code>enter-active-class</code></li><li><code>enter-to-class</code> (2.1.8+)</li><li><code>leave-class</code></li><li><code>leave-active-class</code></li><li><code>leave-to-class</code> (2.1.8+)</li></ul><p>它们的优先级高于普通的类名，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如 Animate.css 结合使用十分有用。</p><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"https://cdn.jsdelivr.net/npm/animate.css@3.5.1"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-3"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"show = !show"</span>&gt;</span></div><div class="line">    Toggle render</div><div class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">transition</span></span></div><div class="line"><span class="tag">    <span class="attr">name</span>=<span class="string">"custom-classes-transition"</span></span></div><div class="line"><span class="tag">    <span class="attr">enter-active-class</span>=<span class="string">"animated tada"</span></span></div><div class="line"><span class="tag">    <span class="attr">leave-active-class</span>=<span class="string">"animated bounceOutRight"</span></span></div><div class="line"><span class="tag">  &gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">"show"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  el: <span class="string">'#example-3'</span>,</div><div class="line">  data: &#123;</div><div class="line">    show: <span class="literal">true</span></div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><h3 id="同时使用过渡和动画"><a href="#同时使用过渡和动画" class="headerlink" title="同时使用过渡和动画"></a>同时使用过渡和动画</h3><p>Vue 为了知道过渡的完成，必须设置相应的事件监听器。它可以是 <code>transitionend</code> 或 <code>animationend</code> ，这取决于给元素应用的 CSS 规则。如果你使用其中任何一种，Vue 能自动识别类型并设置监听。</p><p>但是，在一些场景中，你需要给同一个元素同时设置两种过渡动效，比如 <code>animation</code> 很快的被触发并完成了，而 <code>transition</code> 效果还没结束。在这种情况中，你就需要使用 <code>type</code> 特性并设置 <code>animation</code> 或 <code>transition</code> 来明确声明你需要 Vue 监听的类型。</p><h3 id="显性的过渡持续时间"><a href="#显性的过渡持续时间" class="headerlink" title="显性的过渡持续时间"></a>显性的过渡持续时间</h3><p>在很多情况下，Vue 可以自动得出过渡效果的完成时机。默认情况下，Vue 会等待其在过渡效果的根元素的第一个 <code>transitionend</code> 或 <code>animationend</code> 事件。然而也可以不这样设定–比如，我们可以拥有一个精心编排的一序列过渡效果，其中一些嵌套的内部元素相比于过渡效果的根元素有延迟的或更长的过渡效果。</p><p>在这种情况下你可以用 <code>&lt;transition&gt;</code> 组件上的 <code>duration</code> 属性定制一个显性的过渡持续时间（以毫秒计）：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">:duration</span>=<span class="string">"1000"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">transition</span>&gt;</span></div></pre></td></tr></table></figure><p>你也可以定制进入和移出的持续时间：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">:duration</span>=<span class="string">"&#123; enter: 500, leave: 800 &#125;"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">transition</span>&gt;</span></div></pre></td></tr></table></figure><h3 id="JavaScript-钩子"><a href="#JavaScript-钩子" class="headerlink" title="JavaScript 钩子"></a>JavaScript 钩子</h3><p>可以在属性中声明 JavaScript 钩子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">transition</span></span></div><div class="line"><span class="tag">  <span class="attr">v-on:before-enter</span>=<span class="string">"beforeEnter"</span></span></div><div class="line"><span class="tag">  <span class="attr">v-on:enter</span>=<span class="string">"enter"</span></span></div><div class="line"><span class="tag">  <span class="attr">v-on:after-enter</span>=<span class="string">"afterEnter"</span></span></div><div class="line"><span class="tag">  <span class="attr">v-on:enter-cancelled</span>=<span class="string">"enterCancelled"</span></span></div><div class="line"><span class="tag">  </span></div><div class="line"><span class="tag">  <span class="attr">v-on:before-leave</span>=<span class="string">"beforeLeave"</span></span></div><div class="line"><span class="tag">  <span class="attr">v-on:leave</span>=<span class="string">"leave"</span></span></div><div class="line"><span class="tag">  <span class="attr">v-on:after-leave</span>=<span class="string">"afterLeave"</span></span></div><div class="line"><span class="tag">  <span class="attr">v-on:leave-cancelled</span>=<span class="string">"leaveCancelled"</span></span></div><div class="line"><span class="tag">&gt;</span></div><div class="line">  <span class="comment">&lt;!-- ... --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ...</span></div><div class="line">methods: &#123;</div><div class="line">  <span class="comment">// ------</span></div><div class="line">  <span class="comment">// 进入中</span></div><div class="line">  <span class="comment">// ------</span></div><div class="line"></div><div class="line">  beforeEnter: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// 此回调函数是可选项的设置</span></div><div class="line">  <span class="comment">// 与 CSS 结合时使用</span></div><div class="line">  enter: <span class="function"><span class="keyword">function</span> (<span class="params">el, done</span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    done()</div><div class="line">  &#125;,</div><div class="line">  afterEnter: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  enterCancelled: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  <span class="comment">// ------</span></div><div class="line">  <span class="comment">// 离开时</span></div><div class="line">  <span class="comment">// ------</span></div><div class="line"></div><div class="line">  beforeLeave: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// 此回调函数是可选项的设置</span></div><div class="line">  <span class="comment">// 与 CSS 结合时使用</span></div><div class="line">  leave: <span class="function"><span class="keyword">function</span> (<span class="params">el,done</span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    done()</div><div class="line">  &#125;,</div><div class="line">  afterLeave: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// leaveCancelled 只用于 v-show 中</span></div><div class="line">  leaveCancelled: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这些钩子函数既可以结合 CSS <code>transitions/animations</code> 使用，也可以单独使用。</p><p><strong>NOTE:</strong>当只用 JavaScript 过渡的时候，在 <code>enter</code> 和 <code>leave</code> 中，回调函数 <code>done</code> 是必须的。否则，它们会被同步调用，过渡会立即完成。</p><p><strong>NOTE:</strong>推荐对于仅使用 JavaScript 过渡的元素添加 <code>v-bind:css=&quot;fasle&quot;</code> ，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响。</p><p>一个使用 Velocity.js 的简单例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--</span></div><div class="line"><span class="comment">Velocity works very much like jQuery.animate and is</span></div><div class="line"><span class="comment">a great option for JavaScript animations</span></div><div class="line"><span class="comment">--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-4"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"show = !show"</span>&gt;</span></div><div class="line">    Toggle</div><div class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">transition</span></span></div><div class="line"><span class="tag">    <span class="attr">v-on:before-enter</span>=<span class="string">"beforeEnter"</span></span></div><div class="line"><span class="tag">    <span class="attr">v-on:enter</span>=<span class="string">"enter"</span></span></div><div class="line"><span class="tag">    <span class="attr">v-on:leave</span>=<span class="string">"leave"</span></span></div><div class="line"><span class="tag">    <span class="attr">v-bind:css</span>=<span class="string">"false"</span></span></div><div class="line"><span class="tag">  &gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">"show"</span>&gt;</span></div><div class="line">      Demo</div><div class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  el: <span class="string">'#example-4'</span>,</div><div class="line">  data: &#123;</div><div class="line">    show: <span class="literal">false</span></div><div class="line">  &#125;,</div><div class="line">  methods: &#123;</div><div class="line">    beforeEnter: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</div><div class="line">      el.style.opacity = <span class="number">0</span></div><div class="line">      el.style.transformOrigin = <span class="string">'left'</span></div><div class="line">    &#125;,</div><div class="line">    enter: <span class="function"><span class="keyword">function</span> (<span class="params">el, done</span>) </span>&#123;</div><div class="line">      Velocity(el, &#123; <span class="attr">opacity</span>: <span class="number">1</span>, <span class="attr">fontSize</span>: <span class="string">'1.4em'</span> &#125;, &#123; <span class="attr">duration</span>: <span class="number">300</span> &#125;)</div><div class="line">      Velocity(el, &#123; <span class="attr">fontsize</span>: <span class="string">'1em'</span> &#125;, &#123; <span class="attr">complete</span>: done &#125;)</div><div class="line">    &#125;,</div><div class="line">    leave: <span class="function"><span class="keyword">function</span> (<span class="params">el, done</span>) </span>&#123;</div><div class="line">      Velocity(el, &#123; <span class="attr">translateX</span>: <span class="string">'15px'</span>, <span class="attr">rotateZ</span>: <span class="string">'50deg'</span> &#125;, &#123; <span class="attr">duration</span>: <span class="number">600</span> &#125;)</div><div class="line">      Velocity(el, &#123; <span class="attr">rotateZ</span>: <span class="string">'100deg'</span> &#125;, &#123; <span class="attr">loop</span>: <span class="number">2</span> &#125;)</div><div class="line">      Velocity(el, &#123;</div><div class="line">        rotateZ: <span class="string">'45deg'</span>,</div><div class="line">        translateY: <span class="string">'30px'</span>,</div><div class="line">        translateX: <span class="string">'30px'</span>,</div><div class="line">        opacity: <span class="number">0</span></div><div class="line">      &#125;, &#123; <span class="attr">complete</span>: done &#125;)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><h2 id="初始渲染的过渡"><a href="#初始渲染的过渡" class="headerlink" title="初始渲染的过渡"></a>初始渲染的过渡</h2><p>可以通过 <code>appear</code> 特性设置节点的初始渲染的过渡</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">appear</span>&gt;</span></div><div class="line">  <span class="comment">&lt;!-- ... --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></div></pre></td></tr></table></figure><p>这里默认和进入和离开过渡一样，同样也可以自定义 CSS 类名。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">transition</span>&gt;</span></div><div class="line">  appear</div><div class="line">  appear-class="custom-appear-class"</div><div class="line">  appear-to-class="custom-appear-to-class" (2.1.8+)</div><div class="line">  appear-active-class="custom-appear-active-class"</div><div class="line">&gt;</div><div class="line">  <span class="comment">&lt;!-- ... --&gt;</span></div></pre></td></tr></table></figure><p>自定义 JavaScript 钩子：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">transition</span></span></div><div class="line"><span class="tag">  <span class="attr">appear</span></span></div><div class="line"><span class="tag">  <span class="attr">v-on:before-appear</span>=<span class="string">"customBeforeAppearHook"</span></span></div><div class="line"><span class="tag">  <span class="attr">v-on:appear</span>=<span class="string">"customAppearHook"</span></span></div><div class="line"><span class="tag">  <span class="attr">v-on:after-appear</span>=<span class="string">"customAfterAppearHook"</span></span></div><div class="line"><span class="tag">  <span class="attr">v-on:appear-cancelled</span>=<span class="string">"customAppearCancelledHook"</span></span></div><div class="line"><span class="tag">&gt;</span></div><div class="line">  <span class="comment">&lt;!-- ... --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></div></pre></td></tr></table></figure></p><h2 id="多个元素的过渡"><a href="#多个元素的过渡" class="headerlink" title="多个元素的过渡"></a>多个元素的过渡</h2><p>对于原生标签可以使用 <code>v-if / v-else</code> 。最常见的多标签过渡是一个列表和描述这个列表为空消息的元素：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">transition</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">table</span> <span class="attr">v-if</span>=<span class="string">"items.length &gt; 0"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- ... --&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">table</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-else</span>&gt;</span>Sorry, no items found.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">tansition</span>&gt;</span></div></pre></td></tr></table></figure><p><strong>NOTE:</strong>当有相同标签名的元素切换时，需要通过 <code>key</code> 特性设置唯一的值来标记让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。即使在技术上没有必要，给在 <code>&lt;tansition&gt;</code> 组件中的多个元素设置 key 是一个更好的实践。</p><p>示例：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">transition</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-if</span>=<span class="string">"isEditing"</span> <span class="attr">key</span>=<span class="string">"save"</span>&gt;</span></div><div class="line">    Save</div><div class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-else</span> <span class="attr">key</span>=<span class="string">"edit"</span>&gt;</span></div><div class="line">    Edit</div><div class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></div></pre></td></tr></table></figure></p><p>在一些场景中，也可以通过给同一个元素的 <code>key</code> 特性设置不同的状态来代替 <code>v-if</code> 和 <code>v-else</code> ，上面的例子可以重写为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">transition</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-bind:key</span>=<span class="string">"isEditing"</span>&gt;</span></div><div class="line">    &#123;&#123; isEditing ? 'Save' : 'Edit' &#125;&#125;</div><div class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></div></pre></td></tr></table></figure><p>使用多个 <code>v-if</code> 的多个元素的过渡可以重写为绑定了动态属性的单个元素过渡。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">transition</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-if</span>=<span class="string">"docState === 'saved'"</span> <span class="attr">key</span>=<span class="string">"saved"</span>&gt;</span></div><div class="line">    Edit</div><div class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-if</span>=<span class="string">"docState === 'edited'"</span> <span class="attr">key</span>=<span class="string">"edited"</span>&gt;</span></div><div class="line">    Save</div><div class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-if</span>=<span class="string">"docState === 'editing'"</span> <span class="attr">key</span>=<span class="string">"editing"</span>&gt;</span></div><div class="line">    Cancel</div><div class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></div></pre></td></tr></table></figure><p>可以重写为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">transition</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-bind:key</span>=<span class="string">"docState"</span>&gt;</span></div><div class="line">    &#123;&#123; buttonMessage &#125;&#125;</div><div class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">transiton</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ...</span></div><div class="line">computed: &#123;</div><div class="line">  buttonMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">switch</span> (<span class="keyword">this</span>.docState) &#123;</div><div class="line">      <span class="keyword">case</span> <span class="string">'saved'</span>: <span class="keyword">return</span> <span class="string">'Edit'</span></div><div class="line">      <span class="keyword">case</span> <span class="string">'edited'</span>: <span class="keyword">return</span> <span class="string">'Save'</span></div><div class="line">      <span class="keyword">case</span> <span class="string">'editing'</span>: <span class="keyword">return</span> <span class="string">'Cancel'</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="过渡模式"><a href="#过渡模式" class="headerlink" title="过渡模式"></a>过渡模式</h3><p>由于 <code>&lt;transition&gt;</code> 的默认行为-进入过渡和离开过渡同时发生-不能满足所以要求，所以 Vue 提供了过渡模式。</p><ul><li><code>in-out</code> ：新元素先进行过渡，完成之后当前元素过渡离开。</li><li><code>out-in</code> ：当前元素先进行过渡，完成之后新元素过渡进入。</li></ul><p>用 <code>out-in</code> 重写之前的开关按钮过渡：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">"fade"</span> <span class="attr">mode</span>=<span class="string">"out-in"</span>&gt;</span></div><div class="line">  <span class="comment">&lt;!-- ... the buttons ... --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></div></pre></td></tr></table></figure><h2 id="多个组件的过渡"><a href="#多个组件的过渡" class="headerlink" title="多个组件的过渡"></a>多个组件的过渡</h2><p>多个组件的过渡简单很多–我们不需要使用 <code>key</code> 特性。相反，我们只需要使用动态组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">"component-fade"</span> <span class="attr">mode</span>=<span class="string">"out-in"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">"view"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  el: <span class="string">'#transition-components-demo'</span>,</div><div class="line">  data: &#123;</div><div class="line">    view: <span class="string">'v-a'</span></div><div class="line">  &#125;,</div><div class="line">  components: &#123;</div><div class="line">    <span class="string">'v-a'</span>: &#123;</div><div class="line">      template: <span class="string">'&lt;div&gt;Component A&lt;/div&gt;'</span></div><div class="line">    &#125;,</div><div class="line">    <span class="string">'v-b'</span>: &#123;</div><div class="line">      template: <span class="string">'&lt;div&gt;Component B&lt;/div&gt;'</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.component-fade-enter-active</span>, <span class="selector-class">.component-fade-leave-active</span> &#123;</div><div class="line">  <span class="attribute">transition</span>: opacity .<span class="number">3s</span> ease;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.component-fade-enter</span>, <span class="selector-class">.component-fade-leave-to</span> &#123;</div><div class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="列表过渡"><a href="#列表过渡" class="headerlink" title="列表过渡"></a>列表过渡</h2><p><code>&lt;transition-group&gt;</code> 的几个特点：</p><ul><li>不同于 <code>&lt;transition&gt;</code> ，它会以一个真实元素呈现：默认为一个 <code>&lt;span&gt;</code> 。你也可以通过 <code>tag</code> 特性更换为其他元素。</li><li>内部元素总是需要提供唯一的 <code>key</code> 属性值。</li></ul><h3 id="列表的进入-离开过渡"><a href="#列表的进入-离开过渡" class="headerlink" title="列表的进入/离开过渡"></a>列表的进入/离开过渡</h3><p>由一个简单的例子深入，进入和离开的过渡使用之前一样的 CSS 类名。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"list-demo"</span> <span class="attr">class</span>=<span class="string">"demo"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"add"</span>&gt;</span>Add<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">""</span><span class="attr">remove</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">transition-group</span> <span class="attr">name</span>=<span class="string">"list"</span> <span class="attr">tag</span>=<span class="string">"p"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span> <span class="attr">v-bind:key</span>=<span class="string">"item"</span> <span class="attr">class</span>=<span class="string">"list-item"</span>&gt;</span></div><div class="line">      &#123;&#123; item &#125;&#125;</div><div class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">transition-group</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  el: <span class="string">'#list-demo'</span>,</div><div class="line">  data: &#123;</div><div class="line">    items: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>],</div><div class="line">    nextNum: <span class="number">10</span></div><div class="line">  &#125;,</div><div class="line">  methods: &#123;</div><div class="line">    randomIndex: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="keyword">this</span>.items.length) <span class="comment">// Math.random()取0~1之间的随机数</span></div><div class="line">    &#125;,</div><div class="line">    add: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">this</span>.items.splice(<span class="keyword">this</span>.randomIndex(), <span class="number">0</span>, <span class="keyword">this</span>.nestNum++)</div><div class="line">    &#125;,</div><div class="line">    remove: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">this</span>.items.splice(<span class="keyword">this</span>.randomIndex(), <span class="number">1</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.list-item</span> &#123;</div><div class="line">  <span class="attribute">display</span>: inline-block;</div><div class="line">  <span class="attribute">margin-right</span>: <span class="number">10px</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.list-enter-active</span>, <span class="selector-class">.list-leave-active</span> &#123;</div><div class="line">  <span class="attribute">transition</span>: all <span class="number">1s</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.list-enter</span>, <span class="selector-class">.list-leave-to</span> &#123;</div><div class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">transform</span>: <span class="built_in">translateY</span>(30px);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个例子有个问题，当添加和移除元素的时候，周围的元素会瞬间移动到他们的新布局的位置，而不是平滑的过渡，我们下面会解决这个问题。</p><h3 id="列表的排序过渡"><a href="#列表的排序过渡" class="headerlink" title="列表的排序过渡"></a>列表的排序过渡</h3><p><code>&lt;transition-group&gt;</code> 组件还有一个特殊之处。不仅可以进入和离开动画，还可以改变定位。要使用这个新功能只需要了解新增的 <code>v-move</code> 特性，它会在元素的改变定位的过程中应用。像之前的类名一样，可以用过 <code>name</code>属性自定义前缀，也可以通过 <code>move-class</code> 属性手动设置。</p><p><code>v-move</code> 对于设置过渡的切换时机和过渡曲线非常有用，例子如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"flip-list-demo"</span> <span class="attr">class</span>=<span class="string">"demo"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"shuffle"</span>&gt;</span>Shuffle<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">transition-group</span> <span class="attr">name</span>=<span class="string">"flip-list"</span> <span class="attr">tag</span>=<span class="string">"ul"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span> <span class="attr">v-bind:key</span>=<span class="string">"item"</span>&gt;</span></div><div class="line">      &#123;&#123; item &#125;&#125;</div><div class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">transition-group</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  el: <span class="string">'#flip-list-demo'</span>,</div><div class="line">  data: &#123;</div><div class="line">    items: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</div><div class="line">  &#125;,</div><div class="line">  methods: &#123;</div><div class="line">    shuffle: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">this</span>.items= _.shuffle(<span class="keyword">this</span>.items)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.flip-list-move</span> &#123;</div><div class="line">  <span class="attribute">transition</span>: transform <span class="number">1s</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>内部的实现，Vue 使用了一个叫 FLIP 简单的动画队列使用 transforms 将元素从之前的位置平滑过渡新的位置。</p><p>我们将之前的例子和这个技术结合，使我们列表的一切变动都会有动画过渡。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"list-complete-demo"</span> <span class="attr">class</span>=<span class="string">"demo"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"shuffle"</span>&gt;</span>Shuffle<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"add"</span>&gt;</span>Add<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"Remove"</span>&gt;</span>Remove<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">transition-group</span> <span class="attr">name</span>=<span class="string">"list-complete"</span> <span class="attr">tag</span>=<span class="string">"p"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">span</span></span></div><div class="line"><span class="tag">      <span class="attr">v-for</span>=<span class="string">"item in items"</span></span></div><div class="line"><span class="tag">      <span class="attr">v-bing:key</span>=<span class="string">"item"</span></span></div><div class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"list-complete-item"</span></span></div><div class="line"><span class="tag">    &gt;</span></div><div class="line">      &#123;&#123; item &#125;&#125;</div><div class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">transition-group</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  el: <span class="string">'#list-compplete-demo'</span>,</div><div class="line">  data: &#123;</div><div class="line">    items: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>],</div><div class="line">    nextNum: <span class="number">10</span></div><div class="line">  &#125;,</div><div class="line">  methods: &#123;</div><div class="line">    randomIndex: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="keyword">this</span>.items.length)</div><div class="line">    &#125;,</div><div class="line">    add: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">this</span>.items.splice(<span class="keyword">this</span>.randomIndex, <span class="number">0</span>, <span class="keyword">this</span>.nextNum++)</div><div class="line">    &#125;,</div><div class="line">    remove: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">this</span>.items.splice(<span class="keyword">this</span>.randomIndex(), <span class="number">1</span>)</div><div class="line">    &#125;,</div><div class="line">    shuffle: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">this</span>.items = _.shuffle(<span class="keyword">this</span>.items)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.list-complete-item</span> &#123;</div><div class="line">  <span class="attribute">transition</span>: all <span class="number">1s</span>;</div><div class="line">  <span class="attribute">display</span>: inline-block;</div><div class="line">  <span class="attribute">margin-right</span>: <span class="number">10px</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.list-complete-enter</span>, <span class="selector-class">.list-complete-leave-to</span> &#123;</div><div class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;  <span class="comment">/* 规定不透明度。从 0.0 （完全透明）到 1.0（完全不透明）。*/</span></div><div class="line">  <span class="attribute">transform</span>: <span class="built_in">translateY</span>(30px)</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.list-complete-leave-active</span> &#123;</div><div class="line">  <span class="attribute">postion</span>: absolute;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="列表的交错过渡"><a href="#列表的交错过渡" class="headerlink" title="列表的交错过渡"></a>列表的交错过渡</h3><p>通过 data 属性与 JavaScript 通信，就可以实现列表的交错过渡：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"staggered-list-demo"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"query"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">transition-group</span></span></div><div class="line"><span class="tag">    <span class="attr">name</span>=<span class="string">"staggered-fade"</span></span></div><div class="line"><span class="tag">    <span class="attr">tag</span>=<span class="string">"ul"</span></span></div><div class="line"><span class="tag">    <span class="attr">v-bind:css</span>=<span class="string">"false"</span></span></div><div class="line"><span class="tag">    <span class="attr">v-on:before-enter</span>=<span class="string">"beforeEnter"</span></span></div><div class="line"><span class="tag">    <span class="attr">v-on:enter</span>=<span class="string">"enter"</span></span></div><div class="line"><span class="tag">    <span class="attr">v-on:leave</span>=<span class="string">"leave"</span></span></div><div class="line"><span class="tag">  &gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span></span></div><div class="line"><span class="tag">      <span class="attr">v-for</span>=<span class="string">"(item, index) in computedList"</span></span></div><div class="line"><span class="tag">      <span class="attr">v-bind:key</span>=<span class="string">"item.msg"</span></span></div><div class="line"><span class="tag">      <span class="attr">v-bind:data-index</span>=<span class="string">"index"</span></span></div><div class="line"><span class="tag">    &gt;</span>&#123;&#123; item.msg &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">transition-group</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  el: <span class="string">'#staggered-list-demo'</span>,</div><div class="line">  data: &#123;</div><div class="line">    query: <span class="string">''</span>,</div><div class="line">    list: [</div><div class="line">      &#123; <span class="attr">msg</span>: <span class="string">'Bruce Lee'</span> &#125;,</div><div class="line">      &#123; <span class="attr">msg</span>: <span class="string">'Jackie Chan'</span> &#125;,</div><div class="line">      &#123; <span class="attr">msg</span>: <span class="string">'Chuck Norris'</span> &#125;,</div><div class="line">      &#123; <span class="attr">msg</span>: <span class="string">'Jet Li'</span> &#125;,</div><div class="line">      &#123; <span class="attr">msg</span>: <span class="string">'Kung Fury'</span> &#125;</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  computed: &#123;</div><div class="line">    computedList: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> vm = <span class="keyword">this</span></div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.list.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> items.msg.toLowerCase().indexOf(vm.query.toLowerCase()) !== <span class="number">-1</span></div><div class="line">      &#125;)</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  methods: &#123;</div><div class="line">    beforeEnter: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</div><div class="line">      el.style.opacity = <span class="number">0</span></div><div class="line">      el.style.height = <span class="number">0</span></div><div class="line">    &#125;,</div><div class="line">    enter: <span class="function"><span class="keyword">function</span> (<span class="params">el, done</span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> delay = el.dataset.index * <span class="number">150</span></div><div class="line">      setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        Velocity(</div><div class="line">          el,</div><div class="line">          &#123; <span class="attr">opacity</span>: <span class="number">0</span>, <span class="attr">height</span>: <span class="number">0</span> &#125;,</div><div class="line">          &#123; <span class="attr">complete</span>: done &#125;</div><div class="line">        )</div><div class="line">      &#125;, delay)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><h2 id="可复用的过渡"><a href="#可复用的过渡" class="headerlink" title="可复用的过渡"></a>可复用的过渡</h2><p>过渡可以通过 Vue 的组件系统实现复用。要创建一个可复用过渡组件，你需要做的就是将 <code>&lt;transition&gt;</code> 或者 <code>&lt;transition-group&gt;</code> 作为根组件，然后将任何子组件放置在其中就可以了。</p><p>使用 template 的简单例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'my-special-transition'</span>, &#123;</div><div class="line">  template: <span class="string">'\</span></div><div class="line"><span class="string">    &lt;transition\</span></div><div class="line"><span class="string">      name="very-special-transition"\</span></div><div class="line"><span class="string">      mode="out-in"\</span></div><div class="line"><span class="string">      v-on:before-enter="beforeEnter"\</span></div><div class="line"><span class="string">      v-on:after-enter="afterEnter"\</span></div><div class="line"><span class="string">    &gt;\</span></div><div class="line"><span class="string">      &lt;slot&gt;&lt;/slot&gt;\</span></div><div class="line"><span class="string">    &lt;/transition&gt;\</span></div><div class="line"><span class="string">  '</span>,</div><div class="line">  methods: &#123;</div><div class="line">    beforeEnter: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</div><div class="line">      <span class="comment">// ...</span></div><div class="line">    &#125;,</div><div class="line">    afterEnter: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</div><div class="line">      <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>函数组件更适合完成这个任务：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'my-special-transition'</span>, &#123;</div><div class="line">  functional: <span class="literal">true</span>,</div><div class="line">  render: <span class="function"><span class="keyword">function</span> (<span class="params">createElement, context</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> data = &#123;</div><div class="line">      props: &#123;</div><div class="line">        name: <span class="string">'very-special-transition'</span>,</div><div class="line">        mode: <span class="string">'out-in'</span></div><div class="line">      &#125;,</div><div class="line">      on: &#123;</div><div class="line">        beforeEnter: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</div><div class="line">          <span class="comment">// ...</span></div><div class="line">        &#125;,</div><div class="line">        afterEnter: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</div><div class="line">          <span class="comment">// ...</span></div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> createElement(<span class="string">'transition'</span>, data, context.children)</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><h2 id="动态过渡"><a href="#动态过渡" class="headerlink" title="动态过渡"></a>动态过渡</h2><p>在 Vue 中即使是过渡也是数据驱动的，动态过渡最基本的例子是通过 <code>name</code> 特性来绑定动态值。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">v-bind:name</span>=<span class="string">"transitionName"</span>&gt;</span></div><div class="line">  <span class="comment">&lt;!-- ... --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></div></pre></td></tr></table></figure><p>当你想用 Vue 的过渡系统来定义的 CSS 过渡/动画 在不同过渡间切换会非常有用。</p><p>所有的过渡特性都是动态绑定。它不仅是简单的特性，通过事件的钩子函数方法，可以在获取到相应上下文数据。这意味着，可以根据组件的状态通过 JavaScript 过渡设置不同的过渡效果。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">div</span>  <span class="attr">id</span>=<span class="string">"dynamic-fade-demo"</span> <span class="attr">class</span>=<span class="string">"demo"</span>&gt;</span></div><div class="line">  Fade In: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"range"</span> <span class="attr">v-model</span>=<span class="string">"fadeInDuraation"</span> <span class="attr">min</span>=<span class="string">"0"</span> <span class="attr">v-bind:max</span>=<span class="string">"maxFadeDuration"</span>&gt;</span></div><div class="line">  Fade Out: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"range"</span> <span class="attr">v-model</span>=<span class="string">"fadeOutDuration"</span> <span class="attr">min</span>=<span class="string">"0"</span> <span class="attr">v-bind:max</span>=<span class="string">"maxFadeDuration"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">transition</span></span></div><div class="line"><span class="tag">    <span class="attr">v-bind:css</span>=<span class="string">"fasle"</span></span></div><div class="line"><span class="tag">    <span class="attr">v-on:before-enter</span>=<span class="string">"beforeEnter"</span></span></div><div class="line"><span class="tag">    <span class="attr">v-on:enter</span>=<span class="string">"enter"</span></span></div><div class="line"><span class="tag">    <span class="attr">v-on:leave</span>=<span class="string">"leave"</span></span></div><div class="line"><span class="tag">  &gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">"show"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">button</span></span></div><div class="line"><span class="tag">    <span class="attr">v-if</span>=<span class="string">"stop"</span></span></div><div class="line"><span class="tag">    <span class="attr">v-on:click</span>=<span class="string">"stop = false; show = false"</span></span></div><div class="line"><span class="tag">  &gt;</span>Start animating<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">button</span></span></div><div class="line"><span class="tag">    <span class="attr">v-else</span></span></div><div class="line"><span class="tag">    <span class="attr">v-on:click</span>=<span class="string">"stop = true"</span></span></div><div class="line"><span class="tag">  &gt;</span>Stop it!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  el: <span class="string">'#dynamic-fade-demo'</span>,</div><div class="line">  data: &#123;</div><div class="line">    show: <span class="literal">true</span>,</div><div class="line">    fadeInDuration: <span class="number">1000</span>,</div><div class="line">    fadeOutDuration: <span class="number">1000</span>,</div><div class="line">    maxFadeDuration: <span class="number">1500</span>,</div><div class="line">    stop: <span class="literal">true</span></div><div class="line">  &#125;,</div><div class="line">  mounted: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.show = <span class="literal">false</span></div><div class="line">  &#125;,</div><div class="line">  methods: &#123;</div><div class="line">    beforeEnter: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</div><div class="line">      el.style.opacity = <span class="number">0</span></div><div class="line">    &#125;,</div><div class="line">    enter: <span class="function"><span class="keyword">function</span> (<span class="params">el, done</span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> vm = <span class="keyword">this</span></div><div class="line">      Velocity(el,</div><div class="line">        &#123; <span class="attr">opacity</span>: <span class="number">1</span> &#125;,</div><div class="line">        &#123;</div><div class="line">          duration: <span class="keyword">this</span>.fadeInDuration,</div><div class="line">          complete: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            done()</div><div class="line">            <span class="keyword">if</span> (!vm.stop) vm.show = <span class="literal">false</span></div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      )</div><div class="line">    &#125;,</div><div class="line">    leave: <span class="function"><span class="keyword">function</span> (<span class="params">el, done</span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> vm = <span class="keyword">this</span></div><div class="line">      Velocity(el,</div><div class="line">        &#123; <span class="attr">opacity</span>: <span class="number">0</span> &#125;,</div><div class="line">        &#123;</div><div class="line">          duration: <span class="keyword">this</span>.fadeOutDuration,</div><div class="line">          complete: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            done()</div><div class="line">            vm.show = <span class="literal">true</span></div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      )</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;进入-离开-amp-列表过渡&quot;&gt;&lt;a href=&quot;#进入-离开-amp-列表过渡&quot; class=&quot;headerlink&quot; title=&quot;进入/离开 &amp;amp; 列表过渡&quot;&gt;&lt;/a&gt;进入/离开 &amp;amp; 列表过渡&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。包括以下工具：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 CSS 过渡和动画中自动应用 class&lt;/li&gt;
&lt;li&gt;可以配合使用第三方 CSS 动画库，如 Animate.css&lt;/li&gt;
&lt;li&gt;在过渡钩子函数中使用 JavaScript 直接操作 DOM&lt;/li&gt;
&lt;li&gt;可以配合使用第三方 JavaScript 动画库，如 Velocity.js&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Learning" scheme="http://huguokang.com/categories/Learning/"/>
    
    
      <category term="Vue.js" scheme="http://huguokang.com/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js学习笔记7</title>
    <link href="http://huguokang.com/2017/11/14/Vue.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B07/"/>
    <id>http://huguokang.com/2017/11/14/Vue.js学习笔记7/</id>
    <published>2017-11-14T11:00:18.000Z</published>
    <updated>2017-11-17T01:13:26.780Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><h2 id="什么是组件？"><a href="#什么是组件？" class="headerlink" title="什么是组件？"></a>什么是组件？</h2><p>组件 (Component) 是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码。在较高层面上，组件是自定义元素，Vue.js 的编译器为它添加特殊功能。在有些情况下，组件也可以表现为用 is 特性进行了扩展的原生 HTML 元素。</p><a id="more"></a><h2 id="使用组件"><a href="#使用组件" class="headerlink" title="使用组件"></a>使用组件</h2><h3 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h3><p>要注册一个全局组件，可以使用<code>Vue.component(tagName,option)</code>。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'my-component'</span>,&#123;</div><div class="line">  <span class="comment">// 选项</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure><p><strong>NOTE:</strong>对于自定义标签的命名 Vue.js 不强制遵循 W3C 规则（小写，并且包含一个短杠），但这被认为是最佳实践。</p><p>组件在注册之后，便可以作为自定义元素<code>&lt;my-component&gt;&lt;/my-component&gt;</code>在一个实例的模板中使用。</p><p>要确保在初始化根实例之前注册组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 注册</span></div><div class="line">Vue.component(<span class="string">'my-component'</span>,&#123;</div><div class="line">  template: <span class="string">'&lt;div&gt;A custom component!&lt;/div&gt;'</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 创建根实例</span></div><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  el: <span class="string">'#example'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>渲染为：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>A custom component!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p><h3 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h3><p>不需要把每个组件都注册到全局。我们可以通过某个 Vue 实例/组件的实例选项<code>components</code>注册仅在其作用域中可用的组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Child = &#123;</div><div class="line">  template: <span class="string">'&lt;div&gt;A custom component!&lt;&gt;/div'</span></div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  components: &#123;</div><div class="line">    <span class="comment">// &lt;my-component&gt; 将只在父组件模板中可用</span></div><div class="line">    <span class="string">'my-component'</span>: Child</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>这种封装也适用于其他可注册的 Vue 功能，比如指令。</p><h3 id="DOM-模板解析注意事项"><a href="#DOM-模板解析注意事项" class="headerlink" title="DOM 模板解析注意事项"></a>DOM 模板解析注意事项</h3><p>当使用 DOM 作为模板时（例如，使用<code>el</code>选项来把 Vue 实例挂载到一个已有内容的元素上），你会受到 HTML 本身的一些限制，因为 Vue 只有在浏览器解析、规范化模板之后才能获取其内容。尤其要注意，像<code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;table&gt;</code>、<code>&lt;select&gt;</code>这样的元素里允许包含的元素有限制，而另一些像<code>&lt;option&gt;</code>这样的元素只能出现在某些特定元素的内部。</p><p>在自定义组件中使用这些受限制的元素时会导致一些问题，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">my-row</span>&gt;</span>...<span class="tag">&lt;/<span class="name">my-row</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></div></pre></td></tr></table></figure><p>自定义组件<code>&lt;my-row&gt;</code>会被当作无效的内容，因此会导致错误的渲染结果。变通的方案是使用特殊的<code>is</code>特性：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">tr</span> <span class="attr">is</span>=<span class="string">"my-row"</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></div></pre></td></tr></table></figure><p><strong>如果使用来自以下来源之一的字符串模板，则没有这些限制：</strong></p><ul><li><code>&lt;script type=&quot;text/x-template&quot;&gt;</code></li><li>JavaScript 内联模板字符串</li><li><code>.vue</code>组件</li></ul><h3 id="data-必须是函数"><a href="#data-必须是函数" class="headerlink" title="data 必须是函数"></a>data 必须是函数</h3><p>如果实例中的<code>data</code>不是一个函数，那么 Vue 会停止运行，并在控制台发出警告。</p><p>举一个特殊的例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-2"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">simple-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">simple-counter</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">simple-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">simple-counter</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">simple-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">simple-counter</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> data = &#123; <span class="attr">counter</span>: <span class="number">0</span> &#125;</div><div class="line">Vue.component(<span class="string">'simple-counter'</span>, &#123;</div><div class="line">  template: <span class="string">'&lt;button v-on:click="counter += 1"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;'</span>,</div><div class="line">  <span class="comment">// 技术上 data 的确是一个函数，因此 Vue 不会警告，</span></div><div class="line">  <span class="comment">// 但是我们却给每个组件实例返回了同一个对象的引用</span></div><div class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> data</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  el: <span class="string">'#example-2'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>由于这三个组件实例共享了同一个<code>data</code>对象，因此递增一个 counter 会影响所有组件。</p><p>我们可以通过为每个组件返回全新的数据对象来修复这个问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    counter: <span class="number">0</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>现在每个 counter 都有它自己内部的状态了。</p><h3 id="组件组合"><a href="#组件组合" class="headerlink" title="组件组合"></a>组件组合</h3><p>组件设计初衷就是要配合使用的，最常见的就是形成父子组件的关系：组件 A 在它的模板中使用了组件 B。它们之间必然需要相互通信：父组件可能要给子组件下发数据，子组件则可能要将它内部发生的事情告知父组件。然而，通过一个良好定义的接口来尽可能将父子组件解耦也是很重要的。这保证了每个组件的代码可以在相对隔离的环境中书写和理解，从而提高了其可维护性和复用性。</p><p>在 Vue 中，父子组件的关系可以总结为 <strong>prop 向下传递，事件向上传递</strong>。父组件通过 prop 给子组件下发数据，子组件通过事件给父组件发送消息。看看它们是怎么工作的。</p><h2 id="Prop"><a href="#Prop" class="headerlink" title="Prop"></a>Prop</h2><h3 id="使用-Prop-传递数据"><a href="#使用-Prop-传递数据" class="headerlink" title="使用 Prop 传递数据"></a>使用 Prop 传递数据</h3><p>组件实例的作用域是<strong>孤立的</strong>。这意味着不能（也不应该）在子组件的模板内直接引用父组件的数据。父组件的数据需要通过 Prop 才能下发到子组件中。</p><p>子组件要显式地用<code>props</code>选项声明它预期的数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'child'</span>,&#123;</div><div class="line">  <span class="comment">// 声明 props</span></div><div class="line">  props: [<span class="string">'message'</span>],</div><div class="line">  <span class="comment">// 就像 data 一样，prop 也可以在模板中使用</span></div><div class="line">  <span class="comment">// 同样也可以在 vm 实例中通过 this.message 来使用</span></div><div class="line">  template: <span class="string">'&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure><h3 id="camelCase-vs-kebab-case"><a href="#camelCase-vs-kebab-case" class="headerlink" title="camelCase vs. kebab-case"></a>camelCase vs. kebab-case</h3><p>HTML 特性是不区分大小写的。所以，当使用的不是字符串模板时，camelCase (驼峰式命名) 的 prop 需要转换为相对应的 kebab-case (短横线分隔式命名)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'child'</span>,&#123;</div><div class="line">  <span class="comment">// 在 JavaScript 中使用 camelCase</span></div><div class="line">  props: [<span class="string">'myMessage'</span>],</div><div class="line">  template: <span class="string">'&lt;span&gt;&#123;&#123; myMessage &#125;&#125;&lt;/spam&gt;'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 在 HTML 中使用 kebab-case --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">my-message</span>=<span class="string">"hello!"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></div></pre></td></tr></table></figure><p>如果你使用字符串模板则没有这些限制。</p><h3 id="动态-Prop"><a href="#动态-Prop" class="headerlink" title="动态 Prop"></a>动态 Prop</h3><p>与绑定到任何普通的 HTML 特性相类似，我们可以用<code>v-bind</code>来动态地将 prop 绑定到父组件的数据。当父组件的数据变化时，该变化也会传导给子组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"parentMsg"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">child</span> <span class="attr">v-bind:my-message</span>=<span class="string">"parentMsg"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p>如果你想把一个对象的所有属性作为 prop 进行传递，可以使用不带任何参数的<code>v-bind</code>（即用<code>v-bind</code>而不是<code>v-bind:prop-name</code>）。例如，已知一个<code>todo</code>对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">todo: &#123;</div><div class="line">  text: <span class="string">'Learn Vue'</span>,</div><div class="line">  isComplete: fasle</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>然后：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">todo-item</span> <span class="attr">v-bind</span>=<span class="string">"todo"</span>&gt;</span><span class="tag">&lt;/<span class="name">todo-item</span>&gt;</span></div></pre></td></tr></table></figure><p>将等价于：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">todo-item</span></span></div><div class="line"><span class="tag">  <span class="attr">v-bind:text</span>=<span class="string">"todo.text"</span></span></div><div class="line"><span class="tag">  <span class="attr">v-bind:is-complete</span>=<span class="string">"todo.isComplete"</span></span></div><div class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">todo-item</span>&gt;</span></div></pre></td></tr></table></figure><h3 id="字面量语法-vs-动态语法"><a href="#字面量语法-vs-动态语法" class="headerlink" title="字面量语法 vs 动态语法"></a>字面量语法 vs 动态语法</h3><p>初学者常犯的一个错误是使用字面量语法传递数值：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 传递了一个字符串 "1" --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">comp</span> <span class="attr">some-prop</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></div></pre></td></tr></table></figure><p>因为它是一个字面量 prop ，它的值是字符串<code>&quot;1&quot;</code>而不是一盒数值。如果想传递一个真正的 JavaScript 数值，则需要使用<code>v-bind</code>，从而让它的值被当作 JavaScript 表达式计算：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 传递真正的数值 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">comp</span> <span class="attr">v-bind:some-prop</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></div></pre></td></tr></table></figure><h3 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h3><p>Prop 是单向绑定的：当父组件的属性变化时，将传导给子组件，但是反过来不会。这是为了防止子组件无意间修改了父组件的状态，来避免应用的数据流变得难以理解。</p><p>另外，每次父组件更新时，子组件的所有 prop 都会更新为最新值。这意味着你不应该在子组件内部改变 prop。如果你这么做了，Vue 会在控制台给出警告。</p><p>在两种情况下，我们很容易忍不住想去修改 prop 中数据：</p><ol><li><p>Prop 作为初始值传入后，子组件想把它当作局部数据来用。</p></li><li><p>Prop 作为原始数据传入，由子组件处理成其他数据输出。</p></li></ol><p>对于这两种情况，正确的应对方式是：</p><ol><li>定义一个局部变量，并用 prop 的值初始化它：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">props: [<span class="string">'initialCounter'</span>],</div><div class="line">data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123; <span class="attr">counter</span>: <span class="keyword">this</span>.initialCounter &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ol><li>定义一个计算属性，处理 prop 的值并返回：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">props: [<span class="string">'size'</span>],</div><div class="line">computed: &#123;</div><div class="line">  normalizedSize: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size.trim().toLowerCase  <span class="comment">// 删除首尾空格并小写</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>NOTE:</strong>在 JavaScript 中对象和数组是引用类型，指向同一个内存空间，如果 prop 是一个对象或数组，在子组件内部改变它会影响父组件的状态。</p><h3 id="Prop-验证"><a href="#Prop-验证" class="headerlink" title="Prop 验证"></a>Prop 验证</h3><p>我们可以为组件的 prop 指定验证规则。如果传入的数据不符合要求，Vue 会发出警告。这对于开发给他人使用的组件非常有用。</p><p>要指定验证规则，需要用对象的形式来定义 prop ，而不能用字符串数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'example'</span>, &#123;</div><div class="line">  props: &#123;</div><div class="line">    <span class="comment">// 基础类型检测（'null' 指允许任何类型）</span></div><div class="line">    propA: <span class="built_in">Number</span>,</div><div class="line">    <span class="comment">// 可能是多种类型</span></div><div class="line">    propB: [<span class="built_in">String</span>, <span class="built_in">Number</span>],</div><div class="line">    <span class="comment">// 必传且是字符串</span></div><div class="line">    propC: &#123;</div><div class="line">      type: <span class="built_in">String</span>,</div><div class="line">      required: <span class="literal">true</span></div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// 数值且有默认值</span></div><div class="line">    propD: &#123;</div><div class="line">      type: <span class="built_in">Number</span>,</div><div class="line">      <span class="keyword">default</span>: <span class="number">100</span></div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// 数组/对象的默认值应当由一个工厂函数返回</span></div><div class="line">    propE: &#123;</div><div class="line">      type: <span class="built_in">Object</span>,</div><div class="line">      <span class="keyword">default</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> &#123; <span class="attr">message</span>: <span class="string">'hello'</span> &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// 自定义验证函数</span></div><div class="line">    propF: &#123;</div><div class="line">      validator: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> value &gt; <span class="number">10</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p><code>type</code>可以是下面原生构造器：</p><ul><li>String</li><li>Number</li><li>Boolean</li><li>Function</li><li>Object</li><li>Array</li><li>Symbol</li></ul><p><code>type</code>也可以是一个自定义构造器函数，使用<code>instanceof</code>检测。</p><p>当 prop 验证失败，Vue 会抛出警告 (如果使用的是开发版本)。注意 prop 会在<strong>组件实例创建之前</strong>进行校验，所以在<code>default</code>或<code>validator</code>函数里，诸如<code>data</code>、<code>computed</code>或<code>methods</code>等实例属性还无法使用。</p><h2 id="非-Prop-特性"><a href="#非-Prop-特性" class="headerlink" title="非 Prop 特性"></a>非 Prop 特性</h2><p>所谓非 prop 特性，就是指它可以直接传入组件，而不需要定义相应的 prop。</p><p>尽管为组件定义明确的 prop 是推荐的传参方式，组件的作者却并不总能预见到组件被使用的场景。所以，组件可以接收任意传入的特性，这些特性都会被添加到组件的根元素上。</p><h3 id="替换-合并现有的特性"><a href="#替换-合并现有的特性" class="headerlink" title="替换/合并现有的特性"></a>替换/合并现有的特性</h3><p>假设这是<code>bs-date-input</code>的模板：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"date"</span> <span class="attr">class</span>=<span class="string">"form-control"</span>&gt;</span></div></pre></td></tr></table></figure><p>为了给该日期选择器插件增加一个特殊的主题，我们可能需要增加一个特殊的 class ，比如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bs-date-input</span></span></div><div class="line"><span class="tag">  <span class="attr">date-3d-date-picker</span>=<span class="string">"true"</span></span></div><div class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">"date-picker-theme-dark"</span></span></div><div class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">bs-date-input</span>&gt;</span></div></pre></td></tr></table></figure><p>在这个例子中我们定义了两个不同的<code>class</code>值：</p><ul><li><code>form-control</code>，来自组件自身的模板</li><li><code>date-picker-theme-dark</code>，来自父组件</li></ul><p>对于多数特性来说，传递给组件的值会覆盖组件本身设定的值。即例如传递<code>type=&quot;large&quot;</code>将会覆盖 <code>type=&quot;date&quot;</code>且有可能破坏该组件！所幸我们对待<code>class</code>和<code>style</code>特性会更聪明一些，这两个特性的值都会做合并 (merge) 操作，让最终生成的值为：<code>form-control date-picker-theme-dark</code>。</p><h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><h3 id="使用-绑定自定义事件v-on"><a href="#使用-绑定自定义事件v-on" class="headerlink" title="使用 绑定自定义事件v-on"></a>使用 绑定自定义事件<code>v-on</code></h3><p>每个 Vue 实例都实现了<strong>事件接口</strong>，即：</p><ul><li>使用<code>$on(eventName)</code>监听事件</li><li>使用<code>$emit(eventName)</code>触发事件</li></ul><p>父组件可以在使用子组件的地方直接用<code>v-on</code>来监听子组件触发的事件。不能用<code>$on</code>侦听子组件释放的事件，而必须在模板里直接用<code>v-on</code>绑定。</p><p>举例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"counter-event-example"</span>&gt;</span>  // 父组件</div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; total &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">button-counter</span> <span class="attr">v-on:increment</span>=<span class="string">"incrementTotal"</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">button-counter</span> <span class="attr">v-on:increment</span>=<span class="string">"incrementTotal"</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'button-counter'</span>, &#123;</div><div class="line">  template: <span class="string">'&lt;button v-on:click="incrementCounter"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;'</span>,</div><div class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      counter: <span class="number">0</span></div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  methods: &#123;</div><div class="line">    incrementCounter: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">this</span>.counter += <span class="number">1</span></div><div class="line">      <span class="keyword">this</span>.$emit(<span class="string">'increment'</span>)      <span class="comment">// 子组件只报告自己内部的事件，与外部完全解耦</span></div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  el: <span class="string">'#counter-event-example'</span>,</div><div class="line">  data: &#123;</div><div class="line">    total: <span class="number">0</span></div><div class="line">  &#125;,</div><div class="line">  methods: &#123;</div><div class="line">    incrementTotal: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">this</span>.total += <span class="number">1</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><h3 id="给组件绑定原生事件"><a href="#给组件绑定原生事件" class="headerlink" title="给组件绑定原生事件"></a>给组件绑定原生事件</h3><p>使用<code>v-on</code>的修饰符<code>.native</code>在组件的根元素上监听一个<strong>原生事件</strong>。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">v-on:click.native</span>=<span class="string">"doTheThing"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></div></pre></td></tr></table></figure><h3 id="sync修饰符"><a href="#sync修饰符" class="headerlink" title=".sync修饰符"></a><code>.sync</code>修饰符</h3><p>在一些情况下，我们可能会需要对一个 prop 进行“双向绑定”。</p><p>当一个子组件改变了一个带<code>.sync</code>的 prop 的值时，这个变化也会同步到父组件中所绑定的值。</p><p>这很方便，但是破坏了单向数据流。由于子组件改变 prop 的代码和普通的状态改动代码毫无区别，你无法知道它何时改变了父组件的状态。这在 debug 复杂结构的应用时会带来很高的维护成本。</p><p>2.0中移除<code>.sync</code>就是因为这个原因。</p><p>从2.3.0起重新引入了<code>.sync</code>修饰符，但是这次它只是作为一个编译时的语法糖存在。它会被扩展为一个自动更新父组件属性的<code>v-on</code>监听器。</p><p>如下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">comp</span> <span class="attr">:foo.sync</span>=<span class="string">"bar"</span>&gt;</span><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></div></pre></td></tr></table></figure><p>会被扩展为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">comp</span> <span class="attr">:foo</span>=<span class="string">"bar"</span> @<span class="attr">update:foo</span>=<span class="string">"val =&gt; bar = val"</span>&gt;</span><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></div></pre></td></tr></table></figure><p>当子组件需要更新<code>foo</code>的值时，它需要显式地触发一个更新事件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.$emit(<span class="string">'update:foo'</span>, newValue)</div></pre></td></tr></table></figure><h3 id="使用自定义事件的表单输入组件"><a href="#使用自定义事件的表单输入组件" class="headerlink" title="使用自定义事件的表单输入组件"></a>使用自定义事件的表单输入组件</h3><p>自定义事件可以用来创建自定义的表单输入组件，使用<code>v-model</code>来进行数据双向绑定。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"something"</span>&gt;</span></div></pre></td></tr></table></figure><p>这不过是以下示例的语法糖：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">input</span></span></div><div class="line"><span class="tag">  <span class="attr">v-bind:value</span>=<span class="string">"something"</span></span></div><div class="line"><span class="tag">  <span class="attr">v-on:input</span>=<span class="string">"something = $event.target.value"</span>&gt;</span></div></pre></td></tr></table></figure><p>所以在组件中使用时，它相当于下面的简写：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">custom-input</span></span></div><div class="line"><span class="tag">  <span class="attr">v-bind:value</span>=<span class="string">"something"</span></span></div><div class="line"><span class="tag">  <span class="attr">v-on:input</span>=<span class="string">"something = arguments[0]"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">custom-input</span>&gt;</span></div></pre></td></tr></table></figure><p>所以要让组件的<code>v-model</code>生效，它应该：</p><ul><li>接受一个<code>value</code>prop</li><li>在有新的值时触发<code>input</code>事件并将新值作为参数</li></ul><p>我们来写一个非常简单的货币输入的自定义控件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">currency-input</span> <span class="attr">v-model</span>=<span class="string">"price"</span>&gt;</span><span class="tag">&lt;/<span class="name">currency-input</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'currency-input'</span>, &#123;</div><div class="line">  template: <span class="string">'\</span></div><div class="line"><span class="string">    &lt;span&gt;\</span></div><div class="line"><span class="string">      $\</span></div><div class="line"><span class="string">      &lt;input\</span></div><div class="line"><span class="string">        ref="input"\</span></div><div class="line"><span class="string">        v-bind:value="value"\</span></div><div class="line"><span class="string">        v-on:input="updateValue($event.target.value)"\</span></div><div class="line"><span class="string">      &gt;\</span></div><div class="line"><span class="string">    &lt;/span&gt;\</span></div><div class="line"><span class="string">  '</span>,</div><div class="line">  props: [<span class="string">'value'</span>],</div><div class="line">  methods: &#123;</div><div class="line">    <span class="comment">// 不是直接更新值，而是使用此方法来对输入值进行格式化和位数限制</span></div><div class="line">    updateValue: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> formattedValue = value</div><div class="line">      <span class="comment">// 删除首尾的空格符</span></div><div class="line">      .trim()</div><div class="line">      <span class="comment">// 保留 2 位小数</span></div><div class="line">      .slice(</div><div class="line">        <span class="number">0</span>,</div><div class="line">        value.indexOf(<span class="string">'.'</span>) === <span class="number">-1</span></div><div class="line">          ? value.length</div><div class="line">          : value.indexOf(<span class="string">'.'</span>) + <span class="number">3</span></div><div class="line">      )</div><div class="line">    <span class="comment">// 如果值尚不合规，则手动覆盖合规的值</span></div><div class="line">    <span class="keyword">if</span> (formattedValue !== value) &#123;</div><div class="line">      <span class="keyword">this</span>.$refs.input.value = formattedValue  <span class="comment">// 通过`this.$refs.input.value`访问到`ref="input"`</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 通过 input 事件带出数值</span></div><div class="line">    <span class="keyword">this</span>.$emit(<span class="string">'input'</span>, <span class="built_in">Number</span>(formattedValue))</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><h3 id="自定义组件的v-model"><a href="#自定义组件的v-model" class="headerlink" title="自定义组件的v-model"></a>自定义组件的<code>v-model</code></h3><p>默认情况下，一个组件的<code>v-model</code>会使用<code>value</code>prop 和<code>input</code>事件。但是诸如单选框、复选框之类的输入类型可能把<code>value</code>用作了别的目的。<code>model</code>选项可以避免这样的冲突：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'my-checkbox'</span>, &#123;</div><div class="line">  model: &#123;</div><div class="line">    prop: <span class="string">'checked'</span>,</div><div class="line">    event: <span class="string">'change'</span></div><div class="line">  &#125;,</div><div class="line">  props: &#123;</div><div class="line">    checked: <span class="built_in">Boolean</span>,  <span class="comment">// 注意仍然要显式声明`checked`这个 prop</span></div><div class="line">    <span class="comment">// 这样就允许拿`value`这个 prop 做其他事儿了</span></div><div class="line">    value: <span class="built_in">String</span></div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">my-chcekbox</span> <span class="attr">v-model</span>=<span class="string">"foo"</span> <span class="attr">value</span>=<span class="string">"some value"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-checkbox</span>&gt;</span></div></pre></td></tr></table></figure><p>上述代码等价于：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">my-checkbox</span></span></div><div class="line"><span class="tag">  <span class="attr">:checked</span>=<span class="string">"foo"</span></span></div><div class="line"><span class="tag">  @<span class="attr">change</span>=<span class="string">"val =&gt; &#123; foo = val &#125;"</span></span></div><div class="line"><span class="tag">  <span class="attr">value</span>=<span class="string">"some value"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">my-checkbox</span>&gt;</span></div></pre></td></tr></table></figure><h3 id="非父子组件的通信"><a href="#非父子组件的通信" class="headerlink" title="非父子组件的通信"></a>非父子组件的通信</h3><p>有时候，非父子关系的两个组件之间也需要通信。在简单的场景下，可以使用一个空的 Vue 实例作为事件总线：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> bus = <span class="keyword">new</span> Vue()</div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 触发组件 A 中的事件</span></div><div class="line">bus.$emit(<span class="string">'id-selected'</span>, <span class="number">1</span>)</div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在组件 B 创建的钩子中监听事件</span></div><div class="line">bus.$on(<span class="string">'id-selected'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">id</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>在复杂的情况下，我们应该考虑使用专门的<strong>状态管理模式</strong>。</p><h2 id="使用插槽分发内容"><a href="#使用插槽分发内容" class="headerlink" title="使用插槽分发内容"></a>使用插槽分发内容</h2><p>在使用组件时，我们常常要像这样组合它们：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">app</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">app-header</span>&gt;</span><span class="tag">&lt;/<span class="name">app-header</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">app-footer</span>&gt;</span><span class="tag">&lt;/<span class="name">app-footer</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">app</span>&gt;</span></div></pre></td></tr></table></figure><p>注意两点：</p><ol><li><code>&lt;app&gt;</code>组件不知道它会收到什么内容。这是由使用<code>&lt;app&gt;</code>的父组件决定的。</li><li><code>&lt;app&gt;</code>组件很可能有它自己的模板。</li></ol><p>为了让组件可以组合，我们需要一种方式来混合父组件的内容和子组件自己的模板。这个过程被称为<strong>内容分发</strong>。Vue.js 实现了一个内容分发 API,参照了当前 Web Components 规范草案，使用特殊的<code>&lt;slot&gt;</code>元素作为原始内容的插槽。</p><h3 id="编译作用域"><a href="#编译作用域" class="headerlink" title="编译作用域"></a>编译作用域</h3><p>在深入内容分发 API 之前，我们先明确内容在哪个作用域编译。假定模板为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">child-component</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">child-component</span>&gt;</span></div></pre></td></tr></table></figure><p><code>message</code>绑定到父组件的数据。</p><p>组件作用域简单地说是：</p><blockquote><p>父组件模板的内容在父组件作用域内编译；子组件模板的内容在子组件作用域内编译。</p></blockquote><p>一个常见错误是试图在父组件模板内将一个指令绑定到子组件的属性/方法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 无效 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">child-component</span> <span class="attr">v-show</span>=<span class="string">"someChildProperty"</span>&gt;</span><span class="tag">&lt;/<span class="name">child-component</span>&gt;</span></div></pre></td></tr></table></figure><p>假定<code>someChildProperty</code>是子组件的属性，因为父组件模板并不感知子组件的状态，所以这个例子不会如预期那样工作。</p><p>如果要绑定子组件作用域内的指令到一个组件的根节点，你应当在子组件自己的模板里做：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'child-component'</span>, &#123;</div><div class="line">  <span class="comment">// 有效，因为是在正确的作用域内</span></div><div class="line">  template: <span class="string">'&lt;div v-show="someChildProperty"&gt;Child&lt;/div&gt;'</span>,</div><div class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      someChildProperty: <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>类似地，被分发地内容会在父作用域内编译。</p><h3 id="单个插槽"><a href="#单个插槽" class="headerlink" title="单个插槽"></a>单个插槽</h3><p>除非子组件模板包含至少一个<code>&lt;slot&gt;</code>插口，否则父组件的内容将会被丢弃。当子组件模板只有一个没有属性的插槽时，父组件传入的整个内容片段将插入到插槽所在的 DOM 位置，并替换掉插槽标签本身。</p><p>最初在<code>&lt;slot&gt;</code>标签中的任何内容都被视为备用内容。备用内容在子组件的作用域内编译，并且只有在宿主元素为空，且没有要插入的内容时才显示备用内容。</p><p>假如<code>my-component</code>组件有如下模板：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是子组件的标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span></div><div class="line">    只有在没有要分发的内容时才会显示。</div><div class="line">  <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p>父组件模板：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是父组件的标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">my-component</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一些初始内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是更多的初始内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p>渲染结果为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是父组件的标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是子组件的标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一些初始内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是更多的初始内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><p><code>&lt;slot&gt;</code>元素可以用一个特殊的特性<code>name</code>来进一步配置如何分发内容。多个插槽可以有不同的名字。具名插槽将匹配内容片段中有对应<code>slot</code>特性的元素。</p><p>仍然可以有一个匿名插槽，它是默认插槽，作为找不到匹配的内容片段的备用插槽。如果没有默认插槽，这些找不到匹配的内容片段将被抛弃。</p><p>例如，假定我们有一个<code>app-layout</code>组件，它的模板为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"header"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p>父组件模板为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">app-layout</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">slot</span>=<span class="string">"header"</span>&gt;</span>这里可能是一个页面标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>主要内容的一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>另一个主要段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">slot</span>=<span class="string">"footer"</span>&gt;</span>这里有一些联系信息<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">app-layout</span>&gt;</span></div></pre></td></tr></table></figure><p>渲染结果为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这里可能是一个页面标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>主要内容的一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>另一个主要段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这里有一些联系信息<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><p>作用域插槽是一种特殊类型的插槽，用作一个 (能被传递数据的) 可重用模板，来代替已经渲染好的元素。</p><p>在子组件中，只需将数据传递到插槽，就像你将 prop 传递给组件一样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">text</span>=<span class="string">"hello from child"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p>在父组件中，必须存在具有特殊特性<code>slot-scope</code>的<code>&lt;template&gt;</code>元素存在，它是作用域插槽的模板。<code>slot-scope</code>的值被用作一个临时变量名，<strong>此变量接收从子组件传递过来的 prop 对象</strong>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">child</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">"props"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>hello from parent<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; props.text &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">child</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p>如果我们渲染上述模板，得到的输出会是：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>hello from parent<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>hello from child<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><blockquote><p>在2.5.0+，<code>slot-scope</code>能被用在任意元素或组件中而不再局限于<code>&lt;template&gt;</code>。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">my-awesome-list</span> <span class="attr">:item</span>=<span class="string">"items"</span>&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 作用域插槽也可以是具名的 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span></span></div><div class="line"><span class="tag">    <span class="attr">slot</span>=<span class="string">"item"</span></span></div><div class="line"><span class="tag">    <span class="attr">slot-scope</span>=<span class="string">"props"</span></span></div><div class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"my-fancy-item"</span>&gt;</span></div><div class="line">    &#123;&#123; props.text  &#125;&#125;</div><div class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">my-awesome-list</span>&gt;</span></div></pre></td></tr></table></figure><p>列表组件的模板：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"item"</span></span></div><div class="line"><span class="tag">    <span class="attr">v-for</span>=<span class="string">"item in items"</span></span></div><div class="line"><span class="tag">    <span class="attr">:text</span>=<span class="string">"item.text"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 这里写入备选内容 --&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure><p><strong>解构</strong></p><p><code>slot-scope</code>的值实际上是一个可以出现在函数签名参数位置的合法的 JavaScript 表达式。这意味着在受支持的环境（单文件组件或现代浏览器）中，可以在表达式中使用 ES2015 解构：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">child</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">slot-scope</span>=<span class="string">"&#123; text &#125;"</span>&gt;</span>&#123;&#123; text &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">child</span>&gt;</span></div></pre></td></tr></table></figure><h2 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h2><p>通过使用保留的<code>&lt;component&gt;</code>元素，动态地绑定到它的<code>is</code>特性，我们让多个组件可以使用同一个挂载点，并动态切换：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</div><div class="line">  el: <span class="string">'#example'</span>,</div><div class="line">  data: &#123;</div><div class="line">    currentView: <span class="string">'home'</span></div><div class="line">  &#125;,</div><div class="line">  components: &#123;</div><div class="line">    home: &#123; <span class="comment">/* ... */</span> &#125;,</div><div class="line">    posts: &#123; <span class="comment">/* ... */</span> &#125;,</div><div class="line">    archive: &#123; <span class="comment">/* ... */</span> &#125; </div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">"currentView"</span>&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 组件在 vm.currentView 变化时改变！ --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">component</span>&gt;</span></div></pre></td></tr></table></figure><p>也可以直接绑定到组件对象上：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Home = &#123;</div><div class="line">  template: <span class="string">'&lt;p&gt;Welcome home!&lt;/p&gt;'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</div><div class="line">  el: <span class="string">'#example'</span>,</div><div class="line">  data: &#123;</div><div class="line">    currentView: Home</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><h3 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h3><p>如果把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染。为此可以添加一个<code>keep-alive</code>指令参数：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"currentView"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 非活动组件将被缓存！ --&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">component</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></div></pre></td></tr></table></figure><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h3 id="编写可复用组件"><a href="#编写可复用组件" class="headerlink" title="编写可复用组件"></a>编写可复用组件</h3><p>在编写组件时，最好考虑好以后是否要进行复用。一次性组件间有紧密的耦合没关系，但是可复用组件应当定义一个清晰的公开接口，同时也不要对其使用的外层数据作出任何假设。</p><p>Vue 组件的 API 来自三部分–prop、事件和插槽：</p><ul><li>Prop 允许外部环境传递数据给组件；</li><li>事件允许从组件内部触发外部环境的副作用；</li><li>插槽允许外部环境将额外的内容组合在组件中。</li></ul><h3 id="子组件引用"><a href="#子组件引用" class="headerlink" title="子组件引用"></a>子组件引用</h3><p>尽管有 prop 和事件，但是有时仍然需要在 JavaScript 中直接访问子组件。为此可以使用<code>ref</code>为子组件指定一个引用 ID。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">user-profile</span> <span class="attr">ref</span>=<span class="string">"profile"</span>&gt;</span><span class="tag">&lt;/<span class="name">user-profile</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> parent = <span class="keyword">new</span> Vue(&#123; <span class="attr">el</span>: <span class="string">'#parent'</span>&#125;)</div><div class="line"><span class="comment">// 访问子组件实例</span></div><div class="line"><span class="keyword">var</span> child = parent.$refs.profile</div></pre></td></tr></table></figure><p>当<code>ref</code>和<code>v-for</code>一起使用时，获取到的引用会是一个数组，包含和循环数据源对应的子组件。</p><p><strong>NOTE:</strong><code>refs</code>只有组件渲染完成后才填充，并且它是非响应式的。它仅仅是一个直接操作子组件的应急方案–应当避免在<strong>模板或计算属性</strong>中使用<code>$refs</code>。</p><h3 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h3><p>在大型应用中，我们可能需要将应用拆分为多个小模块，按需从服务器下载。为了进一步简化，Vue.js 允许将组件定义为一个工厂函数，异步地解析组件的定义。Vue.js 只在组件需要渲染时触发工厂函数，并且把结果缓存起来，用于后面的再次渲染。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'async-example'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 将组件定义传入 resolve 回调函数</span></div><div class="line">    resolve(&#123;</div><div class="line">      template: <span class="string">'&lt;div&gt;I am async!&lt;/div&gt;'</span></div><div class="line">    &#125;)</div><div class="line">  &#125;,<span class="number">1000</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>工厂函数接收一个<code>resolve</code>回调，在收到从服务器下载的组件定义时调用。也可以调用<code>reject(reason)</code>指示加载失败。推荐配合 Webpack 的代码分割功能来使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'async-webpack-example'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</div><div class="line">  <span class="comment">// 这个特殊的 require 语法告诉 webpack</span></div><div class="line">  <span class="comment">// 自动将编译后的代码分割成不同的块，</span></div><div class="line">  <span class="comment">// 这些块将通过 Ajax 请求自动下载。</span></div><div class="line">  <span class="built_in">require</span>([<span class="string">'./my-async-component'</span>], resolve)</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>你可以在工厂函数中返回一个<code>Promise</code>，所以当使用 webpack2+ES2015 的语法时可以这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Vue.component(</div><div class="line">  <span class="string">'async-webpack-example'</span>,</div><div class="line">  <span class="comment">// 该`import`函数返回一个`Promise`对象。</span></div><div class="line">  () =&gt; <span class="keyword">import</span>(<span class="string">'./my-async-component'</span>)</div><div class="line">)</div></pre></td></tr></table></figure><p>当使用局部注册时，也可以直接提供一个返回 Promise 的函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  components: &#123;</div><div class="line">    <span class="string">'my-component'</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./my-async-component'</span>)</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><h3 id="高级异步组件"><a href="#高级异步组件" class="headerlink" title="高级异步组件"></a>高级异步组件</h3><p>自2.3.0起，异步组件的工厂函数也可以返回一个如下的对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> AsyncComp = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</div><div class="line">  <span class="comment">// 需要加载的组件。应当是一个 Promise</span></div><div class="line">  component: <span class="keyword">import</span>(<span class="string">'./MyComp.vue'</span>),</div><div class="line">  <span class="comment">// 加载中应当渲染的组件</span></div><div class="line">  loading: LoadingComp,</div><div class="line">  <span class="comment">// 出错时应当渲染的组件</span></div><div class="line">  error: ErrorComp,</div><div class="line">  <span class="comment">// 渲染加载中组件前的等待时间。默认：200ms。</span></div><div class="line">  delay: <span class="number">200</span>,</div><div class="line">  <span class="comment">// 最长等待时间。超出此时间则渲染错误组件。默认：Infinity</span></div><div class="line">  timeout: <span class="number">3000</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>注意，当一个异步组件被作为<code>vue-router</code>的路由组件使用时，这些高级选项都是无效的，因为在路由切换前就会提前加载所需要的异步组件。另外，如果你要在路由组件中使用上述写法，需要使用<code>vue-router</code>2.4.0 以上的版本。</p><h3 id="组件命名约定"><a href="#组件命名约定" class="headerlink" title="组件命名约定"></a>组件命名约定</h3><p>当注册组件（或者 prop）时，可以使用 kebab-case（短横线分隔命名）、camelCase（驼峰式命名）或 PascalCase （单词首字母大写命名）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在组件定义中</span></div><div class="line">components: &#123;</div><div class="line">  <span class="comment">// 使用 kebab-case 注册</span></div><div class="line">  <span class="string">'kebab-cased-component'</span>: &#123; <span class="comment">/* ... */</span>&#125;,</div><div class="line">  <span class="comment">// 使用 camelCase 注册</span></div><div class="line">  <span class="string">'camelCasedComponent'</span>: &#123; <span class="comment">/* ... */</span>&#125;,</div><div class="line">  <span class="comment">// 使用 PascalCase 注册</span></div><div class="line">  <span class="string">'PascalCasedComponent'</span>: &#123; <span class="comment">/* ... */</span>&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在 HTML 模板中始终要使用 kebab-case 。</p><p>当使用字符串模式时，可以不受 HTML 大小写不敏感的限制，这意味实际上在模板中，你可以使用下面的方式来引用你的组件：</p><ul><li>kebab-case</li><li>camelCase 或 kebab-case （如果组件已经被定义为 camelCase）</li><li>kebab-case、camelCase 或 PascalCase （如果组件已经被定义为 PascalCase）</li></ul><p>这意味着 PascalCase 是最通用的<strong>声明约定</strong>而 kebab-case 是最通用的<strong>使用约定</strong>。</p><p>如果组件未经<code>slot</code>元素传入内容，你甚至可以在组件名后使用<code>/</code>使其自闭合：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">my-component</span>/&gt;</span></div></pre></td></tr></table></figure><p>这只能在字符串模板中有效。因为自闭的自定义元素是无效的 HTML ，浏览器原生的解析器也无法识别它。</p><h3 id="递归组件"><a href="#递归组件" class="headerlink" title="递归组件"></a>递归组件</h3><p>组件在它的模板内可以自己递归地调用自己。不过，只有当它有<code>name</code>选项时才可以这么做：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">name: <span class="string">`unique-name-of-my-component`</span></div></pre></td></tr></table></figure><p>当你利用<code>Vue.component</code>全局注册了一个组件，全局的 ID 会自动设置为组件的<code>name</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'unique-name-of-my-component'</span>, &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>递归组件很可能导致死循环，所以要确保递归调用有终止条件（比如递归调用时使用<code>v-if</code>并最终解析为<code>fasle</code>）。</p><h3 id="组件间的循环引用"><a href="#组件间的循环引用" class="headerlink" title="组件间的循环引用"></a>组件间的循环引用</h3><p>假设你正在构建一个文件目录树，像在 Finder 或资源管理器中。你可能有一个<code>tree-folder</code>组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; folder.name &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">tree-folder-contents</span> <span class="attr">:children</span>=<span class="string">"folder.childer"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure><p>以及一个<code>tree-folder-contents</code>组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"child in children"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">tree-folder</span> <span class="attr">v-if</span>=<span class="string">"child.children"</span> <span class="attr">:folder</span>=<span class="string">"child"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else</span>&gt;</span>&#123;&#123; child.name &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure><p>当你仔细看时，会发现在渲染树上这两个组件同时为对方的父节点和子节点——这是矛盾的！当使用 <code>Vue.component</code>将这两个组件注册为全局组件的时候，框架会自动为你解决这个矛盾。</p><p>然而，如果你使用诸如 webpack 或者 Browserify 之类的模块化管理工具来 require/import 组件的话，就会报错了。</p><p>为了解释为什么会报错，简单的将上面两个组件称为 A 和 B。模块系统看到它需要 A，但是首先 A 需要 B，但是 B 需要 A，而 A 需要 B，循环往复。因为不知道到底应该先解析哪个，所以将会陷入无限循环。要解决这个问题，我们需要在其中一个组件中告诉模块化管理系统：“A 虽然最后会用到 B，但是不需要优先导入 B”。</p><p>我们选择让<code>tree-folder</code>组件中来做这件事。我们知道引起矛盾的子组件是<code>tree-folder-contents</code>，所以我们要等到<code>beforeCreate</code>生命钩子中才去注册它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">reCreate: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.$options.components.TreeFolderContents = <span class="built_in">require</span>(<span class="string">'./tree-folder-contents.vue'</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="内联模板"><a href="#内联模板" class="headerlink" title="内联模板"></a>内联模板</h3><p>如果子组件有<code>inline-template</code>特性，组件将把它的内容当作它的模板，而不是把它当作分发内容。这让模板编写起来更灵活。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">inline-template</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这些将作为组件自身的模板。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>而非父组件透传进来的内容。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></div></pre></td></tr></table></figure><p>但是<code>inline-template</code>让模板的作用域难以理解。使用<code>template</code>选项在组件内定义模板或者在<code>.vue</code>文件中使用<code>template</code>元素才是最佳实践。</p><h3 id="X-Template"><a href="#X-Template" class="headerlink" title="X-Template"></a>X-Template</h3><p>另一种定义模板的方法是在 JavaScript 标签里使用 <code>text/x-template</code> 类型，并且指定一个 id 。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/x-template"</span> <span class="attr">id</span>=<span class="string">"hello-world-tempalte"</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello hello hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'hello-world'</span>, &#123;</div><div class="line">  template: <span class="string">'#hello-world-template'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>这在有很多大模板的演示应用或者特别小的应用中可能有用，其它场合应该避免使用，因为这将模板和组件的其它定义分离了。</p><h3 id="对低开销的静态组件使用v-once"><a href="#对低开销的静态组件使用v-once" class="headerlink" title="对低开销的静态组件使用v-once"></a>对低开销的静态组件使用<code>v-once</code></h3><p>尽管在 Vue 中渲染 HTML 很快，不过当组件中包含大量静态内容时，可以考虑使用<code>v-once</code>将渲染结果缓存起来，就像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'terms-of-service'</span>, &#123;</div><div class="line">  template: <span class="string">'\</span></div><div class="line"><span class="string">    &lt;div v-once&gt;\</span></div><div class="line"><span class="string">      &lt;h1&gt;Terms of Service&lt;/h1&gt;\</span></div><div class="line"><span class="string">      ...很多静态内容...\</span></div><div class="line"><span class="string">    &lt;/div&gt;\</span></div><div class="line"><span class="string">  '</span>  </div><div class="line">&#125;)</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;组件&quot;&gt;&lt;a href=&quot;#组件&quot; class=&quot;headerlink&quot; title=&quot;组件&quot;&gt;&lt;/a&gt;组件&lt;/h1&gt;&lt;h2 id=&quot;什么是组件？&quot;&gt;&lt;a href=&quot;#什么是组件？&quot; class=&quot;headerlink&quot; title=&quot;什么是组件？&quot;&gt;&lt;/a&gt;什么是组件？&lt;/h2&gt;&lt;p&gt;组件 (Component) 是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码。在较高层面上，组件是自定义元素，Vue.js 的编译器为它添加特殊功能。在有些情况下，组件也可以表现为用 is 特性进行了扩展的原生 HTML 元素。&lt;/p&gt;
    
    </summary>
    
      <category term="Learning" scheme="http://huguokang.com/categories/Learning/"/>
    
    
      <category term="Vue.js" scheme="http://huguokang.com/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js学习笔记6</title>
    <link href="http://huguokang.com/2017/11/09/Vue.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06/"/>
    <id>http://huguokang.com/2017/11/09/Vue.js学习笔记6/</id>
    <published>2017-11-09T05:17:33.000Z</published>
    <updated>2017-11-17T01:09:52.540Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h1><h2 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h2><p>可以用<code>v-on</code>指令监听 DOM 事件来触发一些 JavaScript 代码。</p><a id="more"></a><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-1"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"counter += 1"</span>&gt;</span>增加 1<span class="tag">&lt;/<span class="name">buttun</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>这个按钮被点击了 &#123;&#123; counter &#125;&#125; 次。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> example1 = <span class="keyword">new</span> Vue(&#123;</div><div class="line">  el: <span class="string">'#example-1'</span>,</div><div class="line">    data: &#123;</div><div class="line">      counter: <span class="number">0</span></div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><h2 id="方法事件处理器"><a href="#方法事件处理器" class="headerlink" title="方法事件处理器"></a>方法事件处理器</h2><p>许多事件处理的逻辑都很复杂，所以直接把 JavaScript 代码写在<code>v-on</code>指令中是不可行的。因此<code>v-on</code>可以接收一个定义的方法来调用。</p><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-2"</span>&gt;</span></div><div class="line">  <span class="comment">&lt;!-- `greet` 是在下面定义的方法名 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"greet"</span>&gt;</span>Greet<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> example2 = <span class="keyword">new</span> Vue(&#123;</div><div class="line">  el: <span class="string">'#example-2'</span>,</div><div class="line">  data: &#123;</div><div class="line">    name: <span class="string">'Vue.js'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// 在 `methods` 对象中定义方法</span></div><div class="line">  methods: &#123;</div><div class="line">    greet: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</div><div class="line">      <span class="comment">// `this` 在方法里指向当前 Vue 实例</span></div><div class="line">      alert(<span class="string">'Hello'</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>)</div><div class="line">      <span class="comment">// `event` 是原生 DOM 事件</span></div><div class="line">      <span class="keyword">if</span> (event) &#123;</div><div class="line">        alert(event.target.tagName)</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 也可以使用 JavaScript 直接调用方法</span></div><div class="line">example2.greet() <span class="comment">// =&gt; 'Hello Vue.js'</span></div></pre></td></tr></table></figure><h2 id="内联处理器里的方法"><a href="#内联处理器里的方法" class="headerlink" title="内联处理器里的方法"></a>内联处理器里的方法</h2><p>除了直接绑定到一个方法，也可以用内联 JavaScript 语句：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-3"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"say('h1')"</span>&gt;</span>Say hi<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"say('what')"</span>&gt;</span>Say what<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  el: <span class="string">'#example-3'</span>,</div><div class="line">  methods: &#123;</div><div class="line">    say: <span class="function"><span class="keyword">function</span> (<span class="params">message</span>) </span>&#123;</div><div class="line">      alert(message)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>有时需要在内联语句处理器中访问原生 DOM 事件。可以使用特殊变量<code>$event</code>把它传入方法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"warn('Form cannot be submitted yet.', $event)"</span>&gt;</span></div><div class="line">  Submit</div><div class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ...</span></div><div class="line">methods: &#123;</div><div class="line">  warn: <span class="function"><span class="keyword">function</span> (<span class="params">message, event</span>) </span>&#123;</div><div class="line">    <span class="comment">// 现在我们可以访问原生事件对象</span></div><div class="line">    <span class="keyword">if</span> (event) event.preventDefault()</div><div class="line">    alert(message)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h2><p>在事件处理程序中调用<code>event.preventDefault()</code>或<code>event.stopPropagation()</code>是非常常见的需求。尽管我们可以在 methods 中轻松实现这点，但更好的方式是：methods 只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。</p><p>为了解决这个问题，Vue.js 为<code>v-on</code>提供了事件修饰符。通过由点 (.) 表示的指令后缀来调用修饰符。</p><ul><li><code>.stop</code>    </li><li><code>.prevent</code></li><li><code>.capture</code></li><li><code>.self</code></li><li><code>.once</code></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 阻止单击事件冒泡 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 提交事件不再重载页面 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">"onSubmit"</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 修饰符可以串联 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:click.stop.prevent</span>=<span class="string">"doThat"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 只有修饰符 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.capture</span>=<span class="string">"doThis"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 只当事件在该元素本身（比如不是子元素）触发时触发回调 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.self</span>=<span class="string">"doThat"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p><strong>NOTE:</strong>使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用<code>@click.prevent.self</code>会阻止所有的点击，而<code>@click.self.prevent</code>只会阻止元素上的点击。</p><h2 id="键值修饰符"><a href="#键值修饰符" class="headerlink" title="键值修饰符"></a>键值修饰符</h2><p>在监听键盘事件时，我们经常需要监测常见的键值。Vue 允许为<code>v-on</code>在监听键盘事件时添加关键修饰符：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 只有在 keyCode 是 13时调用 vm.submit() --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.13</span>=<span class="string">"submit"</span>&gt;</span></div></pre></td></tr></table></figure><p>记住所有的 keyCode 比较困难，所有 Vue 为最常用的按键提供了别名：</p><ul><li>.enter</li><li>.tab</li><li>.delete(捕获“删除”和“退格”键)</li><li>.esc</li><li>.space</li><li>.up</li><li>.down</li><li>.left</li><li>.right</li></ul><p>可以通过全局<code>config.keyCodes</code>对象<strong>自定义键值修饰符别名</strong>：</p><p><code>Vue.config.keyCodes.f1 =112</code> （可以使用<code>v-on:keyup.f1</code>）</p><h3 id="自动匹配按键修饰符"><a href="#自动匹配按键修饰符" class="headerlink" title="自动匹配按键修饰符"></a>自动匹配按键修饰符</h3><h2 id="系统修饰键"><a href="#系统修饰键" class="headerlink" title="系统修饰键"></a>系统修饰键</h2><h3 id="exat修饰符"><a href="#exat修饰符" class="headerlink" title=".exat修饰符"></a><code>.exat</code>修饰符</h3><p><code>.exact</code>修饰符应与其他系统修饰符组合使用，以指示处理程序只在精确匹配该按键组合时触发。</p><h3 id="鼠标按钮修饰符"><a href="#鼠标按钮修饰符" class="headerlink" title="鼠标按钮修饰符"></a>鼠标按钮修饰符</h3><ul><li>.left</li><li>.right</li><li>.middle</li></ul><h2 id="为什么在-HTML-中监听事件？"><a href="#为什么在-HTML-中监听事件？" class="headerlink" title="为什么在 HTML 中监听事件？"></a>为什么在 HTML 中监听事件？</h2><p>使用<code>v-on</code>有几个好处：</p><ol><li><p>扫一眼 HTML 模板便能轻松定位在 JavaScript 代码里对应的方法。</p></li><li><p>因为你无须在 JavaScript 里手动绑定事件，你的 ViewModel 代码可以是非常纯粹的逻辑，和 DOM 完全解耦，更易于测试。</p></li><li><p>当一个 ViewModel 被销毁时，所有的事件处理器都会自动被删除。你无须担心如何自己清理它们。</p></li></ol><h1 id="表单输入绑定"><a href="#表单输入绑定" class="headerlink" title="表单输入绑定"></a>表单输入绑定</h1><h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><p>你可以用<code>v-model</code>指令在表单控件元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但<code>v-model</code>本质上不过是语法糖，它负责监听用户的输入事件以更新数据，并特别处理一些极端的例子。</p><p><strong>NOTE:</strong><code>v-model</code>会忽略所有表单元素的<code>value</code>、<code>checked</code>、<code>selected</code>特性的初始值。因为它会选择 Vue 实例数据来作为具体的值。你应该通过 JavaScript 在组件的<code>data</code>选项中声明初始值。另外，<code>v-model</code>不会在ime（输入法）输入中得到更新。如果你想实现更新，请使用<code>input</code>事件。</p><h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"message"</span> <span class="attr">placeholder</span>=<span class="string">"edit me"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Message is: &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure><h3 id="多行文本"><a href="#多行文本" class="headerlink" title="多行文本"></a>多行文本</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Multiline message is:<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"white-space: pre-line;"</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">v-model</span>=<span class="string">"message"</span> <span class="attr">placeholder</span>=<span class="string">"add multiple lines"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></div></pre></td></tr></table></figure><p><strong>NOTE:</strong>在文本区域插值 (<code>&lt;textarea&gt;&lt;/textarea&gt;</code>标签中间) 并不会生效，应用<code>v-model</code>来代替。</p><h3 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h3><p>单个勾选框，逻辑值：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"checkbox"</span> <span class="attr">v-model</span>=<span class="string">"checked"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"checkbox"</span>&gt;</span>&#123;&#123; checked &#125;&#125;<span class="tag">&lt;/<span class="name">label</span>&gt;</span></div></pre></td></tr></table></figure><p>多个勾选框，绑定到同一个数组：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-3"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"jack"</span> <span class="attr">value</span>=<span class="string">"Jack"</span> <span class="attr">v-model</span>=<span class="string">"checkedNames"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"jack"</span>&gt;</span>Jack<span class="tag">&lt;/<span class="name">label</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"john"</span> <span class="attr">value</span>=<span class="string">"John"</span> <span class="attr">v-model</span>=<span class="string">"checkedNames"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"john"</span>&gt;</span>John<span class="tag">&lt;/<span class="name">label</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"mike"</span> <span class="attr">value</span>=<span class="string">"Mike"</span> <span class="attr">v-model</span>=<span class="string">"checkedNames"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"mike"</span>&gt;</span>Mike<span class="tag">&lt;/<span class="name">label</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Checked names: &#123;&#123; checkedNames &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  el: <span class="string">'#example-3'</span>,</div><div class="line">  data: &#123;</div><div class="line">    checkedNames: []</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><h3 id="单选按钮"><a href="#单选按钮" class="headerlink" title="单选按钮"></a>单选按钮</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-4"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">id</span>=<span class="string">"one"</span> <span class="attr">value</span>=<span class="string">"One"</span> <span class="attr">v-model</span>=<span class="string">"picked"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"one"</span>&gt;</span>One<span class="tag">&lt;/<span class="name">label</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">id</span>=<span class="string">"two"</span> <span class="attr">value</span>=<span class="string">"Two"</span> <span class="attr">v-model</span>=<span class="string">"picked"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"two"</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">label</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Picked: &#123;&#123; picked &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  el: <span class="string">'#example-4'</span>,</div><div class="line">  data: &#123;</div><div class="line">    picked: <span class="string">''</span></div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><h3 id="选择列表"><a href="#选择列表" class="headerlink" title="选择列表"></a>选择列表</h3><p>单选列表：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-5"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"selected"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">disabled</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span>请选择<span class="tag">&lt;/<span class="name">option</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>A<span class="tag">&lt;/<span class="name">option</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>B<span class="tag">&lt;/<span class="name">option</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>C<span class="tag">&lt;/<span class="name">option</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Selected: &#123;&#123; selected &#125;&#125;<span class="tag">&lt;/<span class="name">sapn</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  el: <span class="string">'#example-5'</span>,</div><div class="line">  data: &#123;</div><div class="line">    selected: <span class="string">''</span></div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p><strong>NOTE:</strong>如果<code>v-model</code>表达初始的值不匹配任何的选项，<code>&lt;select&gt;</code>元素就会以“未选中”的状态渲染。在 iOS 中，这会使用户无法选择第一个选项，因为这样的情况下，iOS 不会引发 change 事件。因此，像以上提供<strong><code>disabled</code>选项</strong>是建议的做法。</p><p>多选列表（绑定到一个数组）：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-6"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"selected"</span> <span class="attr">multiple</span> <span class="attr">style</span>=<span class="string">"width: 50px;"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>A<span class="tag">&lt;/<span class="name">option</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>B<span class="tag">&lt;/<span class="name">option</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>C<span class="tag">&lt;/<span class="name">option</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span> </div><div class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Selected: &#123;&#123; selected &#125;&#125;<span class="tag">&lt;/<span class="name">sapn</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  el: <span class="string">'#example-6'</span>,</div><div class="line">  data: &#123;</div><div class="line">    selected: []</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>动态选项，用<code>v-for</code>渲染：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"selected"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">v-for</span>=<span class="string">"option in options"</span> <span class="attr">v-bind:value</span>=<span class="string">"option.value"</span>&gt;</span></div><div class="line">    &#123;&#123; option.text &#125;&#125;</div><div class="line">  <span class="tag">&lt;/<span class="name">option</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Selected: &#123;&#123; selected &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  el: <span class="string">'...'</span>,</div><div class="line">  data: &#123;</div><div class="line">    selected: <span class="string">'A'</span>,</div><div class="line">    options: [</div><div class="line">      &#123; <span class="attr">text</span>: <span class="string">'One'</span>, <span class="attr">value</span>: <span class="string">'A'</span> &#125;,</div><div class="line">      &#123; <span class="attr">text</span>: <span class="string">'Two'</span>, <span class="attr">value</span>: <span class="string">'B'</span> &#125;,</div><div class="line">      &#123; <span class="attr">text</span>: <span class="string">'Three'</span>, <span class="attr">value</span>: <span class="string">'C'</span> &#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><h2 id="值绑定"><a href="#值绑定" class="headerlink" title="值绑定"></a>值绑定</h2><p>对于单选按钮，勾选框及选择列表选项，<code>v-model</code>绑定的 value 通常是静态字符串 (对于勾选框是逻辑值):</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 当选中时，`selected` 为字符串 "abc" --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"selected"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"abc"</span>&gt;</span>ABC<span class="tag">&lt;/<span class="name">option</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></div></pre></td></tr></table></figure><p>但是有时我们想绑定 value 到 Vue 实例的一个动态属性上，这时可以用<code>v-bind</code>实现，并且这个属性的值可以不是字符串。就如同上个例子的<code>v-bind:value=&quot;option.value&quot;</code>。</p><h3 id="复选框-1"><a href="#复选框-1" class="headerlink" title="复选框"></a>复选框</h3><h3 id="单选按钮-1"><a href="#单选按钮-1" class="headerlink" title="单选按钮"></a>单选按钮</h3><p>###选择列表的选项</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"selected"</span>&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 内联对象字面量 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">v-bind:value</span>=<span class="string">"&#123; number: 123 &#125;"</span>&gt;</span>123<span class="tag">&lt;/<span class="name">option</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typeof</span> vm.selected  <span class="comment">// =&gt; 'object'</span></div><div class="line">vm.selected.number  <span class="comment">// =&gt; 123</span></div></pre></td></tr></table></figure><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><h3 id="lazy"><a href="#lazy" class="headerlink" title=".lazy"></a>.lazy</h3><p>在默认情况下，<code>v-model</code>在<code>input</code>事件中同步输入框中的值与数据（除了上述 IME 部分），但你可以添加一个修饰符<code>lazy</code>，从而转变为在<code>change</code>事件中同步：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 在 "change" 而不是 "input" 事件中更新 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.lazy</span>=<span class="string">"msg"</span>&gt;</span></div></pre></td></tr></table></figure><h3 id="number"><a href="#number" class="headerlink" title=".number"></a>.number</h3><p>如果想自动将用户的输入值转为 Number 类型 (如果原值的转换结果为 NaN 则返回原值)，可以添加一个修饰符<code>number</code>给<code>v-model</code>来处理输入值：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.number</span>=<span class="string">"age"</span> <span class="attr">type</span>=<span class="string">"number"</span>&gt;</span></div></pre></td></tr></table></figure><h3 id="trim"><a href="#trim" class="headerlink" title=".trim"></a>.trim</h3><p>如果要自动过滤用户输入的首尾空格，可以添加<code>trim</code>修饰符到<code>v-model</code>上过滤输入：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.trim</span>=<span class="string">"msg"</span>&gt;</span></div></pre></td></tr></table></figure><h2 id="v-model-与组件"><a href="#v-model-与组件" class="headerlink" title="v-model 与组件"></a>v-model 与组件</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;事件处理&quot;&gt;&lt;a href=&quot;#事件处理&quot; class=&quot;headerlink&quot; title=&quot;事件处理&quot;&gt;&lt;/a&gt;事件处理&lt;/h1&gt;&lt;h2 id=&quot;监听事件&quot;&gt;&lt;a href=&quot;#监听事件&quot; class=&quot;headerlink&quot; title=&quot;监听事件&quot;&gt;&lt;/a&gt;监听事件&lt;/h2&gt;&lt;p&gt;可以用&lt;code&gt;v-on&lt;/code&gt;指令监听 DOM 事件来触发一些 JavaScript 代码。&lt;/p&gt;
    
    </summary>
    
      <category term="Learning" scheme="http://huguokang.com/categories/Learning/"/>
    
    
      <category term="Vue.js" scheme="http://huguokang.com/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js学习笔记5</title>
    <link href="http://huguokang.com/2017/11/09/Vue.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05/"/>
    <id>http://huguokang.com/2017/11/09/Vue.js学习笔记5/</id>
    <published>2017-11-09T00:05:30.000Z</published>
    <updated>2017-11-09T05:06:40.009Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h1><h2 id="用v-for把一个数组对应为一个元素"><a href="#用v-for把一个数组对应为一个元素" class="headerlink" title="用v-for把一个数组对应为一个元素"></a>用<code>v-for</code>把一个数组对应为一个元素</h2><p><code>v-for</code>指令需要使用<code>item in items</code>形式的特殊用法，<code>items</code>是源数据数组，<code>item</code>是数组元素迭代的别名。</p><a id="more"></a><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"example-1"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span>&gt;</span></div><div class="line">    &#123;&#123; item.message &#125;&#125;</div><div class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure><hr><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> example1 = <span class="keyword">new</span> Vue(&#123;</div><div class="line">  el: <span class="string">'#example-1'</span>,</div><div class="line">  data: &#123;</div><div class="line">    items: [</div><div class="line">      &#123; <span class="attr">message</span>: <span class="string">'Foo'</span> &#125;,</div><div class="line">      &#123; <span class="attr">message</span>: <span class="string">'Bar'</span> &#125;</div><div class="line">    ]</div><div class="line">  &#125;  </div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>在<code>v-for</code>块中，我们拥有对父作用域属性的完全访问权限。<code>v-for</code>还支持一个可选的第二个参数为当前项的索引。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"example-2"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(item,index) in items"</span>&gt;</span></div><div class="line">    &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125;</div><div class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure><hr><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> example2 = <span class="keyword">new</span> Vue(&#123;</div><div class="line">  el: <span class="string">'#example-2'</span>,</div><div class="line">  data: &#123;</div><div class="line">    parentMessage: <span class="string">'Parent'</span>,</div><div class="line">    items: [</div><div class="line">      &#123; <span class="attr">message</span>: <span class="string">'Foo'</span> &#125;,</div><div class="line">      &#123; <span class="attr">message</span>: <span class="string">'Bar'</span> &#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>可以用<code>of</code>替代<code>in</code>作为分隔符</p><h2 id="一个对象的v-for"><a href="#一个对象的v-for" class="headerlink" title="一个对象的v-for"></a>一个对象的<code>v-for</code></h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"v-for-object"</span> <span class="attr">class</span>=<span class="string">"demo"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"value in object"</span>&gt;</span></div><div class="line">    &#123;&#123; value &#125;&#125;</div><div class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure><hr><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  el: <span class="string">'#v-for-object'</span>,</div><div class="line">  data: &#123;</div><div class="line">    object: &#123;</div><div class="line">      firstName: <span class="string">'John'</span>,</div><div class="line">      lastName: <span class="string">'Doe'</span>,</div><div class="line">      age: <span class="number">30</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>也可以提供第二个的参数为键名：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(value,key) in object"</span>&gt;</span></div><div class="line">  &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p>第三个参数为索引：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(value,key,index) in object"</span>&gt;</span></div><div class="line">  &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p><strong>NOTE:</strong>在遍历对象时，是按<code>object.key()</code>的结果遍历，不能保证它的结果在不同的 JavaScript 引擎下是一致的。</p><p><strong>object.keys()</strong>方法会返回一个由一个给定对象的<strong>自身可枚举属性</strong>组成的数组，数组中的属性排列顺序和使用<code>for...in</code>循环遍历该对象时返回的顺序一致（两者的主要区别是一个<code>for...in</code>循环还会枚举其原型链上的属性）。</p><h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><p>当 Vue.js 用<code>v-for</code>正在更新已渲染过的元素列表时，它默认用“<strong>就地复用</strong>”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处每个元素，并且确保它在特定索引下显示已经被渲染过的每个元素。</p><p>这个默认的模式是高效的，但是只适用于<code>不依赖子组件状态或临时 DOM 状态（例如：表单输入值）的列表渲染输出</code>。</p><p>为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。理想的 key 值是每项都有的且唯一的 id。它的工作方式类似一个属性，所以你需要用<code>v-bind</code>来绑定动态值：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 内容 --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p>建议尽可能在使用<code>v-for</code>时提供<code>key</code>。它是 Vue 识别节点的一个通用机制。</p><h2 id="数组更新检测"><a href="#数组更新检测" class="headerlink" title="数组更新检测"></a>数组更新检测</h2><h3 id="变异方法"><a href="#变异方法" class="headerlink" title="变异方法"></a>变异方法</h3><p>Vue 包含一组观察数组的变异方法，所以它们将会触发视图更新。</p><ul><li>push() 向数组的末尾添加一个或多个元素并返回新的长度。</li><li>pop() 删除数组的最后一个元素并返回删除的元素。</li><li>shift() 删除数组的第一个元素并返回删除的元素。</li><li>unshift() 向数组的开头添加一个或多个元素并返回新的长度。</li><li>splice() 指定位置插入、删除或替换数组的元素。</li><li>sort() 对数组的元素进行排序。</li><li>reverse() 颠倒数组中元素的顺序。  </li></ul><h3 id="替换数组"><a href="#替换数组" class="headerlink" title="替换数组"></a>替换数组</h3><p>变异方法 (mutation method)，顾名思义，会改变被这些方法调用的原始数组。相比之下，也有非变异 (non-mutating method) 方法，例如：<code>filter()</code>、<code>concat()</code>和<code>slice()</code> 。这些不会改变原始数组，但总是返回一个新数组。当使用非变异方法时，可以用新数组替换旧数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">example1.items = example.items.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> item.message.match(<span class="regexp">/Foo/</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure><ul><li>filter() 创建一个新的数组，其包含所有通过所提供函数实现的测试的所有元素。</li><li>concat() 连接两个或多个数组，返回一个新的数组。</li><li>slice() 提取数组中的某个部分，返回一个新的数组。array.slice(start,end(可选，新数组不包括end))</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>由于 JavaScript 的限制，Vue <strong>不能检测以下变动的数组</strong>：</p><ol><li>当你利用索引直接设置一个项时，例如：<code>vm.items[indexOfItem] = newValue</code></li><li>当你修改数组的长度时，例如：<code>vm.items.length = newLength</code></li></ol><p>解决第一类问题的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 第一个方法 Vue.set</span></div><div class="line">Vue.set(example1.items, indexOfItem, newValue)</div><div class="line"></div><div class="line"><span class="comment">// 第二个方法 Array.prototype.splice，参数对应的是起始项，要删除的个数，添加的项</span></div><div class="line">example1.items.splice(indexOfItem, <span class="number">1</span>, newValue)</div></pre></td></tr></table></figure><p>解决第二个类问题的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">example1.items.splice(newLength) <span class="comment">// Vue 的 splice() 可以这样</span></div></pre></td></tr></table></figure><h2 id="对象更改检测注意事项"><a href="#对象更改检测注意事项" class="headerlink" title="对象更改检测注意事项"></a>对象更改检测注意事项</h2><p>还是由于 JavaScript 的限制，Vue <strong>不能检测对象属性的添加或删除</strong>。<br>对于已经创建的实例，Vue 不能动态添加根级别的响应式属性。但是，可以使用<code>Vue.set(object, key, value)</code>方法向嵌套对象添加响应式属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</div><div class="line">  data: &#123;</div><div class="line">    userProfile: &#123;</div><div class="line">      name: <span class="string">'Anika'</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>你可以添加一个新的<code>age</code>属性到嵌套的<code>userProfile</code>对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Vue.set(vm.userProfile,<span class="string">'age'</span>,<span class="number">27</span>)</div></pre></td></tr></table></figure><p>你还可以使用<code>vm.$set</code>实例方法，它只是全局<code>Vue.set</code>的别名：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.$set(<span class="keyword">this</span>.userProfile,<span class="string">'age'</span>,<span class="number">27</span>)</div></pre></td></tr></table></figure><p>有时你可能需要为已有对象赋予多个新属性，比如使用<code>Object.assign()</code>或<code>_.extend()</code>。在这种情况下，你应该用两个对象的属性创建一个新的对象。所以，如果你想添加新的响应式属性，不要像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.assign(<span class="keyword">this</span>.userProfile,&#123;</div><div class="line">  age: <span class="number">27</span>,</div><div class="line">  favoriteColor: <span class="string">"Vue Green"</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>你应该这样做：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.userProfile = <span class="built_in">Object</span>.assign(&#123;&#125;, <span class="keyword">this</span>.userProfile, &#123;</div><div class="line">  age: <span class="number">27</span>,</div><div class="line">  favoriteColor: <span class="string">'Vue Green'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure><h2 id="显示过滤-排序结果"><a href="#显示过滤-排序结果" class="headerlink" title="显示过滤/排序结果"></a>显示过滤/排序结果</h2><p>有时，我们想要显示一个数组的过滤或排序副本，而不实际改变或重置原始数据。在这种情况下，可以创建返回过滤或排序数组的计算属性。</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"n in evenNumbers"</span>&gt;</span>&#123;&#123; n &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div></pre></td></tr></table></figure><hr><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">data: &#123;</div><div class="line">  numbers: [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ]</div><div class="line">&#125;,</div><div class="line">computed: &#123;</div><div class="line">  evenNumbers: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.numbers.filter(<span class="function"><span class="keyword">function</span> (<span class="params">number</span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> number % <span class="number">2</span> === <span class="number">0</span></div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在计算属性不适用的情况下（例如，在嵌套<code>v-for</code>循环中）你可以使用一个 method 方法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"n in even(numbers)"</span>&gt;</span>&#123;&#123; n &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div></pre></td></tr></table></figure><hr><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">data: &#123;</div><div class="line">  numbers: [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</div><div class="line">&#125;,</div><div class="line">methods: &#123;</div><div class="line">  even: <span class="function"><span class="keyword">function</span> (<span class="params">numbers</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> numbers.filter(<span class="function"><span class="keyword">function</span> (<span class="params">number</span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> number % <span class="number">2</span> === <span class="number">0</span></div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="一段取值范围的v-for"><a href="#一段取值范围的v-for" class="headerlink" title="一段取值范围的v-for"></a>一段取值范围的<code>v-for</code></h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-for</span>=<span class="string">"n in 10"</span>&gt;</span>&#123;&#123; n &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p>结果是：1 2 3 4 5 6 7 8 9 10</p><h2 id="v-for-with-v-if"><a href="#v-for-with-v-if" class="headerlink" title="v-for with v-if"></a>v-for with v-if</h2><p>当它们处于同一节点，<code>v-for</code>的优先级比<code>v-if</code>更高，这意味着<code>v-if</code>将分别重复运行于每个 <code>v-for</code>循环中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"todo in todos"</span> <span class="attr">v-if</span>=<span class="string">"!todo.isComplete"</span>&gt;</span></div><div class="line">  &#123;&#123; todo &#125;&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div></pre></td></tr></table></figure><p>上面的 todos 中只有没有完成的 todo 才能被传递。</p><p>而如果你的目的是有条件地跳过循环的执行，那么可以将 v-if 置于外层元素 (或 <code>&lt;template&gt;</code>)上。如： </p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">v-if</span>=<span class="string">"todos.length"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"todo in todos"</span>&gt;</span></div><div class="line">    &#123;&#123; todo &#125;&#125;</div><div class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-else</span>&gt;</span>No todos left!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure><h2 id="一个组件的-v-for"><a href="#一个组件的-v-for" class="headerlink" title="一个组件的 v-for"></a>一个组件的 v-for</h2><p>等我看完组件再回来       </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;列表渲染&quot;&gt;&lt;a href=&quot;#列表渲染&quot; class=&quot;headerlink&quot; title=&quot;列表渲染&quot;&gt;&lt;/a&gt;列表渲染&lt;/h1&gt;&lt;h2 id=&quot;用v-for把一个数组对应为一个元素&quot;&gt;&lt;a href=&quot;#用v-for把一个数组对应为一个元素&quot; class=&quot;headerlink&quot; title=&quot;用v-for把一个数组对应为一个元素&quot;&gt;&lt;/a&gt;用&lt;code&gt;v-for&lt;/code&gt;把一个数组对应为一个元素&lt;/h2&gt;&lt;p&gt;&lt;code&gt;v-for&lt;/code&gt;指令需要使用&lt;code&gt;item in items&lt;/code&gt;形式的特殊用法，&lt;code&gt;items&lt;/code&gt;是源数据数组，&lt;code&gt;item&lt;/code&gt;是数组元素迭代的别名。&lt;/p&gt;
    
    </summary>
    
      <category term="Learning" scheme="http://huguokang.com/categories/Learning/"/>
    
    
      <category term="Vue.js" scheme="http://huguokang.com/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js学习笔记4</title>
    <link href="http://huguokang.com/2017/11/07/Vue.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04/"/>
    <id>http://huguokang.com/2017/11/07/Vue.js学习笔记4/</id>
    <published>2017-11-07T05:36:32.000Z</published>
    <updated>2017-11-08T01:28:32.435Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Class-与-Style-绑定"><a href="#Class-与-Style-绑定" class="headerlink" title="Class 与 Style 绑定"></a>Class 与 Style 绑定</h1><p>操作元素的 class 列表和内联样式是数据绑定的一个常见需求。因为它们都是属性，所以我们可以用<code>v-bind</code>处理它们：只需要通过表达式计算出字符串结果即可。不过，字符串拼接麻烦且易错。对此，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组。</p><a id="more"></a><h2 id="绑定-HTML-Class"><a href="#绑定-HTML-Class" class="headerlink" title="绑定 HTML Class"></a>绑定 HTML Class</h2><h3 id="对象语法"><a href="#对象语法" class="headerlink" title="对象语法"></a>对象语法</h3><p>我们可以传给<code>v-bind:class</code>一个对象来动态地切换 class ：</p><pre><code>// HTML&lt;div v-bind:class=&quot;{ active: isActive }&quot;&gt;&lt;/div&gt;</code></pre><p><code>active</code>这个 class 存在与否取决于数据属性<code>isActive</code>的<code>truthiness</code>。</p><p>你可以在对象中传入更多属性来动态切换多个 class 。此外，<code>v-bind:class</code>指令也可以与普通的 class 属性共存。</p><pre><code>// HTML&lt;div class=&quot;static&quot;     v-bind:class=&quot;{ active: isActive, &apos;text-danger&apos;: hasError }&quot;&gt;&lt;/div&gt;</code></pre><p>下面的 data :</p><pre><code>// JSdata: {  isActive: true,  hasError: false}</code></pre><p>结果渲染为：</p><pre><code>// HTML&lt;div class=&quot;static active&quot;&gt;&lt;/div&gt;</code></pre><p>绑定的数据对象不必内联定义在模版里：</p><pre><code>// HTML&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;</code></pre><hr><pre><code>// JSdata: {  classObject: {    active: true,    &apos;text-danger&apos;: false  }}</code></pre><p>渲染的结果和上面一样。我们也可以在这里绑定一个返回对象的<strong>计算属性</strong>。这是一个常用且强大的模式：</p><pre><code>// HTML&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;</code></pre><hr><pre><code>// JSdata: {  isActive: true,  error: null},computed: {  classObject: function () {    return {      active: this.isActive &amp;&amp; !this.error,      &apos;text-danger&apos;: this.error &amp;&amp; this.error.type === &apos;fatal&apos;    }  }}</code></pre><h3 id="数组语法"><a href="#数组语法" class="headerlink" title="数组语法"></a>数组语法</h3><p>我们可以把一个数组传递给<code>v-bind:class</code>以应用一个 class 列表：</p><pre><code>// HTML&lt;div v-bind:class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;</code></pre><hr><p>   // JS<br>   data: {<br>     activeClass: ‘active’,<br>     errorClass: ‘text-danger’<br>   }</p><p>渲染为：</p><pre><code>// HTML&lt;div class=&quot;active text-danger&quot;&gt;&lt;/div&gt;</code></pre><p>如果你也想根据条件切换列表中的 class ，可以用三元表达式：</p><pre><code>// HTML&lt;div v-bind:class=&quot;[isActive ? activeClass : &apos;&apos;, errorClass]&quot;&gt;&lt;/div&gt;</code></pre><p>当有多个条件 class 时这样写有些繁琐。所以在数组语法中也可以使用对象语法：</p><pre><code>// HTML&lt;div v-bind:class=&quot;[{ active: isActive }, errorClass]&quot;&gt;&lt;/div&gt;</code></pre><h3 id="用在组件上"><a href="#用在组件上" class="headerlink" title="用在组件上"></a>用在组件上</h3><h2 id="绑定内联样式"><a href="#绑定内联样式" class="headerlink" title="绑定内联样式"></a>绑定内联样式</h2><h3 id="对象语法-1"><a href="#对象语法-1" class="headerlink" title="对象语法"></a>对象语法</h3><p><code>v-bind:style</code>的对象语法看着非常像 CSS ，但其实是一个 JavaScript 对象。CSS 属性名可以用驼峰式或短横线分隔（用单引号括起来）来命名：</p><pre><code>// HTML&lt;div v-bind:style=&quot;{ color: activeColor, fontSize: fontSize + &apos;px&apos; }&quot;&gt;&lt;/div&gt;</code></pre><hr><pre><code>data: {  activeColor: &apos;red&apos;,  fontSize: 30}</code></pre><p>直接绑定到一个样式对象会让模板更清晰：</p><pre><code>// HTML&lt;div v-bind:style=&quot;styleObject&quot;&gt;&lt;/div&gt;</code></pre><hr><pre><code>// JSdata: {  styleObject: {    color: &apos;red&apos;,    fontSize: &apos;13px&apos;  }}</code></pre><p>同样的，对象语法常常结合返回对象的计算属性使用。</p><h3 id="数组语法-1"><a href="#数组语法-1" class="headerlink" title="数组语法"></a>数组语法</h3><p><code>v-bind:style</code>的数组语法可以将多个样式对象应用到同一个元素上：</p><pre><code>// HTML&lt;div v-bind:style=&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;/div&gt;</code></pre><h3 id="自动添加前缀"><a href="#自动添加前缀" class="headerlink" title="自动添加前缀"></a>自动添加前缀</h3><p>当<code>v-bind:style</code>使用需要添加浏览器引擎前缀的 CSS 属性时，Vue.js 会自动侦测并添加相应的前缀。</p><h3 id="多重值"><a href="#多重值" class="headerlink" title="多重值"></a>多重值</h3><p>从 2.3.0 起你可以为<code>style</code>绑定中的属性提供一个包含多个值的数组，常用于提供多个带前缀的值，例如：</p><pre><code>// HTML&lt;div :style=&quot;{ display: [&apos;-webkit-box&apos;, &apos;-ms-flebox&apos;, &apos;flex&apos;] }&quot;&gt;&lt;/div&gt;</code></pre><p>这样写只会渲染数组中最后一个被浏览器支持的值。</p><h1 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h1><h2 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h2><p>在字符串模板中，比如 Handlebars ，我们得像这样写一个条件块：</p><pre><code>// HTML&lt;!-- Handlebars 模板 --&gt;{{#if ok}}  &lt;h1&gt;Yes&lt;/h1&gt;{{/if}}</code></pre><p>在 Vue 中。我们使用<code>v-if</code>指令实现同样的功能：</p><pre><code>// HTML&lt;h1 v-if=&quot;ok&quot;&gt;Yes&lt;/h1&gt;  </code></pre><p>也可以用<code>v-esle</code>添加一个“else块”：</p><pre><code>// HTML&lt;h1 v-if=&quot;ok&quot;&gt;Yes&lt;/h1&gt;&lt;h1 v-else&gt;No&lt;/h1&gt;</code></pre><h3 id="在-template-元素上使用-v-if-条件渲染分组"><a href="#在-template-元素上使用-v-if-条件渲染分组" class="headerlink" title="在 template 元素上使用 v-if 条件渲染分组"></a>在 template 元素上使用 v-if 条件渲染分组</h3><p>因为<code>v-if</code>是一个指令，所以必须将它添加到一个元素上。但是如果想切换多个元素呢？此时可以把一个<code>&lt;template&gt;</code>元素当做不可见的包裹元素，并在上面使用<code>v-if</code>。最终的渲染结果将不包含<code>&lt;template&gt;</code>元素。</p><pre><code>// HTML&lt;template v-if=&quot;ok&quot;&gt;  &lt;h1&gt;Title&lt;/h1&gt;  &lt;p&gt;Paragraph 1&lt;/p&gt;  &lt;p&gt;Paragraph 2&lt;/p&gt;&lt;/template&gt;</code></pre><h3 id="v-else"><a href="#v-else" class="headerlink" title="v-else"></a>v-else</h3><p>你可以使用<code>v-else</code>指令来表示<code>v-if</code>的“else块”：</p><pre><code>// HTML&lt;div v-if=&quot;Math.random() &gt; 0.5&quot;&gt;  Now you see me&lt;/div&gt;&lt;div v-else&gt;  Now you don&apos;t&lt;/div&gt;</code></pre><p><code>v-else</code>元素必须跟在带<code>v-if</code>或者<code>v-else-if</code>的元素的后面，否则它将不会被识别。</p><h3 id="v-else-if"><a href="#v-else-if" class="headerlink" title="v-else-if"></a>v-else-if</h3><p>充当<code>v-if</code>的“else-if块”，可以连续使用</p><h3 id="用-key-管理可复用的元素"><a href="#用-key-管理可复用的元素" class="headerlink" title="用 key 管理可复用的元素"></a>用 key 管理可复用的元素</h3><p>Vue 会Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使 Vue 变得非常快之外，还有其它一些好处。例如，如果你允许用户在不同的登录方式之间切换：</p><pre><code>// HTML&lt;template v-if=&quot;loginType === &apos;username&apos;&quot;&gt;  &lt;label&gt;Username&lt;/label&gt;  &lt;input placeholder=&quot;Enter your username&quot;&gt;&lt;/template&gt;&lt;template v-else&gt;  &lt;label&gt;Email&lt;/label&gt;  &lt;input placeholder=&quot;Enter your email address&quot;&gt;&lt;/template&gt;</code></pre><p>上面的代码中切换<code>loginType</code>将不会清除用户已经输入的内容。因为两个模板使用了相同的元素，<code>&lt;input&gt;</code>仅仅替换了它的<code>placeholder</code>。</p><p>这样也不总是符合实际需求，所以 Vue 提供了一种方式来表达“这两个元素是完全独立的，不要复用它们”。只需要添加一个具有唯一值的 key 属性即可：</p><pre><code>// HTML&lt;template v-if=&quot;loginType === &apos;username&apos;&quot;&gt;  &lt;label&gt;Username&lt;/label&gt;  &lt;input placeholder=&quot;Enter your username&quot; key=&quot;username-input&quot;&gt;&lt;/template&gt;&lt;template v-else&gt;  &lt;label&gt;Email&lt;/label&gt;  &lt;input placeholder=&quot;Enter your email address&quot; key=&quot;email-input&quot;&gt;&lt;/template&gt;</code></pre><p>这样的话，每次切换时，输入框都将被重新渲染。<code>&lt;label&gt;</code>元素仍然会被高效地复用。</p><h2 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h2><p><code>v-show</code>也可以根据条件展示元素，不同的是带有<code>v-show</code>的元素始终会被渲染并保留在 DOM 中。<code>v-show</code>只是简单地切换元素的 CSS 属性<code>display</code>。</p><p><strong>NOTE:</strong><code>v-show</code>不支持<code>&lt;template&gt;</code>元素和<code>v-else</code>。</p><h2 id="v-if-vs-v-show"><a href="#v-if-vs-v-show" class="headerlink" title="v-if vs v-show"></a>v-if vs v-show</h2><p><code>v-if</code>是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</p><p><code>v-if</code>也是<strong>惰性的</strong>：如果在初始渲染时条件为假，则什么也不做直到条件第一次变为真时，才会开始渲染条件块。</p><p>相比之下，<code>v-show</code>不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</p><p>一般来说，<code>v-if</code>有更高的切换开销，而<code>v-show</code>有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用<code>v-show</code>较好；如果在运行时条件很少改变，则使用<code>v-if</code>较好。</p><h2 id="v-if-与-v-for-一起使用"><a href="#v-if-与-v-for-一起使用" class="headerlink" title="v-if 与 v-for 一起使用"></a>v-if 与 v-for 一起使用</h2><p>当<code>v-if</code>与<code>v-for</code>一起使用时，<code>v-for</code>具有更高的优先级。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Class-与-Style-绑定&quot;&gt;&lt;a href=&quot;#Class-与-Style-绑定&quot; class=&quot;headerlink&quot; title=&quot;Class 与 Style 绑定&quot;&gt;&lt;/a&gt;Class 与 Style 绑定&lt;/h1&gt;&lt;p&gt;操作元素的 class 列表和内联样式是数据绑定的一个常见需求。因为它们都是属性，所以我们可以用&lt;code&gt;v-bind&lt;/code&gt;处理它们：只需要通过表达式计算出字符串结果即可。不过，字符串拼接麻烦且易错。对此，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组。&lt;/p&gt;
    
    </summary>
    
      <category term="Learning" scheme="http://huguokang.com/categories/Learning/"/>
    
    
      <category term="Vue.js" scheme="http://huguokang.com/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js学习笔记3</title>
    <link href="http://huguokang.com/2017/11/06/Vue.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/"/>
    <id>http://huguokang.com/2017/11/06/Vue.js学习笔记3/</id>
    <published>2017-11-06T11:16:07.000Z</published>
    <updated>2017-11-07T06:45:19.254Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="计算属性和观察者"><a href="#计算属性和观察者" class="headerlink" title="计算属性和观察者"></a>计算属性和观察者</h1><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>模板内的表达式非常便利，但是设计它们的初衷是用于简单运算。所以不应该在模板中放入太多的逻辑，对于复杂逻辑，应该将其放入<strong>计算属性</strong>。</p><a id="more"></a><h3 id="基础例子"><a href="#基础例子" class="headerlink" title="基础例子"></a>基础例子</h3><pre><code>// HTML&lt;div id=&quot;example&quot;&gt;  &lt;p&gt;Original message: &quot;{{ message }}&quot;&lt;/p&gt;  &lt;p&gt;Computed reversed message: &quot;{{ reverseMessage }}&quot;&lt;/p&gt;&lt;/div&gt;</code></pre><hr><pre><code>// JSvar vm = new Vue({  el: &apos;#example&apos;,  data: {  message: &apos;Hello&apos;  },  computed: {    //计算属性的 getter    reversedMessage: function () {      //&apos;this&apos;指向 vm 实例      return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)    }  }})</code></pre><p>这里我们声明了一个计算属性 <code>reversedMessage</code>。我们提供的函数将用作属性<code>vm.reversedMessage</code>的 getter 函数。</p><p>Vue 知道<code>vm.reversedMessage</code>依赖于<code>vm.message</code>，因此<code>vm.message</code>发生改变时，所有依赖<code>vm.reversedMessage</code>的绑定也会更新。</p><h3 id="计算属性缓存-vs-方法"><a href="#计算属性缓存-vs-方法" class="headerlink" title="计算属性缓存 vs 方法"></a>计算属性缓存 vs 方法</h3><p>从表达式中调用方法可以达到同样的效果：</p><pre><code>// HTML&lt;p&gt;Reversed message: &quot;{{ reversedMessage() }}&quot;&lt;/p&gt;</code></pre><hr><pre><code>//在组件中  JSmethods: {  reversedMessage: function () {    return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)  }}</code></pre><p>我们可以将同一函数定义为方法而不是一个计算属性。结果虽然相同，但是不同的计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值。这就意味着只要<code>message</code>还没发生改变，多次访问<code>reversedMessage</code>计算属性就会立即返回之前的计算结果，而不必再次执行函数。</p><p><code>Date.now()</code>不是响应式依赖，所以下面的计算属性将不再更新：</p><pre><code>// HTMLcomputed: {  now: function () {    return Date.now()  }}</code></pre><p>相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。</p><p>我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 A ，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 A 。如果没有缓存，我们将不可避免的多次执行 A 的 getter ！</p><p>如果你不希望有缓存，请用方法来代替。</p><h3 id="计算属性-vs-侦听属性"><a href="#计算属性-vs-侦听属性" class="headerlink" title="计算属性 vs 侦听属性"></a>计算属性 vs 侦听属性</h3><p>Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：<strong>侦听属性</strong>。当你有一些数据需要随着其他数据变动而变动时，你很容易滥用<code>watch</code>。然而，使用计算属性比命令式的<code>watch</code>回调更好。下面两个比较一下：</p><p><code>&lt;div id=&quot;demo&quot;&gt;&lt;/div&gt;  //HTML</code></p><pre><code>// JSvar vm = new Vue({  el: &apos;#demo&apos;,  data: {    firstName: &apos;Foo&apos;,    lastName: &apos;Bar&apos;,    fullName: &apos;Foo Bar&apos;  },  watch: {    firstName: function (val) {      this.fullName = val + &apos; &apos; + this.lastName    },    lastName: function (val) {      this.fullName = this.firstName + &apos; &apos; + val    }  }})</code></pre><p>上面代码式命令式且重复的。将它与计算属性的版本进行比较:</p><pre><code>// JSvar vm = new Vue({  el: &apos;#demo&apos;,  data: {    firstName: &apos;Foo&apos;,    lastName: &apos;Bar&apos;  },  computed: {    fullName: function () {      return this.firstName + &apos; &apos; + this.lastName    }  }})</code></pre><h3 id="计算属性的-setter"><a href="#计算属性的-setter" class="headerlink" title="计算属性的 setter"></a>计算属性的 setter</h3><p>计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter :</p><pre><code>//...   JScomputed: {  fullName: {    // getter    get: function () {      return this.firstName + &apos; &apos; + this.lastName    },    // setter    set: function (newValue) {      var names = newValue.split(&apos; &apos;)      this.firstName = names[0]      this.lastName = name[name.length - 1]    }  }}// ...</code></pre><p>现在再运行<code>vm.fullName = &#39;John Doe&#39;</code>时，setter 会被调用。<code>vm.firstName</code>和<code>vm.lastName</code>也会相应地被更新。</p><h2 id="侦听器"><a href="#侦听器" class="headerlink" title="侦听器"></a>侦听器</h2><p>虽然计算属性在大多数情况下更合适，但有时也需要一个自定义地侦听器。这就是为什么 Vue 通过 <code>watch</code>选项提供了一个更通用地方法，来响应数据地变化。当需要在数据变化时执行异步或者开销较大的操作时，这个方式是最有用的。</p><p>例如:</p><pre><code>// HTML&lt;div id=&quot;watch-example&quot;&gt;  &lt;p&gt;    Ask a yes/no question    &lt;input v-model=&quot;qusetion&quot;&gt;  &lt;/p&gt;  &lt;p&gt;{{ answer }}&lt;/p&gt;&lt;/div&gt;</code></pre><hr><pre><code>// HTML&lt;!-- 因为 AJAX 库和通用工具的生态已经相当丰富，Vue 核心代码没有重复 --&gt;&lt;!-- 提供这些功能以保持精简，这也可以让你自由选择自己更熟悉的工具 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;var watchExampleVm = new Vue({  el: &apos;#watch-example&apos;,  data: {    question: &apos;&apos;,    answer: &apos;I cannot give you an answer until you ask a question!&apos;  },  watch: {    // 如果&apos;question&apos;发生改变，这个函数就会执行    question: function (newQuestion) {      this.answer = &apos;Waiting for you to stop typing...&apos;      this.getAnswer()    }  },  methods: {    // &apos;_.debunce&apos;是一个通过 Lodash 限制操作频率的函数。    // 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率    // AJAX 请求直到用户输入完毕才会发出。    getAnswer: _.debounce(      function () {        if (this.question.index(&apos;?&apos;) === -1) {          this.answer = &apos;Questions usually contain a question mark. ;-)&apos;          return        }        this.answer = &apos;Thinking...&apos;        var vm = this        axios.get(&apos;https://yesno.wtf/api&apos;)          .then(function (response) {            vn.answer = _.capitalize(response.data.answer)          })          .catch(function (error) {            vm.answer = &apos;Error! Could not reach the API. &apos; + error          })      },      // 这是我们为判定用户停止输入等待的毫秒数      500     )  }})</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;计算属性和观察者&quot;&gt;&lt;a href=&quot;#计算属性和观察者&quot; class=&quot;headerlink&quot; title=&quot;计算属性和观察者&quot;&gt;&lt;/a&gt;计算属性和观察者&lt;/h1&gt;&lt;h2 id=&quot;计算属性&quot;&gt;&lt;a href=&quot;#计算属性&quot; class=&quot;headerlink&quot; title=&quot;计算属性&quot;&gt;&lt;/a&gt;计算属性&lt;/h2&gt;&lt;p&gt;模板内的表达式非常便利，但是设计它们的初衷是用于简单运算。所以不应该在模板中放入太多的逻辑，对于复杂逻辑，应该将其放入&lt;strong&gt;计算属性&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Learning" scheme="http://huguokang.com/categories/Learning/"/>
    
    
      <category term="Vue.js" scheme="http://huguokang.com/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>JS正则表达式复习笔记</title>
    <link href="http://huguokang.com/2017/11/05/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://huguokang.com/2017/11/05/正则表达式/</id>
    <published>2017-11-05T13:40:50.000Z</published>
    <updated>2017-11-07T06:46:12.270Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>温故而知新，可以为师矣。对于正则表达式的学习最好的方法还是多练多回顾，复习，走起！</p><p>正则表达式（英文：Regular Expression，在代码中常简写为regex、regexp、RE）使用单个字符串来描述、匹配一系列符合某个语法规则的字符串搜索模式。它可用于所有文本搜索和文本替换的操作。简而言之，它就是通过计算机认识的语言制定的规则，能让计算机帮我们找到对应的东西。<br><a id="more"></a></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="定义正则"><a href="#定义正则" class="headerlink" title="定义正则"></a>定义正则</h2><ol><li><code>var re = new RegExp(&quot;a&quot;); //RegExp 对象，参数就是我们想要制定的规则</code></li><li><code>var re = /a/; //简写方法（推荐使用，性能更好，不能为空）</code></li></ol><h2 id="正则的常用方法"><a href="#正则的常用方法" class="headerlink" title="正则的常用方法"></a>正则的常用方法</h2><h3 id="test"><a href="#test" class="headerlink" title="test():"></a>test():</h3><p>在字符串中查找符合正则的内容，若查找到返回true，反之则返回false。  </p><p>用法：正则.test(字符串)  </p><p>例子：判断是否是数字 </p><pre><code>var str = &quot;4396&quot;;  var re = /\D/;  //  \D\代表非数字if (re.test(str)){    alert(&quot;不全是数字&quot;);} else{    alert(&quot;全是数字&quot;);}</code></pre><p>正则表达式中有很多符号，代表着不同的意思。  </p><ul><li>\s : 空格</li><li>\S : 非空格</li><li>\d : 数字</li><li>\D : 非数字</li><li>\w : 字符（字母、数字或者下划线）</li><li>\W : 非字符<br>（不罗列了，下面会根据例子依次讲一些常用的字符）</li></ul><h3 id="search"><a href="#search" class="headerlink" title="search():"></a>search():</h3><p>在字符串搜索符合正则的内容，搜索到就返回出现的位置（从0开始，如果匹配的不只是一个字母，那就只会返回第一个字母的位置），如果搜索失败就返回-1。  </p><p>用法：字符串.search(正则)  </p><p><strong>NOTE:</strong> 正则中默认区分大小写，如果想不区分大小写，就在正则的最后加修饰符<code>i</code>（ignore的缩写）。  </p><p>例子：在字符串中查找字母b，且不区分大小写</p><pre><code>var str = &quot;abcdf&quot;;var re = /B/i; //也可以写成 var re = new RegExp(&apos;B&apos;,&apos;i&apos;);alert(str.search(re));  //1</code></pre><h3 id="match"><a href="#match" class="headerlink" title="match():"></a>match():</h3><p>在字符串中搜索符合规则的内容，搜索成功就返回内容，格式为<strong>数组</strong>，失败就返回null。  </p><p>用法：字符串.match(正则)   </p><p>量词：<code>+</code>代表至少匹配一次  </p><p>全局匹配：<code>g</code>（global的缩写，正则中默认，只要搜索到符合规则的内容就会结束搜索）  </p><p>例子：找出指定格式的所有数字  </p><pre><code>var str = &quot;rng1skt2rng3skt45&quot;;var re = /\d/g;  //每次匹配至少一个数字且全局匹配，如果不是全局匹配，当找到数字1，它就会停止。加上全局匹配就会从开始到结束一直去搜索符合规则的。如果没有加号，匹配的结果就是[1,2,3,4,5] ，这并不是我们想要的。alert(str.match(re));  //[1,2,3,45]</code></pre><h3 id="replace"><a href="#replace" class="headerlink" title="replace():"></a>replace():</h3><p>查找符合正则的字符串，就替换成对应的字符串。返回替换后的内容。  </p><p>用法：字符串.replace(正则，新的字符串/回调函数)（在回调函数中，第一个参数指的是每次匹配成功的字符）  </p><p>例子：敏感词过滤。  </p><pre><code>var str = &quot;我爱北京天安门，天安门上太阳升&quot;;var re = /北京|天安门/g;var str2 = str.replace(re,&apos;*&apos;);alert(str2)  //我爱**，*上太阳升//这种只是把找到的变成了一个 * ，并不能几个字就对应几个 * 。</code></pre><p>要想实现几个字对应几个 * ，我们可以用回调函数实现。  </p><pre><code>var str = &quot;我爱北京天安门，天安门上太阳升&quot;var re = /北京|天安门/g;var str2 = str.replace(re,function(str){alert(str); //用来测试：函数的第一个参数代表每次搜索到的符合正则的字符，所以第一次str指的是北京，第二次str是天安门，第三次str是天安门var result = &apos;&apos;;for(var i=0;i&lt;str.length;i++){    result += &apos;*&apos;;}    return result;});alert(str2)  //我爱*****，***上太阳升</code></pre><h2 id="正则中的字符"><a href="#正则中的字符" class="headerlink" title="正则中的字符"></a>正则中的字符</h2><p><strong>():</strong> 小括号，叫做分组符。相当于数学里面的括号。</p><pre><code>var str = &apos;2013-6-7&apos;;var re1 = /\d-+/g;  //全局匹一个数字，横杠，横杠数量至少为1，匹配结果为：[&apos;3-&apos;,&apos;6-&apos;]var re2 = /(\d-)+/g;  //全局匹配数字，横杠，数字和横杠整体数量至少为1，匹配结果为：[&apos;3-6-&apos;]var re3 = /(\d+)(-)/g;  //全局匹配至少一个数字，匹配一个横杠，匹配结果为：[&apos;2013-&apos;,&apos;6-&apos;]</code></pre><p>正则中的每一个带小括号的项，都叫做这个正则的子项。  </p><p>例子：让2013-6-7变成2013.6.7  </p><pre><code>var str = &apos;2013-6-7&apos;;var re = /(\d+)(-)/g;str = str.replace(re,function($0,$1,$2) {//replace()中如果有子项，//第一个参数：$0 (匹配成功后的整体结果 2013-, 6-)，//第二个参数：$1 (匹配成功后的第一个分组，这里指的是 \d ，2013, 6 )，//第三个参数：$2 (匹配成功后的第二个分组，这里指的是 - ，-, -)。    return $1 + &apos;.&apos;;});alert(str);</code></pre><p>match 方法也会返回自己的子项，如下：</p><pre><code>var str = &apos;abc&apos;;var re = /(a)(b)(c)/;alert(str.match(re)); //[abc,a,b,c]//返回的是匹配结果以及每一个子项，当 match 不加 g 的时候才可以取到子项的集合</code></pre><p><strong>补充:</strong>exec() 方法和 match() 方法类似，搜索符合规则的内容，并返回内容，格式为数组。</p><p>用法：正则.exec(字符串)</p><p>属性：input //代表要匹配的字符串；index //每次匹配成功的字符串中第一个字符的位置</p><p>例子一：</p><pre><code>var testStr = &quot;now test001 test002&quot;;var re = /test(\d+)/; //不是全局匹配，只匹配一次var r = re.exec(testStr);console.log(r);//[&apos;test001&apos;,&apos;001&apos;,index:4,input:&apos;now test001 test002&apos;]//返回了包含匹配结果、子项、index属性、input属性的数组//另外 r.length = 2</code></pre><p>例子二：</p><pre><code>var testStr = &quot;now test001 test002&quot;;var re = /test(/d+)/g; //全局匹配var r = re.exec(testStr);console.log(r);//[&apos;test001&apos;,&apos;001&apos;,index:4,input:&apos;now test001 test002&apos;]//结果为啥一样，我用 while 循环，可一直匹配出这个结果，并没有接着上次匹配的位置开//始匹配。</code></pre><p><strong>[]:</strong>表示某个集合中的任意一个，比如[abc]整体代表一个字符，匹配 a b c 中的任意一个，也可以是范围，范围必须从小到大[0-9]。</p><p><strong>[^a]:</strong>整体代表一个字符，<code>^</code>写在<code>[]</code>里面的话，就代表排除的意思。</p><p>例子：匹配 HTML 标签，比如<code>&lt;div class=&quot;b&quot;&gt;hahaha&lt;/div&gt;</code>找出标签<code>&lt;div class=&quot;b&quot;&gt;&lt;/div&gt;</code></p><pre><code>var re = /&lt;[^&gt;]+&gt;/g; //匹配左括号，中间至少一个非右括号的内容（标签里面的一些东西），然后匹配右括号var re = /&lt;[\w\W]+&gt;/g;//匹配左括号，中间至少一个字符或者非字符的内容，然后匹配右括号</code></pre><p><strong>转义字符</strong></p><p>除了前面提到的六个还包括：</p><p><code>.</code> ：任意字符</p><p><code>\.</code>: 真正的点</p><p><code>\b</code> ：独立的部分（起始，结束，空格）</p><p><code>\B</code> : 非独立的部分</p><p>关于最后两个我们来看个例子：</p><pre><code>var str1 = &quot;onetwo&quot;;var str2 = &quot;one two&quot;;var re = /one\b/; //e 后面必须是独立的console.log(re.test(str1)); //falseconsole.log(re.test(str2)); //true</code></pre><p>例子：写一个用 class 名获取节点的函数</p><p>我们之前可能见过这样的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function getByClass(parent,classname) &#123;</div><div class="line">    if (parent.getElementByClassName) &#123;</div><div class="line">        return parent.getElementByClassName(classname);</div><div class="line">    &#125; else &#123;</div><div class="line">        var results = new Array(); //用来存储所有取到的 class 为 box 的元素</div><div class="line">        var elems = parent.getElementsByTagName(&quot;*&quot;);</div><div class="line">        for (var i=0;i&lt;elems.length;i++) &#123;</div><div class="line">            if (elems[i].className == classname) &#123;</div><div class="line">                results.push(elems[i]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return results;    </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这其实是存在问题的，比如它如果一个标签里面有两个 class ，或者存在相同名字的 class ，比如<code>&lt;div class=&quot;box1 box1&quot;&gt;</code>，<code>&lt;div class=&quot;box1 box2&quot;&gt;</code>它就没办法了，我们可以用正则来解决这个问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function getByClass(parent,classname) &#123;</div><div class="line">    if (parent.getElementsByClassName) &#123;</div><div class="line">        return parent.getElementsByClassName(classname);</div><div class="line">    &#125; else &#123;</div><div class="line">        var arr = [];</div><div class="line">        var aEle = parent.getElementsByTagName(&quot;*&quot;);</div><div class="line">        //var re = /\bclassname\b/;</div><div class="line">        //不能这样写，当正则需要用到参数时候，一定要用全称的写法，简写方法会把 //clasname当作一个字符串去匹配。</div><div class="line">        var re = new RegExp(&apos;\\b&apos;+classname+&apos;\\b&apos;);</div><div class="line">        //匹配的时候，classname 前面必须是起始或者空格，后面也是。</div><div class="line">        //默认匹配成功就停止，所以就算有重复的也不会再匹配进去了。</div><div class="line">        //需要注意的是，全称的方式声明正则的时候，参数是字符串类型的，所以我们用//的时候，需要保证这些特殊的字符在字符串内也能输出才行。\b本身是特殊字</div><div class="line">        //符，在字符串中无法输出，需要加反斜杠转义。</div><div class="line">        for (var i=0;i&lt;aEle.length;i++) &#123;</div><div class="line">            if (re.test(aEle[i].className)) &#123;</div><div class="line">                arr.push(aEle[i]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return arr;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>\a:</strong>表示重复的某个子项，比如：</p><p><code>\1</code> ：重复的第一个子项</p><p><code>\2</code> ：重复的第二个子项</p><pre><code>/(a)(b)(c)\1/    //匹配 abca/(a)(b)(c)\1+/   //匹配 abcaa,abcaaa···（子项 a 至少重复一次）/(a)(b)(c)\2/    //匹配 abcb</code></pre><p>例子：找重复项最多的字符个数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var  str =&quot;assssjdssskssalsssdkjsssdss&quot;;</div><div class="line">var arr = str.split(&apos;&apos;); //把字符串分割为数组</div><div class="line">str = arr.sort().join(&apos;&apos;); //先排序，在转化为字符串</div><div class="line">var value = &apos;&apos;; </div><div class="line">var index = 0;</div><div class="line">var re = /(\w)\1+/g; //匹配字符且重复这个字符，重复次数至少一次</div><div class="line">str.replace(re,function($0,$1) &#123;</div><div class="line">    //$0 代表每次匹配成功的结果：aa dd jj kk l sssssssssssssssss</div><div class="line">    //$1 代表每次匹配成功的第一个子项：a d j k l s</div><div class="line">    if (index&lt;$0.length) &#123;</div><div class="line">        index = $0.length;</div><div class="line">        value = $1;</div><div class="line">    // 没匹配到一次执行一次if语句，直到最后</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">console.log(&apos;最多的字符:&apos;+value+&apos;重复的次数&apos;+index);</div></pre></td></tr></table></figure><p><strong>量词:</strong>代表出现的次数</p><p><code>{n,m}</code>: 至少出现 n 次，最多 m 次</p><p><code>{n,}</code>: 至少 n 次</p><p><code>*</code> ：任意次，相当于{0,}</p><p><code>?</code> : 零次或者一次，相当于{0，1}</p><p><code>+</code> ：至少一次，相当于{1,}</p><p><code>{n}</code>；正好 n 次</p><p>例子：判断是不是 QQ 号</p><p><code>^</code>放在正则最开始的位置，就代表起始的意思，注意<code>/[^a]/</code>和<code>/^[a]/</code>是不一样的，前者是排除的意思，后者代表首位。</p><p><code>$</code>放在正则的最后位置，就代表结束的意思</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//首先想 QQ 号的规则，第一条首位不能是0，第二条必须是5-12位的数字</div><div class="line">var aInput = document.getElementsByTagName(&apos;input&apos;);</div><div class="line">var re = /^[1-9]\d&#123;4,11&#125;$/;</div><div class="line">//为了防止 123456abc 这种情况，所以必须限制最后</div><div class="line">//首位是0-9，接着是4-11位的数字类型</div><div class="line">aInput[1].onclick = function() &#123;</div><div class="line">    if (re.test(aInput[0].value)) &#123;</div><div class="line">        alert(&apos;是 QQ 号&apos;);</div><div class="line">    &#125; else &#123;</div><div class="line">        alert(&apos;不是 QQ 号&apos;);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>例子：去掉前后空格</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var str = &apos;  hello  &apos;;</div><div class="line">alert(&apos;(&apos;+trim(str)+&apos;)&apos;);</div><div class="line">//为了看出区别所以加上括号  (hello)</div><div class="line">function trim(str) &#123;</div><div class="line">    var re = /^\s+|\s+$/g;</div><div class="line">    retrun str.replace(re,&apos;&apos;); //把空格替换成空</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p><strong>常用的一些表单校验</strong></p><p>匹配中文：<code>[\u4e00-\u9fa5]</code> //中文 ACALL 码的范围</p><p>行首行尾空格：<code>^\s*|\s*$</code> //首行出现任意个空格或者尾行出现任意个空格</p><p>Email：<code>^\w+@[a-z0-9]+(\.[a-z]+){1,3}$</code></p><p>//起始至少为一个字符，然后匹配<code>@</code>，接着为任意小写字母或者数字，<br><code>\.</code>代表真正的点，<code>.</code>后面为至少一个字符（a-z），<br>同时这个（比如 .com ）整体为一个子项作为结束，可以出现1-3次。</p><p>网址：<code>[a-zA-Z]+://[^\s]*</code> //匹配不分大小写的任意字母，接着是//，后面是非空格的任意字符</p><p>邮政编码：<code>[1-9]\d{5}</code> //起始数字不能为0，然后是5个数字</p><p>身份证：<code>[1-9]\d{14}|[1-9]\d{17}|[1-9]\d{16}x</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;温故而知新，可以为师矣。对于正则表达式的学习最好的方法还是多练多回顾，复习，走起！&lt;/p&gt;
&lt;p&gt;正则表达式（英文：Regular Expression，在代码中常简写为regex、regexp、RE）使用单个字符串来描述、匹配一系列符合某个语法规则的字符串搜索模式。它可用于所有文本搜索和文本替换的操作。简而言之，它就是通过计算机认识的语言制定的规则，能让计算机帮我们找到对应的东西。&lt;br&gt;
    
    </summary>
    
      <category term="Learning" scheme="http://huguokang.com/categories/Learning/"/>
    
    
      <category term="JavaScript" scheme="http://huguokang.com/tags/JavaScript/"/>
    
      <category term="Regular Expression" scheme="http://huguokang.com/tags/Regular-Expression/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js学习笔记2</title>
    <link href="http://huguokang.com/2017/11/03/Vue.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/"/>
    <id>http://huguokang.com/2017/11/03/Vue.js学习笔记2/</id>
    <published>2017-11-03T01:02:58.000Z</published>
    <updated>2017-11-07T06:45:11.821Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h1><p>Vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。</p><p>在底层的实现上，Vue 将模板编译成虚拟 DOM 渲染函数。<br><a id="more"></a></p><h2 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h2><h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><ol><li><p>使用“Mustache”语法的文本插值：</p><p><code>&lt;span&gt;Message: &lt;/span&gt; //HTML</code></p><p>Mustache 标签将会被替代为对应数据上的<code>msg</code>属性的值。</p></li><li><p>通过使用<code>v-once</code>指令，可以执行一次性的插值，当数据改变时插值处的内容不会更新。这个指令会影响到该节点上所有的数据绑定：</p><p><code>&lt;span v-once&gt;这个将不会改变：&lt;/sapn&gt; //HTML</code></p></li></ol><h3 id="原始-HTML"><a href="#原始-HTML" class="headerlink" title="原始 HTML"></a>原始 HTML</h3><p>双大括号会将数据解释为普通文本，而非 HTML 代码。为了输出 HTML，你需要使用<code>v-html</code>指令：</p><p><code>&lt;div v-html=&quot;rawHtml&quot;&gt;&lt;/div&gt; //HTML</code></p><p>这个<code>div</code>的内容将会被替换成属性值<code>rawHtml</code>，直接作为 HTML –会忽略解析属性值中的数据绑定。</p><p><strong>NOTE:</strong>请只对可信内容使用 HTML 插值，绝不要对用户提供的内容使用插值。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>Mustache 语法不能作用在 HTML 特性上，遇这种情况应该使用<code>v-bind</code>指令：</p><p><code>&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt;  //HTML</code></p><p>这同样适用于布尔类特性，如果求职结果是 falsy 的值，则该特性将会被删除：</p><p><code>&lt;button v-bind:disabled=&quot;isButtonDisabled&quot;&gt;Button&lt;/button&gt; //HTML</code></p><h3 id="使用-JavaScript-表达式"><a href="#使用-JavaScript-表达式" class="headerlink" title="使用 JavaScript 表达式"></a>使用 JavaScript 表达式</h3><p>对于所有的数据绑定，Vue.js 都提供了完全的 JavaScript 表达式支持。</p><p>每个绑定都只能包含<strong>单个表达式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//HTML</div><div class="line">&lt;!-- 这是语句，不是表达式 --&gt;</div><div class="line">&#123;&#123; var a = 1&#125;&#125;</div><div class="line"></div><div class="line">&lt;!-- 流控制不会生效，要改用三元表达式 --&gt;</div><div class="line">&#123;&#123; if (true) &#123; return message &#125; &#125;&#125;</div></pre></td></tr></table></figure><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>指令(Directive)是带有<code>v-</code>前缀的特殊属性。指令属性的值预期是<strong>单个 JavaScript 表达式</strong>。指令的职责是，当表达式的值改变时，将其产生的连带影响响应式地作用于 DOM 。</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>参数在指令名称后面以冒号表示。</p><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>修饰符(Modifiers)是以半角句号<code>.</code>指明的特殊后缀，用于指出一个指令应该特殊方式绑定。例如，<code>.prevent</code>修饰符告诉<code>v-on</code>指令对于触发的事件调用<code>event.preventDefault()</code>:</p><p><code>&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;...&lt;/form&gt; //HTML</code></p><h2 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h2><p>对于一些频繁用到的指令来说，<code>v-</code>前缀让人感到繁琐。同时，在构建由 Vue.js 管理所有模板的<strong>单页面应用程序(SPA-single page application)</strong>时，<code>v-</code>前缀也变得没那么重要了。</p><h3 id="v-bind-缩写"><a href="#v-bind-缩写" class="headerlink" title="v-bind 缩写"></a><code>v-bind</code> 缩写</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//HTML</div><div class="line">&lt;!-- 完整语法 --&gt;</div><div class="line">&lt;a v-bind:href=&quot;url&quot;&gt;...&lt;/a&gt;</div><div class="line"></div><div class="line">&lt;!-- 缩写 --&gt;</div><div class="line">&lt;a :href=&quot;url&quot;&gt;...&lt;/a&gt;</div></pre></td></tr></table></figure><h3 id="v-on-缩写"><a href="#v-on-缩写" class="headerlink" title="v-on 缩写"></a><code>v-on</code> 缩写</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//HTML</div><div class="line">&lt;!-- 完整语法 --&gt;</div><div class="line">&lt;a v-on:click=&quot;doSomething&quot;&gt;...&lt;/a&gt;</div><div class="line"></div><div class="line">&lt;!-- 缩写 --&gt;</div><div class="line">&lt;a @click=&quot;doSomething&quot;&gt;...&lt;/a&gt;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;模板语法&quot;&gt;&lt;a href=&quot;#模板语法&quot; class=&quot;headerlink&quot; title=&quot;模板语法&quot;&gt;&lt;/a&gt;模板语法&lt;/h1&gt;&lt;p&gt;Vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。&lt;/p&gt;
&lt;p&gt;在底层的实现上，Vue 将模板编译成虚拟 DOM 渲染函数。&lt;br&gt;
    
    </summary>
    
      <category term="Learning" scheme="http://huguokang.com/categories/Learning/"/>
    
    
      <category term="Vue.js" scheme="http://huguokang.com/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js学习笔记1</title>
    <link href="http://huguokang.com/2017/11/02/Vue.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"/>
    <id>http://huguokang.com/2017/11/02/Vue.js学习笔记1/</id>
    <published>2017-11-02T13:14:15.000Z</published>
    <updated>2017-11-07T06:45:31.253Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Vue-js是什么"><a href="#Vue-js是什么" class="headerlink" title="Vue.js是什么"></a>Vue.js是什么</h1><p>Vue.js是一套构建用户界面的<em>渐进式框架</em>。与其他重量级框架不同的是，Vue采用自底向上增量开发的设计。</p><a id="more"></a><h1 id="声明式渲染"><a href="#声明式渲染" class="headerlink" title="声明式渲染"></a>声明式渲染</h1><p>Vue.js的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//html</div><div class="line">&lt;div id=&quot;app&gt;</div><div class="line">  &#123;&#123; message &#125;&#125;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//JS</div><div class="line">var app = new Vue(&#123;</div><div class="line">  el: &apos;#app&apos;,</div><div class="line">  data: &#123;</div><div class="line">    message；&apos;Hello Vue&apos;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>现在数据和 DOM 已经被绑定在一起，所有的元素都是响应式的。 </p><h1 id="Vue实例"><a href="#Vue实例" class="headerlink" title="Vue实例"></a>Vue实例</h1><h2 id="创建一个Vue的实例"><a href="#创建一个Vue的实例" class="headerlink" title="创建一个Vue的实例"></a>创建一个Vue的实例</h2><p>每一个Vue应用都是通过<code>Vue</code>函数创建一个新的Vue实例开始的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var vm = new Vue(&#123;</div><div class="line">  // 选项</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>当创建一个Vue实例时，你可以传入一个选项对象。通过使用这些选项来创建你想要的行为。一个Vue应用由一个通过<code>new Vue</code>创建的<em>根Vue实例</em>，以及可选的嵌套的、可复用的组件数组成。</p><h2 id="数据与方法"><a href="#数据与方法" class="headerlink" title="数据与方法"></a>数据与方法</h2><p>当一个Vue实例被创建时，它向Vue的响应式系统中加入其<code>data</code>对象中能找到的所有的属性。当这些属性的值发生改变时，视图将会产生“响应”。</p><p>除了data属性，Vue实例还有很多有用的实例属性和方法。它们都有前缀<code>$</code>，以便与用户定义的属性区分开。可以在<a href="https://cn.vuejs.org/v2/api/#%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7" target="_blank" rel="external">API参考</a>中查阅。</p><h2 id="实例生命周期"><a href="#实例生命周期" class="headerlink" title="实例生命周期"></a>实例生命周期</h2><p>每个 Vue 实例在被创建之前都要经过一系列的初始化过程。例如需要设置数据监听、编译模板、挂载实例到 DOM、在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，给予用户机会在一些特定的场景下添加他们自己的代码。</p><p>比如<code>created</code>钩子可以用来在一个实例被创建之后执行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//JS</div><div class="line">new Vue(&#123;</div><div class="line">  data: &#123;</div><div class="line">    a: 1</div><div class="line">  &#125;,</div><div class="line">  created: function () &#123;</div><div class="line">    // `this` 指向 vm 实例</div><div class="line">    console.log(&apos;a is: &apos; + this.a)</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line">// =&gt; &quot;a is: 1&quot;</div></pre></td></tr></table></figure><p>钩子的<code>this</code>指向调用它的Vue实例。</p><p><em>NOTE:</em>不要在选项属性或回调上使用箭头函数，比如</p><p><code>created: () =&gt; console.log(this.a)</code>或</p><p><code>vm.$watch(&#39;a&#39;, newValue =&gt; this.myMethod())</code></p><p>因为箭头函数是和父级上下文绑定在一起的，<code>this</code>不会是你预期的Vue实例。</p><h2 id="生命周期图示"><a href="#生命周期图示" class="headerlink" title="生命周期图示"></a>生命周期图示</h2><p><img src="http://oy7msxtdy.bkt.clouddn.com/lifecycle.png" alt="生命周期图示"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Vue-js是什么&quot;&gt;&lt;a href=&quot;#Vue-js是什么&quot; class=&quot;headerlink&quot; title=&quot;Vue.js是什么&quot;&gt;&lt;/a&gt;Vue.js是什么&lt;/h1&gt;&lt;p&gt;Vue.js是一套构建用户界面的&lt;em&gt;渐进式框架&lt;/em&gt;。与其他重量级框架不同的是，Vue采用自底向上增量开发的设计。&lt;/p&gt;
    
    </summary>
    
      <category term="Learning" scheme="http://huguokang.com/categories/Learning/"/>
    
    
      <category term="Vue.js" scheme="http://huguokang.com/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>Next的个性化设置</title>
    <link href="http://huguokang.com/2017/10/18/Next%E7%9A%84%E4%B8%AA%E6%80%A7%E5%8C%96%E8%AE%BE%E7%BD%AE/"/>
    <id>http://huguokang.com/2017/10/18/Next的个性化设置/</id>
    <published>2017-10-18T02:14:24.000Z</published>
    <updated>2017-11-08T03:19:11.165Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><strong>NOTE:</strong>Next是Hexo的主题之一。Hexo是一款基于Node.js的静态博客框架，可以方便地生成静态网页并托管在Github上。我的博客就是通过Github+Hexo搭建起来的。</p><a id="more"></a>  <h2 id="个性化设置"><a href="#个性化设置" class="headerlink" title="个性化设置"></a>个性化设置</h2><h3 id="完善个人信息"><a href="#完善个人信息" class="headerlink" title="完善个人信息"></a>完善个人信息</h3><p>打开站点配置文件（本地hexo根目录下的_config.yml文件）完善基本的信息，依次是网站标题、副标题、网站描述、作者、网站语言、时区等。<br><img src="http://oy7msxtdy.bkt.clouddn.com/Next1.png" alt="yourInformation"><br><strong>Tip:</strong>  </p><ol><li>时区就改成Asia/Shanghai，不要多余地改成你的城市，否则会出现 TypeError: Cannot read property ‘offset’ of null<br><img src="http://oy7msxtdy.bkt.clouddn.com/Nest2.png" alt="error">  </li><li>配置信息时冒号后面一定要加空格。  </li></ol><h3 id="添加标签页面"><a href="#添加标签页面" class="headerlink" title="添加标签页面"></a>添加标签页面</h3><ol><li>新建页面<br>在终端窗口下，定位到hexo站点目录（按住shift点击右键，选择“在此处打开命令窗口”）。使用<code>hexo new page</code>新建一个页面，命名为 tags :<br><code>$ hexo new page tags</code><br>此时 sourse 文件夹下会出现名为 tags 的文件夹。  </li><li><p>设置页面类型<br>打开 tags 下的 index.md 文件进行编辑，将页面的类型设置为 tags，主题将自动为这个页面显示标签云。页面内容如下：  </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">title: Tagcloud</div><div class="line">date: 2017-10-18 08:03:58</div><div class="line">type: &quot;tags&quot;</div></pre></td></tr></table></figure></li><li><p>修改菜单<br>在菜单中添加链接。编辑主题配置文件，添加 tags 到 menu 中。只要将 tags 前面的 # 去掉即可。</p></li></ol><h3 id="添加评论系统"><a href="#添加评论系统" class="headerlink" title="添加评论系统"></a>添加评论系统</h3><p>Next 支持多款评论系统，我使用了 <a href="https://disqus.com" target="_blank" rel="external">DISQUS</a> (要翻墙，评论不翻墙也看不了)，注册并获取 shortname 。</p><p>进入主题配置文件，编辑如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">disqus:</div><div class="line">  enable: true</div><div class="line">  shortname: blog-vxrbvtbdqy //你自己的 shortname</div><div class="line">  count: true</div></pre></td></tr></table></figure><p>如需取消某个页面/文章的评论，在 md 文件的 front-matter 中增加<code>comments: false</code></p><h3 id="添加百度分析"><a href="#添加百度分析" class="headerlink" title="添加百度分析"></a>添加百度分析</h3><ol><li><p>登陆<a href="https://tongji.baidu.com" target="_blank" rel="external">百度统计</a>，定位到站点的代码获取页面</p></li><li><p>复制<code>hm.js?</code>后面的一串 id :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">  var _hmt = _hmt || [];</div><div class="line">  (function() &#123;</div><div class="line">  var hm = document.createElement(&quot;script&quot;);</div><div class="line">  hm.src = &quot;https://hm.baidu.com/hm.js?***************&quot;;</div><div class="line">  var s = document.getElementsByTagName(&quot;script&quot;)[0]; </div><div class="line">  s.parentNode.insertBefore(hm, s);</div><div class="line">  &#125;)();</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></li><li><p>编辑主题配置文件，将<code>baidu_analytics</code>的值设置为你的百度统计脚本 id 。</p></li></ol><h3 id="添加文章阅读量统计"><a href="#添加文章阅读量统计" class="headerlink" title="添加文章阅读量统计"></a>添加文章阅读量统计</h3><p>我看了这篇文章<a href="https://notes.wanghao.work/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud" target="_blank" rel="external">为NexT主题添加文章阅读量统计功能</a></p><h3 id="修改文章内链接文本样式"><a href="#修改文章内链接文本样式" class="headerlink" title="修改文章内链接文本样式"></a>修改文章内链接文本样式</h3><p>修改文件 themes\next\source\css_common\components\post\post.styl ，在末尾添加如下css样式：</p><pre><code>// 文章内链接文本样式.post-body p a{  color: #0593d3;  border-bottom: none;  border-bottom: 1px solid #0593d3;  &amp;:hover {    color: #fc6423;    border-bottom: none;    border-bottom: 1px solid #fc6423;  }}</code></pre><h3 id="修改文章底部的那个带-号的标签"><a href="#修改文章底部的那个带-号的标签" class="headerlink" title="修改文章底部的那个带#号的标签"></a>修改文章底部的那个带#号的标签</h3><p>修改模板/themes/next/layout/_macro/post.swig，搜索 <code>rel=&quot;tag&quot;&gt;#</code>，将 # 换成<code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code></p><h3 id="主页文章添加阴影效果"><a href="#主页文章添加阴影效果" class="headerlink" title="主页文章添加阴影效果"></a>主页文章添加阴影效果</h3><p>打开\themes\next\source\css_custom\custom.styl,向里面加入：</p><pre><code>/*主页文章添加阴影效果*/ .post {   margin-top: 60px;   margin-bottom: 60px;   padding: 25px;   -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5);   -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);  }</code></pre><h3 id="安装-RSS-插件"><a href="#安装-RSS-插件" class="headerlink" title="安装 RSS 插件"></a>安装 RSS 插件</h3><ol><li><p>安装插件。进入本地 hexo 目录，按住 shift 点击在此处打开命令窗口，输入以下指令：<code>npm install hexo-generator-feed</code></p></li><li><p>添加配置。打开站点配置文件，添加以下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># Extensions</div><div class="line">## Plugins: http://hexo.io/plugins/</div><div class="line"># RSS订阅</div><div class="line">plugin:</div><div class="line">- hexo-generator-feed</div><div class="line">#Feed Atom</div><div class="line">feed:</div><div class="line">type: atom</div><div class="line">path: atom.xml</div><div class="line">limit: 20</div></pre></td></tr></table></figure></li><li><p>添加主题配置，打开主题配置文件，找到 rss ，添加如下配置：<code>rss: /atom.xml</code></p></li></ol><h3 id="在每篇文章末尾统一添加“本文结束”标记"><a href="#在每篇文章末尾统一添加“本文结束”标记" class="headerlink" title="在每篇文章末尾统一添加“本文结束”标记"></a>在每篇文章末尾统一添加“本文结束”标记</h3><ol><li><p>在路径 \themes\next\layout_macro 中新建 passage-end-tag.swig 文件,并添加以下内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">    &#123;% if not is_index %&#125;</div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"text-align:center;color: #ccc;font-size:14px;"</span>&gt;</span></div><div class="line">            -------------本文结束</div><div class="line">            <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-paw"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></div><div class="line">            感谢您的阅读-------------</div><div class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    &#123;% endif %&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></li><li><p>接着打开 \themes\next\layout_macro\post.swig 文件，我用的 VSCode 按 Ctrl+ f 键搜索 post-footer ，找到这个<code>footer</code>后，在它之前添加如下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">  &#123;% if not is_index %&#125;</div><div class="line">    &#123;% include 'passage-end-tag.swig' %&#125;</div><div class="line">  &#123;% endif %&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></li><li><p>然后打开主题配置文件 _config.yml ，在末尾添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># 文章末尾添加“本文结束”标记</div><div class="line">passage_end_tag:</div><div class="line">enabled: true</div></pre></td></tr></table></figure></li></ol><h3 id="字数和时间统计"><a href="#字数和时间统计" class="headerlink" title="字数和时间统计"></a>字数和时间统计</h3><ol><li><p>在博客根目录打开命令行，输入如下代码：<code>npm install hexo-wordcount --save</code></p></li><li><p>然后在打开 themes\next\layout_macro\post.swig ，搜索Leancloud，在它之前添加如下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-time"</span>&gt;</span></div><div class="line"> &amp;nbsp; | &amp;nbsp;</div><div class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-item-icon"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-calendar-o"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-item-text"</span>&gt;</span>字数统计:<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-count"</span>&gt;</span>&#123;&#123; wordcount(post.content) &#125;&#125;(字)<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">        </div><div class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-time"</span>&gt;</span></div><div class="line"> &amp;nbsp; | &amp;nbsp;</div><div class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-item-icon"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-calendar-o"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-item-text"</span>&gt;</span>阅读时长:<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-count"</span>&gt;</span>&#123;&#123; min2read(post.content) &#125;&#125;(分)<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">        </div><div class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></div></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt;Next是Hexo的主题之一。Hexo是一款基于Node.js的静态博客框架，可以方便地生成静态网页并托管在Github上。我的博客就是通过Github+Hexo搭建起来的。&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://huguokang.com/categories/Tech/"/>
    
    
      <category term="next" scheme="http://huguokang.com/tags/next/"/>
    
      <category term="blog" scheme="http://huguokang.com/tags/blog/"/>
    
  </entry>
  
</feed>
