<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hu Guokang&#39;s Blog</title>
  
  <subtitle>Stupid is as stupid does.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://huguokang.com/"/>
  <updated>2017-11-09T05:06:40.009Z</updated>
  <id>http://huguokang.com/</id>
  
  <author>
    <name>胡国康</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue.js学习笔记5</title>
    <link href="http://huguokang.com/2017/11/09/Vue.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05/"/>
    <id>http://huguokang.com/2017/11/09/Vue.js学习笔记5/</id>
    <published>2017-11-09T00:05:30.000Z</published>
    <updated>2017-11-09T05:06:40.009Z</updated>
    
    <content type="html"><![CDATA[<h1 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h1><h2 id="用v-for把一个数组对应为一个元素"><a href="#用v-for把一个数组对应为一个元素" class="headerlink" title="用v-for把一个数组对应为一个元素"></a>用<code>v-for</code>把一个数组对应为一个元素</h2><p><code>v-for</code>指令需要使用<code>item in items</code>形式的特殊用法，<code>items</code>是源数据数组，<code>item</code>是数组元素迭代的别名。</p><a id="more"></a><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"example-1"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span>&gt;</span></div><div class="line">    &#123;&#123; item.message &#125;&#125;</div><div class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure><hr><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> example1 = <span class="keyword">new</span> Vue(&#123;</div><div class="line">  el: <span class="string">'#example-1'</span>,</div><div class="line">  data: &#123;</div><div class="line">    items: [</div><div class="line">      &#123; <span class="attr">message</span>: <span class="string">'Foo'</span> &#125;,</div><div class="line">      &#123; <span class="attr">message</span>: <span class="string">'Bar'</span> &#125;</div><div class="line">    ]</div><div class="line">  &#125;  </div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>在<code>v-for</code>块中，我们拥有对父作用域属性的完全访问权限。<code>v-for</code>还支持一个可选的第二个参数为当前项的索引。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"example-2"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(item,index) in items"</span>&gt;</span></div><div class="line">    &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125;</div><div class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure><hr><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> example2 = <span class="keyword">new</span> Vue(&#123;</div><div class="line">  el: <span class="string">'#example-2'</span>,</div><div class="line">  data: &#123;</div><div class="line">    parentMessage: <span class="string">'Parent'</span>,</div><div class="line">    items: [</div><div class="line">      &#123; <span class="attr">message</span>: <span class="string">'Foo'</span> &#125;,</div><div class="line">      &#123; <span class="attr">message</span>: <span class="string">'Bar'</span> &#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>可以用<code>of</code>替代<code>in</code>作为分隔符</p><h2 id="一个对象的v-for"><a href="#一个对象的v-for" class="headerlink" title="一个对象的v-for"></a>一个对象的<code>v-for</code></h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"v-for-object"</span> <span class="attr">class</span>=<span class="string">"demo"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"value in object"</span>&gt;</span></div><div class="line">    &#123;&#123; value &#125;&#125;</div><div class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure><hr><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  el: <span class="string">'#v-for-object'</span>,</div><div class="line">  data: &#123;</div><div class="line">    object: &#123;</div><div class="line">      firstName: <span class="string">'John'</span>,</div><div class="line">      lastName: <span class="string">'Doe'</span>,</div><div class="line">      age: <span class="number">30</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>也可以提供第二个的参数为键名：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(value,key) in object"</span>&gt;</span></div><div class="line">  &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p>第三个参数为索引：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(value,key,index) in object"</span>&gt;</span></div><div class="line">  &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p><strong>NOTE:</strong>在遍历对象时，是按<code>object.key()</code>的结果遍历，不能保证它的结果在不同的 JavaScript 引擎下是一致的。</p><p><strong>object.keys()</strong>方法会返回一个由一个给定对象的<strong>自身可枚举属性</strong>组成的数组，数组中的属性排列顺序和使用<code>for...in</code>循环遍历该对象时返回的顺序一致（两者的主要区别是一个<code>for...in</code>循环还会枚举其原型链上的属性）。</p><h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><p>当 Vue.js 用<code>v-for</code>正在更新已渲染过的元素列表时，它默认用“<strong>就地复用</strong>”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处每个元素，并且确保它在特定索引下显示已经被渲染过的每个元素。</p><p>这个默认的模式是高效的，但是只适用于<code>不依赖子组件状态或临时 DOM 状态（例如：表单输入值）的列表渲染输出</code>。</p><p>为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。理想的 key 值是每项都有的且唯一的 id。它的工作方式类似一个属性，所以你需要用<code>v-bind</code>来绑定动态值：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 内容 --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p>建议尽可能在使用<code>v-for</code>时提供<code>key</code>。它是 Vue 识别节点的一个通用机制。</p><h2 id="数组更新检测"><a href="#数组更新检测" class="headerlink" title="数组更新检测"></a>数组更新检测</h2><h3 id="变异方法"><a href="#变异方法" class="headerlink" title="变异方法"></a>变异方法</h3><p>Vue 包含一组观察数组的变异方法，所以它们将会触发视图更新。</p><ul><li>push() 向数组的末尾添加一个或多个元素并返回新的长度。</li><li>pop() 删除数组的最后一个元素并返回删除的元素。</li><li>shift() 删除数组的第一个元素并返回删除的元素。</li><li>unshift() 向数组的开头添加一个或多个元素并返回新的长度。</li><li>splice() 指定位置插入、删除或替换数组的元素。</li><li>sort() 对数组的元素进行排序。</li><li>reverse() 颠倒数组中元素的顺序。  </li></ul><h3 id="替换数组"><a href="#替换数组" class="headerlink" title="替换数组"></a>替换数组</h3><p>变异方法 (mutation method)，顾名思义，会改变被这些方法调用的原始数组。相比之下，也有非变异 (non-mutating method) 方法，例如：<code>filter()</code>、<code>concat()</code>和<code>slice()</code> 。这些不会改变原始数组，但总是返回一个新数组。当使用非变异方法时，可以用新数组替换旧数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">example1.items = example.items.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> item.message.match(<span class="regexp">/Foo/</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure><ul><li>filter() 创建一个新的数组，其包含所有通过所提供函数实现的测试的所有元素。</li><li>concat() 连接两个或多个数组，返回一个新的数组。</li><li>slice() 提取数组中的某个部分，返回一个新的数组。array.slice(start,end(可选，新数组不包括end))</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>由于 JavaScript 的限制，Vue <strong>不能检测以下变动的数组</strong>：</p><ol><li>当你利用索引直接设置一个项时，例如：<code>vm.items[indexOfItem] = newValue</code></li><li>当你修改数组的长度时，例如：<code>vm.items.length = newLength</code></li></ol><p>解决第一类问题的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 第一个方法 Vue.set</span></div><div class="line">Vue.set(example1.items, indexOfItem, newValue)</div><div class="line"></div><div class="line"><span class="comment">// 第二个方法 Array.prototype.splice，参数对应的是起始项，要删除的个数，添加的项</span></div><div class="line">example1.items.splice(indexOfItem, <span class="number">1</span>, newValue)</div></pre></td></tr></table></figure><p>解决第二个类问题的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">example1.items.splice(newLength) <span class="comment">// Vue 的 splice() 可以这样</span></div></pre></td></tr></table></figure><h2 id="对象更改检测注意事项"><a href="#对象更改检测注意事项" class="headerlink" title="对象更改检测注意事项"></a>对象更改检测注意事项</h2><p>还是由于 JavaScript 的限制，Vue <strong>不能检测对象属性的添加或删除</strong>。<br>对于已经创建的实例，Vue 不能动态添加根级别的响应式属性。但是，可以使用<code>Vue.set(object, key, value)</code>方法向嵌套对象添加响应式属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</div><div class="line">  data: &#123;</div><div class="line">    userProfile: &#123;</div><div class="line">      name: <span class="string">'Anika'</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>你可以添加一个新的<code>age</code>属性到嵌套的<code>userProfile</code>对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Vue.set(vm.userProfile,<span class="string">'age'</span>,<span class="number">27</span>)</div></pre></td></tr></table></figure><p>你还可以使用<code>vm.$set</code>实例方法，它只是全局<code>Vue.set</code>的别名：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.$set(<span class="keyword">this</span>.userProfile,<span class="string">'age'</span>,<span class="number">27</span>)</div></pre></td></tr></table></figure><p>有时你可能需要为已有对象赋予多个新属性，比如使用<code>Object.assign()</code>或<code>_.extend()</code>。在这种情况下，你应该用两个对象的属性创建一个新的对象。所以，如果你想添加新的响应式属性，不要像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.assign(<span class="keyword">this</span>.userProfile,&#123;</div><div class="line">  age: <span class="number">27</span>,</div><div class="line">  favoriteColor: <span class="string">"Vue Green"</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>你应该这样做：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.userProfile = <span class="built_in">Object</span>.assign(&#123;&#125;, <span class="keyword">this</span>.userProfile, &#123;</div><div class="line">  age: <span class="number">27</span>,</div><div class="line">  favoriteColor: <span class="string">'Vue Green'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure><h2 id="显示过滤-排序结果"><a href="#显示过滤-排序结果" class="headerlink" title="显示过滤/排序结果"></a>显示过滤/排序结果</h2><p>有时，我们想要显示一个数组的过滤或排序副本，而不实际改变或重置原始数据。在这种情况下，可以创建返回过滤或排序数组的计算属性。</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"n in evenNumbers"</span>&gt;</span>&#123;&#123; n &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div></pre></td></tr></table></figure><hr><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">data: &#123;</div><div class="line">  numbers: [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ]</div><div class="line">&#125;,</div><div class="line">computed: &#123;</div><div class="line">  evenNumbers: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.numbers.filter(<span class="function"><span class="keyword">function</span> (<span class="params">number</span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> number % <span class="number">2</span> === <span class="number">0</span></div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在计算属性不适用的情况下（例如，在嵌套<code>v-for</code>循环中）你可以使用一个 method 方法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"n in even(numbers)"</span>&gt;</span>&#123;&#123; n &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div></pre></td></tr></table></figure><hr><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">data: &#123;</div><div class="line">  numbers: [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</div><div class="line">&#125;,</div><div class="line">methods: &#123;</div><div class="line">  even: <span class="function"><span class="keyword">function</span> (<span class="params">numbers</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> numbers.filter(<span class="function"><span class="keyword">function</span> (<span class="params">number</span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> number % <span class="number">2</span> === <span class="number">0</span></div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="一段取值范围的v-for"><a href="#一段取值范围的v-for" class="headerlink" title="一段取值范围的v-for"></a>一段取值范围的<code>v-for</code></h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-for</span>=<span class="string">"n in 10"</span>&gt;</span>&#123;&#123; n &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p>结果是：1 2 3 4 5 6 7 8 9 10</p><h2 id="v-for-with-v-if"><a href="#v-for-with-v-if" class="headerlink" title="v-for with v-if"></a>v-for with v-if</h2><p>当它们处于同一节点，<code>v-for</code>的优先级比<code>v-if</code>更高，这意味着<code>v-if</code>将分别重复运行于每个 <code>v-for</code>循环中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"todo in todos"</span> <span class="attr">v-if</span>=<span class="string">"!todo.isComplete"</span>&gt;</span></div><div class="line">  &#123;&#123; todo &#125;&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div></pre></td></tr></table></figure><p>上面的 todos 中只有没有完成的 todo 才能被传递。</p><p>而如果你的目的是有条件地跳过循环的执行，那么可以将 v-if 置于外层元素 (或 <code>&lt;template&gt;</code>)上。如： </p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">v-if</span>=<span class="string">"todos.length"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"todo in todos"</span>&gt;</span></div><div class="line">    &#123;&#123; todo &#125;&#125;</div><div class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-else</span>&gt;</span>No todos left!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure><h2 id="一个组件的-v-for"><a href="#一个组件的-v-for" class="headerlink" title="一个组件的 v-for"></a>一个组件的 v-for</h2><p>等我看完组件再回来       </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;列表渲染&quot;&gt;&lt;a href=&quot;#列表渲染&quot; class=&quot;headerlink&quot; title=&quot;列表渲染&quot;&gt;&lt;/a&gt;列表渲染&lt;/h1&gt;&lt;h2 id=&quot;用v-for把一个数组对应为一个元素&quot;&gt;&lt;a href=&quot;#用v-for把一个数组对应为一个元素&quot; class=&quot;headerlink&quot; title=&quot;用v-for把一个数组对应为一个元素&quot;&gt;&lt;/a&gt;用&lt;code&gt;v-for&lt;/code&gt;把一个数组对应为一个元素&lt;/h2&gt;&lt;p&gt;&lt;code&gt;v-for&lt;/code&gt;指令需要使用&lt;code&gt;item in items&lt;/code&gt;形式的特殊用法，&lt;code&gt;items&lt;/code&gt;是源数据数组，&lt;code&gt;item&lt;/code&gt;是数组元素迭代的别名。&lt;/p&gt;
    
    </summary>
    
      <category term="Learning" scheme="http://huguokang.com/categories/Learning/"/>
    
    
      <category term="Vue.js" scheme="http://huguokang.com/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js学习笔记4</title>
    <link href="http://huguokang.com/2017/11/07/Vue.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04/"/>
    <id>http://huguokang.com/2017/11/07/Vue.js学习笔记4/</id>
    <published>2017-11-07T05:36:32.000Z</published>
    <updated>2017-11-08T01:28:32.435Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Class-与-Style-绑定"><a href="#Class-与-Style-绑定" class="headerlink" title="Class 与 Style 绑定"></a>Class 与 Style 绑定</h1><p>操作元素的 class 列表和内联样式是数据绑定的一个常见需求。因为它们都是属性，所以我们可以用<code>v-bind</code>处理它们：只需要通过表达式计算出字符串结果即可。不过，字符串拼接麻烦且易错。对此，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组。</p><a id="more"></a><h2 id="绑定-HTML-Class"><a href="#绑定-HTML-Class" class="headerlink" title="绑定 HTML Class"></a>绑定 HTML Class</h2><h3 id="对象语法"><a href="#对象语法" class="headerlink" title="对象语法"></a>对象语法</h3><p>我们可以传给<code>v-bind:class</code>一个对象来动态地切换 class ：</p><pre><code>// HTML&lt;div v-bind:class=&quot;{ active: isActive }&quot;&gt;&lt;/div&gt;</code></pre><p><code>active</code>这个 class 存在与否取决于数据属性<code>isActive</code>的<code>truthiness</code>。</p><p>你可以在对象中传入更多属性来动态切换多个 class 。此外，<code>v-bind:class</code>指令也可以与普通的 class 属性共存。</p><pre><code>// HTML&lt;div class=&quot;static&quot;     v-bind:class=&quot;{ active: isActive, &apos;text-danger&apos;: hasError }&quot;&gt;&lt;/div&gt;</code></pre><p>下面的 data :</p><pre><code>// JSdata: {  isActive: true,  hasError: false}</code></pre><p>结果渲染为：</p><pre><code>// HTML&lt;div class=&quot;static active&quot;&gt;&lt;/div&gt;</code></pre><p>绑定的数据对象不必内联定义在模版里：</p><pre><code>// HTML&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;</code></pre><hr><pre><code>// JSdata: {  classObject: {    active: true,    &apos;text-danger&apos;: false  }}</code></pre><p>渲染的结果和上面一样。我们也可以在这里绑定一个返回对象的<strong>计算属性</strong>。这是一个常用且强大的模式：</p><pre><code>// HTML&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;</code></pre><hr><pre><code>// JSdata: {  isActive: true,  error: null},computed: {  classObject: function () {    return {      active: this.isActive &amp;&amp; !this.error,      &apos;text-danger&apos;: this.error &amp;&amp; this.error.type === &apos;fatal&apos;    }  }}</code></pre><h3 id="数组语法"><a href="#数组语法" class="headerlink" title="数组语法"></a>数组语法</h3><p>我们可以把一个数组传递给<code>v-bind:class</code>以应用一个 class 列表：</p><pre><code>// HTML&lt;div v-bind:class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;</code></pre><hr><p>   // JS<br>   data: {<br>     activeClass: ‘active’,<br>     errorClass: ‘text-danger’<br>   }</p><p>渲染为：</p><pre><code>// HTML&lt;div class=&quot;active text-danger&quot;&gt;&lt;/div&gt;</code></pre><p>如果你也想根据条件切换列表中的 class ，可以用三元表达式：</p><pre><code>// HTML&lt;div v-bind:class=&quot;[isActive ? activeClass : &apos;&apos;, errorClass]&quot;&gt;&lt;/div&gt;</code></pre><p>当有多个条件 class 时这样写有些繁琐。所以在数组语法中也可以使用对象语法：</p><pre><code>// HTML&lt;div v-bind:class=&quot;[{ active: isActive }, errorClass]&quot;&gt;&lt;/div&gt;</code></pre><h3 id="用在组件上"><a href="#用在组件上" class="headerlink" title="用在组件上"></a>用在组件上</h3><h2 id="绑定内联样式"><a href="#绑定内联样式" class="headerlink" title="绑定内联样式"></a>绑定内联样式</h2><h3 id="对象语法-1"><a href="#对象语法-1" class="headerlink" title="对象语法"></a>对象语法</h3><p><code>v-bind:style</code>的对象语法看着非常像 CSS ，但其实是一个 JavaScript 对象。CSS 属性名可以用驼峰式或短横线分隔（用单引号括起来）来命名：</p><pre><code>// HTML&lt;div v-bind:style=&quot;{ color: activeColor, fontSize: fontSize + &apos;px&apos; }&quot;&gt;&lt;/div&gt;</code></pre><hr><pre><code>data: {  activeColor: &apos;red&apos;,  fontSize: 30}</code></pre><p>直接绑定到一个样式对象会让模板更清晰：</p><pre><code>// HTML&lt;div v-bind:style=&quot;styleObject&quot;&gt;&lt;/div&gt;</code></pre><hr><pre><code>// JSdata: {  styleObject: {    color: &apos;red&apos;,    fontSize: &apos;13px&apos;  }}</code></pre><p>同样的，对象语法常常结合返回对象的计算属性使用。</p><h3 id="数组语法-1"><a href="#数组语法-1" class="headerlink" title="数组语法"></a>数组语法</h3><p><code>v-bind:style</code>的数组语法可以将多个样式对象应用到同一个元素上：</p><pre><code>// HTML&lt;div v-bind:style=&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;/div&gt;</code></pre><h3 id="自动添加前缀"><a href="#自动添加前缀" class="headerlink" title="自动添加前缀"></a>自动添加前缀</h3><p>当<code>v-bind:style</code>使用需要添加浏览器引擎前缀的 CSS 属性时，Vue.js 会自动侦测并添加相应的前缀。</p><h3 id="多重值"><a href="#多重值" class="headerlink" title="多重值"></a>多重值</h3><p>从 2.3.0 起你可以为<code>style</code>绑定中的属性提供一个包含多个值的数组，常用于提供多个带前缀的值，例如：</p><pre><code>// HTML&lt;div :style=&quot;{ display: [&apos;-webkit-box&apos;, &apos;-ms-flebox&apos;, &apos;flex&apos;] }&quot;&gt;&lt;/div&gt;</code></pre><p>这样写只会渲染数组中最后一个被浏览器支持的值。</p><h1 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h1><h2 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h2><p>在字符串模板中，比如 Handlebars ，我们得像这样写一个条件块：</p><pre><code>// HTML&lt;!-- Handlebars 模板 --&gt;{{#if ok}}  &lt;h1&gt;Yes&lt;/h1&gt;{{/if}}</code></pre><p>在 Vue 中。我们使用<code>v-if</code>指令实现同样的功能：</p><pre><code>// HTML&lt;h1 v-if=&quot;ok&quot;&gt;Yes&lt;/h1&gt;  </code></pre><p>也可以用<code>v-esle</code>添加一个“else块”：</p><pre><code>// HTML&lt;h1 v-if=&quot;ok&quot;&gt;Yes&lt;/h1&gt;&lt;h1 v-else&gt;No&lt;/h1&gt;</code></pre><h3 id="在-template-元素上使用-v-if-条件渲染分组"><a href="#在-template-元素上使用-v-if-条件渲染分组" class="headerlink" title="在 template 元素上使用 v-if 条件渲染分组"></a>在 template 元素上使用 v-if 条件渲染分组</h3><p>因为<code>v-if</code>是一个指令，所以必须将它添加到一个元素上。但是如果想切换多个元素呢？此时可以把一个<code>&lt;template&gt;</code>元素当做不可见的包裹元素，并在上面使用<code>v-if</code>。最终的渲染结果将不包含<code>&lt;template&gt;</code>元素。</p><pre><code>// HTML&lt;template v-if=&quot;ok&quot;&gt;  &lt;h1&gt;Title&lt;/h1&gt;  &lt;p&gt;Paragraph 1&lt;/p&gt;  &lt;p&gt;Paragraph 2&lt;/p&gt;&lt;/template&gt;</code></pre><h3 id="v-else"><a href="#v-else" class="headerlink" title="v-else"></a>v-else</h3><p>你可以使用<code>v-else</code>指令来表示<code>v-if</code>的“else块”：</p><pre><code>// HTML&lt;div v-if=&quot;Math.random() &gt; 0.5&quot;&gt;  Now you see me&lt;/div&gt;&lt;div v-else&gt;  Now you don&apos;t&lt;/div&gt;</code></pre><p><code>v-else</code>元素必须跟在带<code>v-if</code>或者<code>v-else-if</code>的元素的后面，否则它将不会被识别。</p><h3 id="v-else-if"><a href="#v-else-if" class="headerlink" title="v-else-if"></a>v-else-if</h3><p>充当<code>v-if</code>的“else-if块”，可以连续使用</p><h3 id="用-key-管理可复用的元素"><a href="#用-key-管理可复用的元素" class="headerlink" title="用 key 管理可复用的元素"></a>用 key 管理可复用的元素</h3><p>Vue 会Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使 Vue 变得非常快之外，还有其它一些好处。例如，如果你允许用户在不同的登录方式之间切换：</p><pre><code>// HTML&lt;template v-if=&quot;loginType === &apos;username&apos;&quot;&gt;  &lt;label&gt;Username&lt;/label&gt;  &lt;input placeholder=&quot;Enter your username&quot;&gt;&lt;/template&gt;&lt;template v-else&gt;  &lt;label&gt;Email&lt;/label&gt;  &lt;input placeholder=&quot;Enter your email address&quot;&gt;&lt;/template&gt;</code></pre><p>上面的代码中切换<code>loginType</code>将不会清除用户已经输入的内容。因为两个模板使用了相同的元素，<code>&lt;input&gt;</code>仅仅替换了它的<code>placeholder</code>。</p><p>这样也不总是符合实际需求，所以 Vue 提供了一种方式来表达“这两个元素是完全独立的，不要复用它们”。只需要添加一个具有唯一值的 key 属性即可：</p><pre><code>// HTML&lt;template v-if=&quot;loginType === &apos;username&apos;&quot;&gt;  &lt;label&gt;Username&lt;/label&gt;  &lt;input placeholder=&quot;Enter your username&quot; key=&quot;username-input&quot;&gt;&lt;/template&gt;&lt;template v-else&gt;  &lt;label&gt;Email&lt;/label&gt;  &lt;input placeholder=&quot;Enter your email address&quot; key=&quot;email-input&quot;&gt;&lt;/template&gt;</code></pre><p>这样的话，每次切换时，输入框都将被重新渲染。<code>&lt;label&gt;</code>元素仍然会被高效地复用。</p><h2 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h2><p><code>v-show</code>也可以根据条件展示元素，不同的是带有<code>v-show</code>的元素始终会被渲染并保留在 DOM 中。<code>v-show</code>只是简单地切换元素的 CSS 属性<code>display</code>。</p><p><strong>NOTE:</strong><code>v-show</code>不支持<code>&lt;template&gt;</code>元素和<code>v-else</code>。</p><h2 id="v-if-vs-v-show"><a href="#v-if-vs-v-show" class="headerlink" title="v-if vs v-show"></a>v-if vs v-show</h2><p><code>v-if</code>是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</p><p><code>v-if</code>也是<strong>惰性的</strong>：如果在初始渲染时条件为假，则什么也不做直到条件第一次变为真时，才会开始渲染条件块。</p><p>相比之下，<code>v-show</code>不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</p><p>一般来说，<code>v-if</code>有更高的切换开销，而<code>v-show</code>有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用<code>v-show</code>较好；如果在运行时条件很少改变，则使用<code>v-if</code>较好。</p><h2 id="v-if-与-v-for-一起使用"><a href="#v-if-与-v-for-一起使用" class="headerlink" title="v-if 与 v-for 一起使用"></a>v-if 与 v-for 一起使用</h2><p>当<code>v-if</code>与<code>v-for</code>一起使用时，<code>v-for</code>具有更高的优先级。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Class-与-Style-绑定&quot;&gt;&lt;a href=&quot;#Class-与-Style-绑定&quot; class=&quot;headerlink&quot; title=&quot;Class 与 Style 绑定&quot;&gt;&lt;/a&gt;Class 与 Style 绑定&lt;/h1&gt;&lt;p&gt;操作元素的 class 列表和内联样式是数据绑定的一个常见需求。因为它们都是属性，所以我们可以用&lt;code&gt;v-bind&lt;/code&gt;处理它们：只需要通过表达式计算出字符串结果即可。不过，字符串拼接麻烦且易错。对此，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组。&lt;/p&gt;
    
    </summary>
    
      <category term="Learning" scheme="http://huguokang.com/categories/Learning/"/>
    
    
      <category term="Vue.js" scheme="http://huguokang.com/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js学习笔记3</title>
    <link href="http://huguokang.com/2017/11/06/Vue.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/"/>
    <id>http://huguokang.com/2017/11/06/Vue.js学习笔记3/</id>
    <published>2017-11-06T11:16:07.000Z</published>
    <updated>2017-11-07T06:45:19.254Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算属性和观察者"><a href="#计算属性和观察者" class="headerlink" title="计算属性和观察者"></a>计算属性和观察者</h1><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>模板内的表达式非常便利，但是设计它们的初衷是用于简单运算。所以不应该在模板中放入太多的逻辑，对于复杂逻辑，应该将其放入<strong>计算属性</strong>。</p><a id="more"></a><h3 id="基础例子"><a href="#基础例子" class="headerlink" title="基础例子"></a>基础例子</h3><pre><code>// HTML&lt;div id=&quot;example&quot;&gt;  &lt;p&gt;Original message: &quot;{{ message }}&quot;&lt;/p&gt;  &lt;p&gt;Computed reversed message: &quot;{{ reverseMessage }}&quot;&lt;/p&gt;&lt;/div&gt;</code></pre><hr><pre><code>// JSvar vm = new Vue({  el: &apos;#example&apos;,  data: {  message: &apos;Hello&apos;  },  computed: {    //计算属性的 getter    reversedMessage: function () {      //&apos;this&apos;指向 vm 实例      return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)    }  }})</code></pre><p>这里我们声明了一个计算属性 <code>reversedMessage</code>。我们提供的函数将用作属性<code>vm.reversedMessage</code>的 getter 函数。</p><p>Vue 知道<code>vm.reversedMessage</code>依赖于<code>vm.message</code>，因此<code>vm.message</code>发生改变时，所有依赖<code>vm.reversedMessage</code>的绑定也会更新。</p><h3 id="计算属性缓存-vs-方法"><a href="#计算属性缓存-vs-方法" class="headerlink" title="计算属性缓存 vs 方法"></a>计算属性缓存 vs 方法</h3><p>从表达式中调用方法可以达到同样的效果：</p><pre><code>// HTML&lt;p&gt;Reversed message: &quot;{{ reversedMessage() }}&quot;&lt;/p&gt;</code></pre><hr><pre><code>//在组件中  JSmethods: {  reversedMessage: function () {    return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)  }}</code></pre><p>我们可以将同一函数定义为方法而不是一个计算属性。结果虽然相同，但是不同的计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值。这就意味着只要<code>message</code>还没发生改变，多次访问<code>reversedMessage</code>计算属性就会立即返回之前的计算结果，而不必再次执行函数。</p><p><code>Date.now()</code>不是响应式依赖，所以下面的计算属性将不再更新：</p><pre><code>// HTMLcomputed: {  now: function () {    return Date.now()  }}</code></pre><p>相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。</p><p>我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 A ，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 A 。如果没有缓存，我们将不可避免的多次执行 A 的 getter ！</p><p>如果你不希望有缓存，请用方法来代替。</p><h3 id="计算属性-vs-侦听属性"><a href="#计算属性-vs-侦听属性" class="headerlink" title="计算属性 vs 侦听属性"></a>计算属性 vs 侦听属性</h3><p>Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：<strong>侦听属性</strong>。当你有一些数据需要随着其他数据变动而变动时，你很容易滥用<code>watch</code>。然而，使用计算属性比命令式的<code>watch</code>回调更好。下面两个比较一下：</p><p><code>&lt;div id=&quot;demo&quot;&gt;&lt;/div&gt;  //HTML</code></p><pre><code>// JSvar vm = new Vue({  el: &apos;#demo&apos;,  data: {    firstName: &apos;Foo&apos;,    lastName: &apos;Bar&apos;,    fullName: &apos;Foo Bar&apos;  },  watch: {    firstName: function (val) {      this.fullName = val + &apos; &apos; + this.lastName    },    lastName: function (val) {      this.fullName = this.firstName + &apos; &apos; + val    }  }})</code></pre><p>上面代码式命令式且重复的。将它与计算属性的版本进行比较:</p><pre><code>// JSvar vm = new Vue({  el: &apos;#demo&apos;,  data: {    firstName: &apos;Foo&apos;,    lastName: &apos;Bar&apos;  },  computed: {    fullName: function () {      return this.firstName + &apos; &apos; + this.lastName    }  }})</code></pre><h3 id="计算属性的-setter"><a href="#计算属性的-setter" class="headerlink" title="计算属性的 setter"></a>计算属性的 setter</h3><p>计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter :</p><pre><code>//...   JScomputed: {  fullName: {    // getter    get: function () {      return this.firstName + &apos; &apos; + this.lastName    },    // setter    set: function (newValue) {      var names = newValue.split(&apos; &apos;)      this.firstName = names[0]      this.lastName = name[name.length - 1]    }  }}// ...</code></pre><p>现在再运行<code>vm.fullName = &#39;John Doe&#39;</code>时，setter 会被调用。<code>vm.firstName</code>和<code>vm.lastName</code>也会相应地被更新。</p><h2 id="侦听器"><a href="#侦听器" class="headerlink" title="侦听器"></a>侦听器</h2><p>虽然计算属性在大多数情况下更合适，但有时也需要一个自定义地侦听器。这就是为什么 Vue 通过 <code>watch</code>选项提供了一个更通用地方法，来响应数据地变化。当需要在数据变化时执行异步或者开销较大的操作时，这个方式是最有用的。</p><p>例如:</p><pre><code>// HTML&lt;div id=&quot;watch-example&quot;&gt;  &lt;p&gt;    Ask a yes/no question    &lt;input v-model=&quot;qusetion&quot;&gt;  &lt;/p&gt;  &lt;p&gt;{{ answer }}&lt;/p&gt;&lt;/div&gt;</code></pre><hr><pre><code>// HTML&lt;!-- 因为 AJAX 库和通用工具的生态已经相当丰富，Vue 核心代码没有重复 --&gt;&lt;!-- 提供这些功能以保持精简，这也可以让你自由选择自己更熟悉的工具 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;var watchExampleVm = new Vue({  el: &apos;#watch-example&apos;,  data: {    question: &apos;&apos;,    answer: &apos;I cannot give you an answer until you ask a question!&apos;  },  watch: {    // 如果&apos;question&apos;发生改变，这个函数就会执行    question: function (newQuestion) {      this.answer = &apos;Waiting for you to stop typing...&apos;      this.getAnswer()    }  },  methods: {    // &apos;_.debunce&apos;是一个通过 Lodash 限制操作频率的函数。    // 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率    // AJAX 请求直到用户输入完毕才会发出。    getAnswer: _.debounce(      function () {        if (this.question.index(&apos;?&apos;) === -1) {          this.answer = &apos;Questions usually contain a question mark. ;-)&apos;          return        }        this.answer = &apos;Thinking...&apos;        var vm = this        axios.get(&apos;https://yesno.wtf/api&apos;)          .then(function (response) {            vn.answer = _.capitalize(response.data.answer)          })          .catch(function (error) {            vm.answer = &apos;Error! Could not reach the API. &apos; + error          })      },      // 这是我们为判定用户停止输入等待的毫秒数      500     )  }})</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;计算属性和观察者&quot;&gt;&lt;a href=&quot;#计算属性和观察者&quot; class=&quot;headerlink&quot; title=&quot;计算属性和观察者&quot;&gt;&lt;/a&gt;计算属性和观察者&lt;/h1&gt;&lt;h2 id=&quot;计算属性&quot;&gt;&lt;a href=&quot;#计算属性&quot; class=&quot;headerlink&quot; title=&quot;计算属性&quot;&gt;&lt;/a&gt;计算属性&lt;/h2&gt;&lt;p&gt;模板内的表达式非常便利，但是设计它们的初衷是用于简单运算。所以不应该在模板中放入太多的逻辑，对于复杂逻辑，应该将其放入&lt;strong&gt;计算属性&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Learning" scheme="http://huguokang.com/categories/Learning/"/>
    
    
      <category term="Vue.js" scheme="http://huguokang.com/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>JS正则表达式复习笔记</title>
    <link href="http://huguokang.com/2017/11/05/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://huguokang.com/2017/11/05/正则表达式/</id>
    <published>2017-11-05T13:40:50.000Z</published>
    <updated>2017-11-07T06:46:12.270Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>温故而知新，可以为师矣。对于正则表达式的学习最好的方法还是多练多回顾，复习，走起！</p><p>正则表达式（英文：Regular Expression，在代码中常简写为regex、regexp、RE）使用单个字符串来描述、匹配一系列符合某个语法规则的字符串搜索模式。它可用于所有文本搜索和文本替换的操作。简而言之，它就是通过计算机认识的语言制定的规则，能让计算机帮我们找到对应的东西。<br><a id="more"></a></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="定义正则"><a href="#定义正则" class="headerlink" title="定义正则"></a>定义正则</h2><ol><li><code>var re = new RegExp(&quot;a&quot;); //RegExp 对象，参数就是我们想要制定的规则</code></li><li><code>var re = /a/; //简写方法（推荐使用，性能更好，不能为空）</code></li></ol><h2 id="正则的常用方法"><a href="#正则的常用方法" class="headerlink" title="正则的常用方法"></a>正则的常用方法</h2><h3 id="test"><a href="#test" class="headerlink" title="test():"></a>test():</h3><p>在字符串中查找符合正则的内容，若查找到返回true，反之则返回false。  </p><p>用法：正则.test(字符串)  </p><p>例子：判断是否是数字 </p><pre><code>var str = &quot;4396&quot;;  var re = /\D/;  //  \D\代表非数字if (re.test(str)){    alert(&quot;不全是数字&quot;);} else{    alert(&quot;全是数字&quot;);}</code></pre><p>正则表达式中有很多符号，代表着不同的意思。  </p><ul><li>\s : 空格</li><li>\S : 非空格</li><li>\d : 数字</li><li>\D : 非数字</li><li>\w : 字符（字母、数字或者下划线）</li><li>\W : 非字符<br>（不罗列了，下面会根据例子依次讲一些常用的字符）</li></ul><h3 id="search"><a href="#search" class="headerlink" title="search():"></a>search():</h3><p>在字符串搜索符合正则的内容，搜索到就返回出现的位置（从0开始，如果匹配的不只是一个字母，那就只会返回第一个字母的位置），如果搜索失败就返回-1。  </p><p>用法：字符串.search(正则)  </p><p><strong>NOTE:</strong> 正则中默认区分大小写，如果想不区分大小写，就在正则的最后加修饰符<code>i</code>（ignore的缩写）。  </p><p>例子：在字符串中查找字母b，且不区分大小写</p><pre><code>var str = &quot;abcdf&quot;;var re = /B/i; //也可以写成 var re = new RegExp(&apos;B&apos;,&apos;i&apos;);alert(str.search(re));  //1</code></pre><h3 id="match"><a href="#match" class="headerlink" title="match():"></a>match():</h3><p>在字符串中搜索符合规则的内容，搜索成功就返回内容，格式为<strong>数组</strong>，失败就返回null。  </p><p>用法：字符串.match(正则)   </p><p>量词：<code>+</code>代表至少匹配一次  </p><p>全局匹配：<code>g</code>（global的缩写，正则中默认，只要搜索到符合规则的内容就会结束搜索）  </p><p>例子：找出指定格式的所有数字  </p><pre><code>var str = &quot;rng1skt2rng3skt45&quot;;var re = /\d/g;  //每次匹配至少一个数字且全局匹配，如果不是全局匹配，当找到数字1，它就会停止。加上全局匹配就会从开始到结束一直去搜索符合规则的。如果没有加号，匹配的结果就是[1,2,3,4,5] ，这并不是我们想要的。alert(str.match(re));  //[1,2,3,45]</code></pre><h3 id="replace"><a href="#replace" class="headerlink" title="replace():"></a>replace():</h3><p>查找符合正则的字符串，就替换成对应的字符串。返回替换后的内容。  </p><p>用法：字符串.replace(正则，新的字符串/回调函数)（在回调函数中，第一个参数指的是每次匹配成功的字符）  </p><p>例子：敏感词过滤。  </p><pre><code>var str = &quot;我爱北京天安门，天安门上太阳升&quot;;var re = /北京|天安门/g;var str2 = str.replace(re,&apos;*&apos;);alert(str2)  //我爱**，*上太阳升//这种只是把找到的变成了一个 * ，并不能几个字就对应几个 * 。</code></pre><p>要想实现几个字对应几个 * ，我们可以用回调函数实现。  </p><pre><code>var str = &quot;我爱北京天安门，天安门上太阳升&quot;var re = /北京|天安门/g;var str2 = str.replace(re,function(str){alert(str); //用来测试：函数的第一个参数代表每次搜索到的符合正则的字符，所以第一次str指的是北京，第二次str是天安门，第三次str是天安门var result = &apos;&apos;;for(var i=0;i&lt;str.length;i++){    result += &apos;*&apos;;}    return result;});alert(str2)  //我爱*****，***上太阳升</code></pre><h2 id="正则中的字符"><a href="#正则中的字符" class="headerlink" title="正则中的字符"></a>正则中的字符</h2><p><strong>():</strong> 小括号，叫做分组符。相当于数学里面的括号。</p><pre><code>var str = &apos;2013-6-7&apos;;var re1 = /\d-+/g;  //全局匹一个数字，横杠，横杠数量至少为1，匹配结果为：[&apos;3-&apos;,&apos;6-&apos;]var re2 = /(\d-)+/g;  //全局匹配数字，横杠，数字和横杠整体数量至少为1，匹配结果为：[&apos;3-6-&apos;]var re3 = /(\d+)(-)/g;  //全局匹配至少一个数字，匹配一个横杠，匹配结果为：[&apos;2013-&apos;,&apos;6-&apos;]</code></pre><p>正则中的每一个带小括号的项，都叫做这个正则的子项。  </p><p>例子：让2013-6-7变成2013.6.7  </p><pre><code>var str = &apos;2013-6-7&apos;;var re = /(\d+)(-)/g;str = str.replace(re,function($0,$1,$2) {//replace()中如果有子项，//第一个参数：$0 (匹配成功后的整体结果 2013-, 6-)，//第二个参数：$1 (匹配成功后的第一个分组，这里指的是 \d ，2013, 6 )，//第三个参数：$2 (匹配成功后的第二个分组，这里指的是 - ，-, -)。    return $1 + &apos;.&apos;;});alert(str);</code></pre><p>match 方法也会返回自己的子项，如下：</p><pre><code>var str = &apos;abc&apos;;var re = /(a)(b)(c)/;alert(str.match(re)); //[abc,a,b,c]//返回的是匹配结果以及每一个子项，当 match 不加 g 的时候才可以取到子项的集合</code></pre><p><strong>补充:</strong>exec() 方法和 match() 方法类似，搜索符合规则的内容，并返回内容，格式为数组。</p><p>用法：正则.exec(字符串)</p><p>属性：input //代表要匹配的字符串；index //每次匹配成功的字符串中第一个字符的位置</p><p>例子一：</p><pre><code>var testStr = &quot;now test001 test002&quot;;var re = /test(\d+)/; //不是全局匹配，只匹配一次var r = re.exec(testStr);console.log(r);//[&apos;test001&apos;,&apos;001&apos;,index:4,input:&apos;now test001 test002&apos;]//返回了包含匹配结果、子项、index属性、input属性的数组//另外 r.length = 2</code></pre><p>例子二：</p><pre><code>var testStr = &quot;now test001 test002&quot;;var re = /test(/d+)/g; //全局匹配var r = re.exec(testStr);console.log(r);//[&apos;test001&apos;,&apos;001&apos;,index:4,input:&apos;now test001 test002&apos;]//结果为啥一样，我用 while 循环，可一直匹配出这个结果，并没有接着上次匹配的位置开//始匹配。</code></pre><p><strong>[]:</strong>表示某个集合中的任意一个，比如[abc]整体代表一个字符，匹配 a b c 中的任意一个，也可以是范围，范围必须从小到大[0-9]。</p><p><strong>[^a]:</strong>整体代表一个字符，<code>^</code>写在<code>[]</code>里面的话，就代表排除的意思。</p><p>例子：匹配 HTML 标签，比如<code>&lt;div class=&quot;b&quot;&gt;hahaha&lt;/div&gt;</code>找出标签<code>&lt;div class=&quot;b&quot;&gt;&lt;/div&gt;</code></p><pre><code>var re = /&lt;[^&gt;]+&gt;/g; //匹配左括号，中间至少一个非右括号的内容（标签里面的一些东西），然后匹配右括号var re = /&lt;[\w\W]+&gt;/g;//匹配左括号，中间至少一个字符或者非字符的内容，然后匹配右括号</code></pre><p><strong>转义字符</strong></p><p>除了前面提到的六个还包括：</p><p><code>.</code> ：任意字符</p><p><code>\.</code>: 真正的点</p><p><code>\b</code> ：独立的部分（起始，结束，空格）</p><p><code>\B</code> : 非独立的部分</p><p>关于最后两个我们来看个例子：</p><pre><code>var str1 = &quot;onetwo&quot;;var str2 = &quot;one two&quot;;var re = /one\b/; //e 后面必须是独立的console.log(re.test(str1)); //falseconsole.log(re.test(str2)); //true</code></pre><p>例子：写一个用 class 名获取节点的函数</p><p>我们之前可能见过这样的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function getByClass(parent,classname) &#123;</div><div class="line">    if (parent.getElementByClassName) &#123;</div><div class="line">        return parent.getElementByClassName(classname);</div><div class="line">    &#125; else &#123;</div><div class="line">        var results = new Array(); //用来存储所有取到的 class 为 box 的元素</div><div class="line">        var elems = parent.getElementsByTagName(&quot;*&quot;);</div><div class="line">        for (var i=0;i&lt;elems.length;i++) &#123;</div><div class="line">            if (elems[i].className == classname) &#123;</div><div class="line">                results.push(elems[i]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return results;    </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这其实是存在问题的，比如它如果一个标签里面有两个 class ，或者存在相同名字的 class ，比如<code>&lt;div class=&quot;box1 box1&quot;&gt;</code>，<code>&lt;div class=&quot;box1 box2&quot;&gt;</code>它就没办法了，我们可以用正则来解决这个问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function getByClass(parent,classname) &#123;</div><div class="line">    if (parent.getElementsByClassName) &#123;</div><div class="line">        return parent.getElementsByClassName(classname);</div><div class="line">    &#125; else &#123;</div><div class="line">        var arr = [];</div><div class="line">        var aEle = parent.getElementsByTagName(&quot;*&quot;);</div><div class="line">        //var re = /\bclassname\b/;</div><div class="line">        //不能这样写，当正则需要用到参数时候，一定要用全称的写法，简写方法会把 //clasname当作一个字符串去匹配。</div><div class="line">        var re = new RegExp(&apos;\\b&apos;+classname+&apos;\\b&apos;);</div><div class="line">        //匹配的时候，classname 前面必须是起始或者空格，后面也是。</div><div class="line">        //默认匹配成功就停止，所以就算有重复的也不会再匹配进去了。</div><div class="line">        //需要注意的是，全称的方式声明正则的时候，参数是字符串类型的，所以我们用//的时候，需要保证这些特殊的字符在字符串内也能输出才行。\b本身是特殊字</div><div class="line">        //符，在字符串中无法输出，需要加反斜杠转义。</div><div class="line">        for (var i=0;i&lt;aEle.length;i++) &#123;</div><div class="line">            if (re.test(aEle[i].className)) &#123;</div><div class="line">                arr.push(aEle[i]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return arr;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>\a:</strong>表示重复的某个子项，比如：</p><p><code>\1</code> ：重复的第一个子项</p><p><code>\2</code> ：重复的第二个子项</p><pre><code>/(a)(b)(c)\1/    //匹配 abca/(a)(b)(c)\1+/   //匹配 abcaa,abcaaa···（子项 a 至少重复一次）/(a)(b)(c)\2/    //匹配 abcb</code></pre><p>例子：找重复项最多的字符个数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var  str =&quot;assssjdssskssalsssdkjsssdss&quot;;</div><div class="line">var arr = str.split(&apos;&apos;); //把字符串分割为数组</div><div class="line">str = arr.sort().join(&apos;&apos;); //先排序，在转化为字符串</div><div class="line">var value = &apos;&apos;; </div><div class="line">var index = 0;</div><div class="line">var re = /(\w)\1+/g; //匹配字符且重复这个字符，重复次数至少一次</div><div class="line">str.replace(re,function($0,$1) &#123;</div><div class="line">    //$0 代表每次匹配成功的结果：aa dd jj kk l sssssssssssssssss</div><div class="line">    //$1 代表每次匹配成功的第一个子项：a d j k l s</div><div class="line">    if (index&lt;$0.length) &#123;</div><div class="line">        index = $0.length;</div><div class="line">        value = $1;</div><div class="line">    // 没匹配到一次执行一次if语句，直到最后</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">console.log(&apos;最多的字符:&apos;+value+&apos;重复的次数&apos;+index);</div></pre></td></tr></table></figure><p><strong>量词:</strong>代表出现的次数</p><p><code>{n,m}</code>: 至少出现 n 次，最多 m 次</p><p><code>{n,}</code>: 至少 n 次</p><p><code>*</code> ：任意次，相当于{0,}</p><p><code>?</code> : 零次或者一次，相当于{0，1}</p><p><code>+</code> ：至少一次，相当于{1,}</p><p><code>{n}</code>；正好 n 次</p><p>例子：判断是不是 QQ 号</p><p><code>^</code>放在正则最开始的位置，就代表起始的意思，注意<code>/[^a]/</code>和<code>/^[a]/</code>是不一样的，前者是排除的意思，后者代表首位。</p><p><code>$</code>放在正则的最后位置，就代表结束的意思</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//首先想 QQ 号的规则，第一条首位不能是0，第二条必须是5-12位的数字</div><div class="line">var aInput = document.getElementsByTagName(&apos;input&apos;);</div><div class="line">var re = /^[1-9]\d&#123;4,11&#125;$/;</div><div class="line">//为了防止 123456abc 这种情况，所以必须限制最后</div><div class="line">//首位是0-9，接着是4-11位的数字类型</div><div class="line">aInput[1].onclick = function() &#123;</div><div class="line">    if (re.test(aInput[0].value)) &#123;</div><div class="line">        alert(&apos;是 QQ 号&apos;);</div><div class="line">    &#125; else &#123;</div><div class="line">        alert(&apos;不是 QQ 号&apos;);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>例子：去掉前后空格</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var str = &apos;  hello  &apos;;</div><div class="line">alert(&apos;(&apos;+trim(str)+&apos;)&apos;);</div><div class="line">//为了看出区别所以加上括号  (hello)</div><div class="line">function trim(str) &#123;</div><div class="line">    var re = /^\s+|\s+$/g;</div><div class="line">    retrun str.replace(re,&apos;&apos;); //把空格替换成空</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p><strong>常用的一些表单校验</strong></p><p>匹配中文：<code>[\u4e00-\u9fa5]</code> //中文 ACALL 码的范围</p><p>行首行尾空格：<code>^\s*|\s*$</code> //首行出现任意个空格或者尾行出现任意个空格</p><p>Email：<code>^\w+@[a-z0-9]+(\.[a-z]+){1,3}$</code></p><p>//起始至少为一个字符，然后匹配<code>@</code>，接着为任意小写字母或者数字，<br><code>\.</code>代表真正的点，<code>.</code>后面为至少一个字符（a-z），<br>同时这个（比如 .com ）整体为一个子项作为结束，可以出现1-3次。</p><p>网址：<code>[a-zA-Z]+://[^\s]*</code> //匹配不分大小写的任意字母，接着是//，后面是非空格的任意字符</p><p>邮政编码：<code>[1-9]\d{5}</code> //起始数字不能为0，然后是5个数字</p><p>身份证：<code>[1-9]\d{14}|[1-9]\d{17}|[1-9]\d{16}x</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;温故而知新，可以为师矣。对于正则表达式的学习最好的方法还是多练多回顾，复习，走起！&lt;/p&gt;
&lt;p&gt;正则表达式（英文：Regular Expression，在代码中常简写为regex、regexp、RE）使用单个字符串来描述、匹配一系列符合某个语法规则的字符串搜索模式。它可用于所有文本搜索和文本替换的操作。简而言之，它就是通过计算机认识的语言制定的规则，能让计算机帮我们找到对应的东西。&lt;br&gt;
    
    </summary>
    
      <category term="Learning" scheme="http://huguokang.com/categories/Learning/"/>
    
    
      <category term="JavaScript" scheme="http://huguokang.com/tags/JavaScript/"/>
    
      <category term="Regular Expression" scheme="http://huguokang.com/tags/Regular-Expression/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js学习笔记2</title>
    <link href="http://huguokang.com/2017/11/03/Vue.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/"/>
    <id>http://huguokang.com/2017/11/03/Vue.js学习笔记2/</id>
    <published>2017-11-03T01:02:58.000Z</published>
    <updated>2017-11-07T06:45:11.821Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h1><p>Vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。</p><p>在底层的实现上，Vue 将模板编译成虚拟 DOM 渲染函数。<br><a id="more"></a></p><h2 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h2><h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><ol><li><p>使用“Mustache”语法的文本插值：</p><p><code>&lt;span&gt;Message: &lt;/span&gt; //HTML</code></p><p>Mustache 标签将会被替代为对应数据上的<code>msg</code>属性的值。</p></li><li><p>通过使用<code>v-once</code>指令，可以执行一次性的插值，当数据改变时插值处的内容不会更新。这个指令会影响到该节点上所有的数据绑定：</p><p><code>&lt;span v-once&gt;这个将不会改变：&lt;/sapn&gt; //HTML</code></p></li></ol><h3 id="原始-HTML"><a href="#原始-HTML" class="headerlink" title="原始 HTML"></a>原始 HTML</h3><p>双大括号会将数据解释为普通文本，而非 HTML 代码。为了输出 HTML，你需要使用<code>v-html</code>指令：</p><p><code>&lt;div v-html=&quot;rawHtml&quot;&gt;&lt;/div&gt; //HTML</code></p><p>这个<code>div</code>的内容将会被替换成属性值<code>rawHtml</code>，直接作为 HTML –会忽略解析属性值中的数据绑定。</p><p><strong>NOTE:</strong>请只对可信内容使用 HTML 插值，绝不要对用户提供的内容使用插值。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>Mustache 语法不能作用在 HTML 特性上，遇这种情况应该使用<code>v-bind</code>指令：</p><p><code>&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt;  //HTML</code></p><p>这同样适用于布尔类特性，如果求职结果是 falsy 的值，则该特性将会被删除：</p><p><code>&lt;button v-bind:disabled=&quot;isButtonDisabled&quot;&gt;Button&lt;/button&gt; //HTML</code></p><h3 id="使用-JavaScript-表达式"><a href="#使用-JavaScript-表达式" class="headerlink" title="使用 JavaScript 表达式"></a>使用 JavaScript 表达式</h3><p>对于所有的数据绑定，Vue.js 都提供了完全的 JavaScript 表达式支持。</p><p>每个绑定都只能包含<strong>单个表达式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//HTML</div><div class="line">&lt;!-- 这是语句，不是表达式 --&gt;</div><div class="line">&#123;&#123; var a = 1&#125;&#125;</div><div class="line"></div><div class="line">&lt;!-- 流控制不会生效，要改用三元表达式 --&gt;</div><div class="line">&#123;&#123; if (true) &#123; return message &#125; &#125;&#125;</div></pre></td></tr></table></figure><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>指令(Directive)是带有<code>v-</code>前缀的特殊属性。指令属性的值预期是<strong>单个 JavaScript 表达式</strong>。指令的职责是，当表达式的值改变时，将其产生的连带影响响应式地作用于 DOM 。</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>参数在指令名称后面以冒号表示。</p><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>修饰符(Modifiers)是以半角句号<code>.</code>指明的特殊后缀，用于指出一个指令应该特殊方式绑定。例如，<code>.prevent</code>修饰符告诉<code>v-on</code>指令对于触发的事件调用<code>event.preventDefault()</code>:</p><p><code>&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;...&lt;/form&gt; //HTML</code></p><h2 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h2><p>对于一些频繁用到的指令来说，<code>v-</code>前缀让人感到繁琐。同时，在构建由 Vue.js 管理所有模板的<strong>单页面应用程序(SPA-single page application)</strong>时，<code>v-</code>前缀也变得没那么重要了。</p><h3 id="v-bind-缩写"><a href="#v-bind-缩写" class="headerlink" title="v-bind 缩写"></a><code>v-bind</code> 缩写</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//HTML</div><div class="line">&lt;!-- 完整语法 --&gt;</div><div class="line">&lt;a v-bind:href=&quot;url&quot;&gt;...&lt;/a&gt;</div><div class="line"></div><div class="line">&lt;!-- 缩写 --&gt;</div><div class="line">&lt;a :href=&quot;url&quot;&gt;...&lt;/a&gt;</div></pre></td></tr></table></figure><h3 id="v-on-缩写"><a href="#v-on-缩写" class="headerlink" title="v-on 缩写"></a><code>v-on</code> 缩写</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//HTML</div><div class="line">&lt;!-- 完整语法 --&gt;</div><div class="line">&lt;a v-on:click=&quot;doSomething&quot;&gt;...&lt;/a&gt;</div><div class="line"></div><div class="line">&lt;!-- 缩写 --&gt;</div><div class="line">&lt;a @click=&quot;doSomething&quot;&gt;...&lt;/a&gt;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;模板语法&quot;&gt;&lt;a href=&quot;#模板语法&quot; class=&quot;headerlink&quot; title=&quot;模板语法&quot;&gt;&lt;/a&gt;模板语法&lt;/h1&gt;&lt;p&gt;Vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。&lt;/p&gt;
&lt;p&gt;在底层的实现上，Vue 将模板编译成虚拟 DOM 渲染函数。&lt;br&gt;
    
    </summary>
    
      <category term="Learning" scheme="http://huguokang.com/categories/Learning/"/>
    
    
      <category term="Vue.js" scheme="http://huguokang.com/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js学习笔记1</title>
    <link href="http://huguokang.com/2017/11/02/Vue.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"/>
    <id>http://huguokang.com/2017/11/02/Vue.js学习笔记1/</id>
    <published>2017-11-02T13:14:15.000Z</published>
    <updated>2017-11-07T06:45:31.253Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue-js是什么"><a href="#Vue-js是什么" class="headerlink" title="Vue.js是什么"></a>Vue.js是什么</h1><p>Vue.js是一套构建用户界面的<em>渐进式框架</em>。与其他重量级框架不同的是，Vue采用自底向上增量开发的设计。</p><a id="more"></a><h1 id="声明式渲染"><a href="#声明式渲染" class="headerlink" title="声明式渲染"></a>声明式渲染</h1><p>Vue.js的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//html</div><div class="line">&lt;div id=&quot;app&gt;</div><div class="line">  &#123;&#123; message &#125;&#125;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//JS</div><div class="line">var app = new Vue(&#123;</div><div class="line">  el: &apos;#app&apos;,</div><div class="line">  data: &#123;</div><div class="line">    message；&apos;Hello Vue&apos;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>现在数据和 DOM 已经被绑定在一起，所有的元素都是响应式的。 </p><h1 id="Vue实例"><a href="#Vue实例" class="headerlink" title="Vue实例"></a>Vue实例</h1><h2 id="创建一个Vue的实例"><a href="#创建一个Vue的实例" class="headerlink" title="创建一个Vue的实例"></a>创建一个Vue的实例</h2><p>每一个Vue应用都是通过<code>Vue</code>函数创建一个新的Vue实例开始的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var vm = new Vue(&#123;</div><div class="line">  // 选项</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>当创建一个Vue实例时，你可以传入一个选项对象。通过使用这些选项来创建你想要的行为。一个Vue应用由一个通过<code>new Vue</code>创建的<em>根Vue实例</em>，以及可选的嵌套的、可复用的组件数组成。</p><h2 id="数据与方法"><a href="#数据与方法" class="headerlink" title="数据与方法"></a>数据与方法</h2><p>当一个Vue实例被创建时，它向Vue的响应式系统中加入其<code>data</code>对象中能找到的所有的属性。当这些属性的值发生改变时，视图将会产生“响应”。</p><p>除了data属性，Vue实例还有很多有用的实例属性和方法。它们都有前缀<code>$</code>，以便与用户定义的属性区分开。可以在<a href="https://cn.vuejs.org/v2/api/#%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7" target="_blank" rel="external">API参考</a>中查阅。</p><h2 id="实例生命周期"><a href="#实例生命周期" class="headerlink" title="实例生命周期"></a>实例生命周期</h2><p>每个 Vue 实例在被创建之前都要经过一系列的初始化过程。例如需要设置数据监听、编译模板、挂载实例到 DOM、在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，给予用户机会在一些特定的场景下添加他们自己的代码。</p><p>比如<code>created</code>钩子可以用来在一个实例被创建之后执行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//JS</div><div class="line">new Vue(&#123;</div><div class="line">  data: &#123;</div><div class="line">    a: 1</div><div class="line">  &#125;,</div><div class="line">  created: function () &#123;</div><div class="line">    // `this` 指向 vm 实例</div><div class="line">    console.log(&apos;a is: &apos; + this.a)</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line">// =&gt; &quot;a is: 1&quot;</div></pre></td></tr></table></figure><p>钩子的<code>this</code>指向调用它的Vue实例。</p><p><em>NOTE:</em>不要在选项属性或回调上使用箭头函数，比如</p><p><code>created: () =&gt; console.log(this.a)</code>或</p><p><code>vm.$watch(&#39;a&#39;, newValue =&gt; this.myMethod())</code></p><p>因为箭头函数是和父级上下文绑定在一起的，<code>this</code>不会是你预期的Vue实例。</p><h2 id="生命周期图示"><a href="#生命周期图示" class="headerlink" title="生命周期图示"></a>生命周期图示</h2><p><img src="http://oy7msxtdy.bkt.clouddn.com/lifecycle.png" alt="生命周期图示"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Vue-js是什么&quot;&gt;&lt;a href=&quot;#Vue-js是什么&quot; class=&quot;headerlink&quot; title=&quot;Vue.js是什么&quot;&gt;&lt;/a&gt;Vue.js是什么&lt;/h1&gt;&lt;p&gt;Vue.js是一套构建用户界面的&lt;em&gt;渐进式框架&lt;/em&gt;。与其他重量级框架不同的是，Vue采用自底向上增量开发的设计。&lt;/p&gt;
    
    </summary>
    
      <category term="Learning" scheme="http://huguokang.com/categories/Learning/"/>
    
    
      <category term="Vue.js" scheme="http://huguokang.com/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>Next的个性化设置</title>
    <link href="http://huguokang.com/2017/10/18/Next%E7%9A%84%E4%B8%AA%E6%80%A7%E5%8C%96%E8%AE%BE%E7%BD%AE/"/>
    <id>http://huguokang.com/2017/10/18/Next的个性化设置/</id>
    <published>2017-10-18T02:14:24.000Z</published>
    <updated>2017-11-08T03:19:11.165Z</updated>
    
    <content type="html"><![CDATA[<p><strong>NOTE:</strong>Next是Hexo的主题之一。Hexo是一款基于Node.js的静态博客框架，可以方便地生成静态网页并托管在Github上。我的博客就是通过Github+Hexo搭建起来的。</p><a id="more"></a>  <h2 id="个性化设置"><a href="#个性化设置" class="headerlink" title="个性化设置"></a>个性化设置</h2><h3 id="完善个人信息"><a href="#完善个人信息" class="headerlink" title="完善个人信息"></a>完善个人信息</h3><p>打开站点配置文件（本地hexo根目录下的_config.yml文件）完善基本的信息，依次是网站标题、副标题、网站描述、作者、网站语言、时区等。<br><img src="http://oy7msxtdy.bkt.clouddn.com/Next1.png" alt="yourInformation"><br><strong>Tip:</strong>  </p><ol><li>时区就改成Asia/Shanghai，不要多余地改成你的城市，否则会出现 TypeError: Cannot read property ‘offset’ of null<br><img src="http://oy7msxtdy.bkt.clouddn.com/Nest2.png" alt="error">  </li><li>配置信息时冒号后面一定要加空格。  </li></ol><h3 id="添加标签页面"><a href="#添加标签页面" class="headerlink" title="添加标签页面"></a>添加标签页面</h3><ol><li>新建页面<br>在终端窗口下，定位到hexo站点目录（按住shift点击右键，选择“在此处打开命令窗口”）。使用<code>hexo new page</code>新建一个页面，命名为 tags :<br><code>$ hexo new page tags</code><br>此时 sourse 文件夹下会出现名为 tags 的文件夹。  </li><li><p>设置页面类型<br>打开 tags 下的 index.md 文件进行编辑，将页面的类型设置为 tags，主题将自动为这个页面显示标签云。页面内容如下：  </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">title: Tagcloud</div><div class="line">date: 2017-10-18 08:03:58</div><div class="line">type: &quot;tags&quot;</div></pre></td></tr></table></figure></li><li><p>修改菜单<br>在菜单中添加链接。编辑主题配置文件，添加 tags 到 menu 中。只要将 tags 前面的 # 去掉即可。</p></li></ol><h3 id="添加评论系统"><a href="#添加评论系统" class="headerlink" title="添加评论系统"></a>添加评论系统</h3><p>Next 支持多款评论系统，我使用了 <a href="https://disqus.com" target="_blank" rel="external">DISQUS</a> (要翻墙，评论不翻墙也看不了)，注册并获取 shortname 。</p><p>进入主题配置文件，编辑如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">disqus:</div><div class="line">  enable: true</div><div class="line">  shortname: blog-vxrbvtbdqy //你自己的 shortname</div><div class="line">  count: true</div></pre></td></tr></table></figure><p>如需取消某个页面/文章的评论，在 md 文件的 front-matter 中增加<code>comments: false</code></p><h3 id="添加百度分析"><a href="#添加百度分析" class="headerlink" title="添加百度分析"></a>添加百度分析</h3><ol><li><p>登陆<a href="https://tongji.baidu.com" target="_blank" rel="external">百度统计</a>，定位到站点的代码获取页面</p></li><li><p>复制<code>hm.js?</code>后面的一串 id :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">  var _hmt = _hmt || [];</div><div class="line">  (function() &#123;</div><div class="line">  var hm = document.createElement(&quot;script&quot;);</div><div class="line">  hm.src = &quot;https://hm.baidu.com/hm.js?***************&quot;;</div><div class="line">  var s = document.getElementsByTagName(&quot;script&quot;)[0]; </div><div class="line">  s.parentNode.insertBefore(hm, s);</div><div class="line">  &#125;)();</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></li><li><p>编辑主题配置文件，将<code>baidu_analytics</code>的值设置为你的百度统计脚本 id 。</p></li></ol><h3 id="添加文章阅读量统计"><a href="#添加文章阅读量统计" class="headerlink" title="添加文章阅读量统计"></a>添加文章阅读量统计</h3><p>我看了这篇文章<a href="https://notes.wanghao.work/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud" target="_blank" rel="external">为NexT主题添加文章阅读量统计功能</a></p><h3 id="修改文章内链接文本样式"><a href="#修改文章内链接文本样式" class="headerlink" title="修改文章内链接文本样式"></a>修改文章内链接文本样式</h3><p>修改文件 themes\next\source\css_common\components\post\post.styl ，在末尾添加如下css样式：</p><pre><code>// 文章内链接文本样式.post-body p a{  color: #0593d3;  border-bottom: none;  border-bottom: 1px solid #0593d3;  &amp;:hover {    color: #fc6423;    border-bottom: none;    border-bottom: 1px solid #fc6423;  }}</code></pre><h3 id="修改文章底部的那个带-号的标签"><a href="#修改文章底部的那个带-号的标签" class="headerlink" title="修改文章底部的那个带#号的标签"></a>修改文章底部的那个带#号的标签</h3><p>修改模板/themes/next/layout/_macro/post.swig，搜索 <code>rel=&quot;tag&quot;&gt;#</code>，将 # 换成<code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code></p><h3 id="主页文章添加阴影效果"><a href="#主页文章添加阴影效果" class="headerlink" title="主页文章添加阴影效果"></a>主页文章添加阴影效果</h3><p>打开\themes\next\source\css_custom\custom.styl,向里面加入：</p><pre><code>/*主页文章添加阴影效果*/ .post {   margin-top: 60px;   margin-bottom: 60px;   padding: 25px;   -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5);   -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);  }</code></pre><h3 id="安装-RSS-插件"><a href="#安装-RSS-插件" class="headerlink" title="安装 RSS 插件"></a>安装 RSS 插件</h3><ol><li><p>安装插件。进入本地 hexo 目录，按住 shift 点击在此处打开命令窗口，输入以下指令：<code>npm install hexo-generator-feed</code></p></li><li><p>添加配置。打开站点配置文件，添加以下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># Extensions</div><div class="line">## Plugins: http://hexo.io/plugins/</div><div class="line"># RSS订阅</div><div class="line">plugin:</div><div class="line">- hexo-generator-feed</div><div class="line">#Feed Atom</div><div class="line">feed:</div><div class="line">type: atom</div><div class="line">path: atom.xml</div><div class="line">limit: 20</div></pre></td></tr></table></figure></li><li><p>添加主题配置，打开主题配置文件，找到 rss ，添加如下配置：<code>rss: /atom.xml</code></p></li></ol><h3 id="在每篇文章末尾统一添加“本文结束”标记"><a href="#在每篇文章末尾统一添加“本文结束”标记" class="headerlink" title="在每篇文章末尾统一添加“本文结束”标记"></a>在每篇文章末尾统一添加“本文结束”标记</h3><ol><li><p>在路径 \themes\next\layout_macro 中新建 passage-end-tag.swig 文件,并添加以下内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">    &#123;% if not is_index %&#125;</div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"text-align:center;color: #ccc;font-size:14px;"</span>&gt;</span></div><div class="line">            -------------本文结束</div><div class="line">            <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-paw"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></div><div class="line">            感谢您的阅读-------------</div><div class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    &#123;% endif %&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></li><li><p>接着打开 \themes\next\layout_macro\post.swig 文件，我用的 VSCode 按 Ctrl+ f 键搜索 post-footer ，找到这个<code>footer</code>后，在它之前添加如下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">  &#123;% if not is_index %&#125;</div><div class="line">    &#123;% include 'passage-end-tag.swig' %&#125;</div><div class="line">  &#123;% endif %&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></li><li><p>然后打开主题配置文件 _config.yml ，在末尾添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># 文章末尾添加“本文结束”标记</div><div class="line">passage_end_tag:</div><div class="line">enabled: true</div></pre></td></tr></table></figure></li></ol><h3 id="字数和时间统计"><a href="#字数和时间统计" class="headerlink" title="字数和时间统计"></a>字数和时间统计</h3><ol><li><p>在博客根目录打开命令行，输入如下代码：<code>npm install hexo-wordcount --save</code></p></li><li><p>然后在打开 themes\next\layout_macro\post.swig ，搜索Leancloud，在它之前添加如下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-time"</span>&gt;</span></div><div class="line"> &amp;nbsp; | &amp;nbsp;</div><div class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-item-icon"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-calendar-o"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-item-text"</span>&gt;</span>字数统计:<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-count"</span>&gt;</span>&#123;&#123; wordcount(post.content) &#125;&#125;(字)<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">        </div><div class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-time"</span>&gt;</span></div><div class="line"> &amp;nbsp; | &amp;nbsp;</div><div class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-item-icon"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-calendar-o"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-item-text"</span>&gt;</span>阅读时长:<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-count"</span>&gt;</span>&#123;&#123; min2read(post.content) &#125;&#125;(分)<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">        </div><div class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></div></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt;Next是Hexo的主题之一。Hexo是一款基于Node.js的静态博客框架，可以方便地生成静态网页并托管在Github上。我的博客就是通过Github+Hexo搭建起来的。&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://huguokang.com/categories/Tech/"/>
    
    
      <category term="next" scheme="http://huguokang.com/tags/next/"/>
    
      <category term="blog" scheme="http://huguokang.com/tags/blog/"/>
    
  </entry>
  
</feed>
